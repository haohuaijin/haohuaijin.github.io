<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HHJ的个人网站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://haohuaijin.github.io/"/>
  <updated>2020-11-23T13:23:42.239Z</updated>
  <id>https://haohuaijin.github.io/</id>
  
  <author>
    <name>HuaiJin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实验6:地址映射与共享</title>
    <link href="https://haohuaijin.github.io/2020/11/23/%E5%AE%9E%E9%AA%8C6-%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/"/>
    <id>https://haohuaijin.github.io/2020/11/23/%E5%AE%9E%E9%AA%8C6-%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E4%B8%8E%E5%85%B1%E4%BA%AB/</id>
    <published>2020-11-23T13:22:32.000Z</published>
    <updated>2020-11-23T13:23:42.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>本次实验的基本内容是：</p><ul><li>用 Bochs 调试工具跟踪 Linux 0.11 的地址翻译（地址映射）过程，了解 IA-32 和 Linux 0.11 的内存管理机制；</li><li>在 Ubuntu 上编写多进程的生产者—消费者程序，用共享内存做缓冲区；</li><li>在信号量实验的基础上，为 Linux 0.11 增加共享内存功能，并将生产者—消费者程序移植到 Linux 0.11。</li></ul><h3 id="1-跟踪地址翻译过程"><a href="#1-跟踪地址翻译过程" class="headerlink" title="1. 跟踪地址翻译过程"></a>1. 跟踪地址翻译过程</h3><p>首先以汇编级调试的方式启动 Bochs，引导 Linux 0.11，在 0.11 下编译和运行 test.c。它是一个无限循环的程序，永远不会主动退出。然后在调试器中通过查看各项系统参数，从逻辑地址、LDT 表、GDT 表、线性地址到页表，计算出变量 <code>i</code> 的物理地址。最后通过直接修改物理内存的方式让 test.c 退出运行。</p><p>test.c 的代码如下：</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The logical/virtual address of i is 0x%08x"</span>, &amp;i);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">while</span> (i)</span><br><span class="line">        ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-基于共享内存的生产者—消费者程序"><a href="#2-基于共享内存的生产者—消费者程序" class="headerlink" title="2. 基于共享内存的生产者—消费者程序"></a>2. 基于共享内存的生产者—消费者程序</h3><p>本项实验在 Ubuntu 下完成，与信号量实验中的 <code>pc.c</code> 的功能要求基本一致，仅有两点不同：</p><ul><li>不用文件做缓冲区，而是使用共享内存；</li><li>生产者和消费者分别是不同的程序。生产者是 producer.c，消费者是 consumer.c。两个程序都是单进程的，通过信号量和缓冲区进行通信。</li></ul><p>Linux 下，可以通过 <code>shmget()</code> 和 <code>shmat()</code> 两个系统调用使用共享内存。</p><h3 id="3-共享内存的实现"><a href="#3-共享内存的实现" class="headerlink" title="3. 共享内存的实现"></a>3. 共享内存的实现</h3><p>进程之间可以通过页共享进行通信，被共享的页叫做共享内存，结构如下图所示：</p><p><img src="https://doc.shiyanlou.com/userid19614labid573time1424086247964" alt="图片描述信息"></p><p>图 1 进程间共享内存的结构</p><p>本部分实验内容是在 Linux 0.11 上实现上述页面共享，并将上一部分实现的 producer.c 和 consumer.c 移植过来，验证页面共享的有效性。</p><p>具体要求在 <code>mm/shm.c</code> 中实现 <code>shmget()</code> 和 <code>shmat()</code> 两个系统调用。它们能支持 <code>producer.c</code> 和 <code>consumer.c</code> 的运行即可，不需要完整地实现 POSIX 所规定的功能。</p><ul><li>shmget()</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p><code>shmget()</code> 会新建/打开一页内存，并返回该页共享内存的 shmid（该块共享内存在操作系统内部的 id）。</p><p>所有使用同一块共享内存的进程都要使用相同的 key 参数。</p><p>如果 key 所对应的共享内存已经建立，则直接返回 <code>shmid</code>。如果 size 超过一页内存的大小，返回 <code>-1</code>，并置 <code>errno</code> 为 <code>EINVAL</code>。如果系统无空闲内存，返回 -1，并置 <code>errno</code> 为 <code>ENOMEM</code>。</p><p><code>shmflg</code> 参数可忽略。</p><ul><li>shmat()</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p><code>shmat()</code> 会将 <code>shmid</code> 指定的共享页面映射到当前进程的虚拟地址空间中，并将其首地址返回。</p><p>如果 <code>shmid</code> 非法，返回 <code>-1</code>，并置 <code>errno</code> 为 <code>EINVAL</code>。</p><p><code>shmaddr</code> 和 <code>shmflg</code> 参数可忽略。</p><h2 id="1-跟踪地址翻译过程-1"><a href="#1-跟踪地址翻译过程-1" class="headerlink" title="1. 跟踪地址翻译过程"></a>1. 跟踪地址翻译过程</h2><p>这个跟着实验报告做即可。</p><h2 id="2-基于共享内存的生产者—消费者程序-1"><a href="#2-基于共享内存的生产者—消费者程序-1" class="headerlink" title="2. 基于共享内存的生产者—消费者程序"></a>2. 基于共享内存的生产者—消费者程序</h2><p><code>producer.c</code>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUMBER 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUFFER 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建信号量</span></span><br><span class="line">    <span class="keyword">sem_t</span>* full = sem_open(<span class="string">"/full"</span>, O_CREAT, <span class="number">0666</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">sem_t</span>* mutex = sem_open(<span class="string">"/mutex"</span>, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">sem_t</span>* empty = sem_open(<span class="string">"/empty"</span>, O_CREAT, <span class="number">0666</span>, MAX_BUFFER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">position</span>, shmid;</span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">key_t</span> key = <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line">    shmid = shmget(key, (MAX_BUFFER+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0644</span> | IPC_CREAT);</span><br><span class="line">    data = (<span class="keyword">int</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; MAX_NUMBER+<span class="number">1</span>; i++)&#123;</span><br><span class="line">        sem_wait(empty);</span><br><span class="line">        sem_wait(mutex);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">position</span> = (i % MAX_BUFFER);</span><br><span class="line">        data[<span class="built_in">position</span>] = i;</span><br><span class="line"></span><br><span class="line">        sem_post(mutex);</span><br><span class="line">        sem_post(full);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>consumer.c</code>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUMBER 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUFFER 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建信号量</span></span><br><span class="line">    <span class="keyword">sem_t</span>* full = sem_open(<span class="string">"/full"</span>, O_CREAT, <span class="number">0666</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">sem_t</span>* mutex = sem_open(<span class="string">"/mutex"</span>, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">sem_t</span>* empty = sem_open(<span class="string">"/empty"</span>, O_CREAT, <span class="number">0666</span>, MAX_BUFFER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp, shmid;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">position</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *data;</span><br><span class="line">    <span class="keyword">key_t</span> key = <span class="number">9999</span>;</span><br><span class="line"></span><br><span class="line">    shmid = shmget(key, (MAX_BUFFER+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">0644</span> | IPC_CREAT);</span><br><span class="line">    data = (<span class="keyword">int</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sem_wait(full);</span><br><span class="line">        sem_wait(mutex);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">position</span> = (<span class="built_in">position</span> % MAX_BUFFER);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: %d\n"</span>, getpid(), data[<span class="built_in">position</span>]);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">if</span>(data[<span class="built_in">position</span>] == MAX_NUMBER)&#123;</span><br><span class="line">            sem_post(mutex);</span><br><span class="line">            sem_post(empty);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">position</span>++;</span><br><span class="line">        </span><br><span class="line">        sem_post(mutex);</span><br><span class="line">        sem_post(empty);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(data);</span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    sem_close(full);</span><br><span class="line">    sem_close(mutex);</span><br><span class="line">    sem_close(empty);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-共享内存的实现-1"><a href="#3-共享内存的实现-1" class="headerlink" title="3. 共享内存的实现"></a>3. 共享内存的实现</h2><p>共享内存的实现需要在实验5：信号量的实验与应用的基础上，在实验5的基础上再添加两个系统调用<code>shmget()</code>和<code>shmat</code>。需要添加的<code>shm.c</code>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;a.out.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_shmget</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> allKey[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">void</span> *allAddress[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> countKey;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * shmget() 会新建/打开一页内存，并返回该页共享内存的 shmid（该块共享内存在操作系统内部的 id）。</span></span><br><span class="line"><span class="comment"> * 所有使用同一块共享内存的进程都要使用相同的 key 参数。</span></span><br><span class="line"><span class="comment"> * 如果 key 所对应的共享内存已经建立，则直接返回 shmid。</span></span><br><span class="line"><span class="comment"> * 如果 size 超过一页内存的大小，返回 -1，并置 errno 为 EINVAL。</span></span><br><span class="line"><span class="comment"> * 如果系统无空闲内存，返回 -1，并置 errno 为 ENOMEM。</span></span><br><span class="line"><span class="comment"> * shmflg 参数可忽略。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_shmget</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> shmflg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;countKey; i++)</span><br><span class="line">        <span class="keyword">if</span>(allKey[i] == key)</span><br><span class="line">            <span class="keyword">return</span> key; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> &gt; <span class="number">4096</span>)&#123;</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tmp = get_free_page();</span><br><span class="line">    <span class="keyword">if</span>(tmp == <span class="number">0</span>)&#123;</span><br><span class="line">        printk(<span class="string">"don't have page.\n"</span>);</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    allKey[countKey] = key;</span><br><span class="line">    allAddress[countKey] = (<span class="keyword">void</span>*)tmp;</span><br><span class="line">    countKey++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * shmat() 会将 shmid 指定的共享页面映射到当前进程的虚拟地址空间中，并将其首地址返回。</span></span><br><span class="line"><span class="comment"> * 如果 shmid 非法，返回 -1，并置 errno 为 EINVAL。</span></span><br><span class="line"><span class="comment"> * shmaddr 和 shmflg 参数可忽略。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> data_limit, data_base, data;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">void</span> * result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;countKey; i++)</span><br><span class="line">        <span class="keyword">if</span>(allKey[i] == shmid)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(i == countKey) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    result = allAddress[i];</span><br><span class="line">data_limit = <span class="number">0x4000000</span>;</span><br><span class="line">data_base = get_base(current-&gt;ldt[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * I don't know why he is work ,but it work.</span></span><br><span class="line"><span class="comment">     * Because i don't find the data segment end, so i use this. </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    data = data_base + data_limit;</span><br><span class="line">    data -= <span class="number">10</span>*PAGE_SIZE; </span><br><span class="line">    put_page(result, data);</span><br><span class="line">    data -= data_base; </span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot; class=&quot;headerlink&quot; title=&quot;实验内容&quot;&gt;&lt;/a&gt;实验内容&lt;/h2&gt;&lt;p&gt;本次实验的基本内容是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 Bochs 调试工具跟踪 Linux 0.11 的地址翻译（地址映射）过程，了解 IA-32 和 Linux 0.11 的内存管理机制；&lt;/li&gt;
&lt;li&gt;在 Ubuntu 上编写多进程的生产者—消费者程序，用共享内存做缓冲区；&lt;/li&gt;
&lt;li&gt;在信号量实验的基础上，为 Linux 0.11 增加共享内存功能，并将生产者—消费者程序移植到 Linux 0.11。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-跟踪地址翻译过程&quot;&gt;&lt;a href=&quot;#1-跟踪地址翻译过程&quot; class=&quot;headerlink&quot; title=&quot;1. 跟踪地址翻译过程&quot;&gt;&lt;/a&gt;1. 跟踪地址翻译过程&lt;/h3&gt;&lt;p&gt;首先以汇编级调试的方式启动 Bochs，引导 Linux 0.11，在 0.11 下编译和运行 test.c。它是一个无限循环的程序，永远不会主动退出。然后在调试器中通过查看各项系统参数，从逻辑地址、LDT 表、GDT 表、线性地址到页表，计算出变量 &lt;code&gt;i&lt;/code&gt; 的物理地址。最后通过直接修改物理内存的方式让 test.c 退出运行。&lt;/p&gt;
&lt;p&gt;test.c 的代码如下：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="https://haohuaijin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Bomb lab</title>
    <link href="https://haohuaijin.github.io/2020/11/22/CSAPP-Bomb-lab/"/>
    <id>https://haohuaijin.github.io/2020/11/22/CSAPP-Bomb-lab/</id>
    <published>2020-11-22T07:47:15.000Z</published>
    <updated>2020-11-22T07:48:45.160Z</updated>
    
    <content type="html"><![CDATA[<p>CSAPP的bomb lab是让你通过反汇编和gdb，找到六个相应的字符串，来拆掉炸弹。</p><p>本实验一共六个阶段，每个阶段对应一个字符串。在完成这六个阶段以后，还有一个彩蛋secret_phase。彩蛋可以在反汇编的代码中看到，只能通过gdb进入，没有出现在<code>main</code>函数中。</p><p>整个实验的整体框架可以在<code>bomb.c</code>文件中看到。主要是用的工具是gdb和objdump。</p><p>下面的代码都是在gdb中反汇编出来的代码，通过gdb反汇编出来的代码跳转地址是用的绝对地址，比较好看。</p><a id="more"></a><h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase_1"></a>Phase_1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">phase_1:</span><br><span class="line">   0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi</span><br><span class="line">   0x0000000000400ee9 &lt;+9&gt;:     callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax</span><br><span class="line">   0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line">   0x0000000000400ef2 &lt;+18&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x0000000000400efb &lt;+27&gt;:    retq</span><br></pre></td></tr></table></figure><p>第一阶段是将输入的字符串与位于<code>0x402400</code>比较，如果相等则成功。函数<code>strings_not_equal</code>做的事情就是比较两个字符串，如果相等就返回0，反之返回1。</p><p>在<code>strings_not_equla</code>中首先调用<code>string_length</code>测量两个字符串的长度，不想等直接返回1，相等的话在逐一比对字符串中的字符，全部相等返回0。</p><p>答案就是储存在<code>0x402400</code>里面的字符：<code>Border relations with Canada have never been better.</code></p><h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase_2"></a>Phase_2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">phase_2:</span><br><span class="line">   0x0000000000400efc &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x0000000000400efd &lt;+1&gt;:     push   %rbx</span><br><span class="line">   0x0000000000400efe &lt;+2&gt;:     sub    $0x28,%rsp</span><br><span class="line">   0x0000000000400f02 &lt;+6&gt;:     mov    %rsp,%rsi</span><br><span class="line">   0x0000000000400f05 &lt;+9&gt;:     callq  0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">   0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)</span><br><span class="line">   0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400f10 &lt;+20&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax</span><br><span class="line">   0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax</span><br><span class="line">   0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)</span><br><span class="line">   0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;</span><br><span class="line">   0x0000000000400f20 &lt;+36&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx</span><br><span class="line">   0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx</span><br><span class="line">   0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;</span><br><span class="line">   0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx</span><br><span class="line">   0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp</span><br><span class="line">   0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp</span><br><span class="line">   0x0000000000400f40 &lt;+68&gt;:    pop    %rbx</span><br><span class="line">   0x0000000000400f41 &lt;+69&gt;:    pop    %rbp</span><br><span class="line">   0x0000000000400f42 &lt;+70&gt;:    retq</span><br></pre></td></tr></table></figure><p>第二阶段让我们输入六个数字，通过<code>read_six_numbers</code>，把输入的六个数字储存在栈中。并且第一个数字必须是1(代码<code>0x400f0a</code>)，然后通过一个循环(从<code>0x400f1a</code>到<code>0x400f2c</code>)来计算后一个数必须是前一个数的两倍，而且我们知道第一个数必须是1。所以答案是：<code>1 2 4 8 16 32</code>。</p><h2 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase_3"></a>Phase_3</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">phase_3: </span><br><span class="line">   0x0000000000400f43 &lt;+0&gt;:     sub    $0x18,%rsp</span><br><span class="line">   0x0000000000400f47 &lt;+4&gt;:     lea    0xc(%rsp),%rcx</span><br><span class="line">   0x0000000000400f4c &lt;+9&gt;:     lea    0x8(%rsp),%rdx</span><br><span class="line">   0x0000000000400f51 &lt;+14&gt;:    mov    $0x4025cf,%esi</span><br><span class="line">   0x0000000000400f56 &lt;+19&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000400f5b &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000400f60 &lt;+29&gt;:    cmp    $0x1,%eax</span><br><span class="line">   0x0000000000400f63 &lt;+32&gt;:    jg     0x400f6a &lt;phase_3+39&gt;</span><br><span class="line">   0x0000000000400f65 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp)</span><br><span class="line">   0x0000000000400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;</span><br><span class="line">   0x0000000000400f71 &lt;+46&gt;:    mov    0x8(%rsp),%eax</span><br><span class="line">   0x0000000000400f75 &lt;+50&gt;:    jmpq   *0x402470(,%rax,8)</span><br><span class="line">   0x0000000000400f7c &lt;+57&gt;:    mov    $0xcf,%eax</span><br><span class="line">   0x0000000000400f81 &lt;+62&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f83 &lt;+64&gt;:    mov    $0x2c3,%eax</span><br><span class="line">   0x0000000000400f88 &lt;+69&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f8a &lt;+71&gt;:    mov    $0x100,%eax</span><br><span class="line">   0x0000000000400f8f &lt;+76&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f91 &lt;+78&gt;:    mov    $0x185,%eax</span><br><span class="line">   0x0000000000400f96 &lt;+83&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f98 &lt;+85&gt;:    mov    $0xce,%eax</span><br><span class="line">   0x0000000000400f9d &lt;+90&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f9f &lt;+92&gt;:    mov    $0x2aa,%eax</span><br><span class="line">   0x0000000000400fa4 &lt;+97&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fa6 &lt;+99&gt;:    mov    $0x147,%eax</span><br><span class="line">   0x0000000000400fab &lt;+104&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fad &lt;+106&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fb2 &lt;+111&gt;:   mov    $0x0,%eax</span><br><span class="line">   0x0000000000400fb7 &lt;+116&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fb9 &lt;+118&gt;:   mov    $0x137,%eax</span><br><span class="line">   0x0000000000400fbe &lt;+123&gt;:   cmp    0xc(%rsp),%eax</span><br><span class="line">   0x0000000000400fc2 &lt;+127&gt;:   je     0x400fc9 &lt;phase_3+134&gt;</span><br><span class="line">   0x0000000000400fc4 &lt;+129&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fc9 &lt;+134&gt;:   add    $0x18,%rsp</span><br><span class="line">   0x0000000000400fcd &lt;+138&gt;:   retq</span><br></pre></td></tr></table></figure><p>第三阶段相当于一个<code>switch</code>结构，要输入两个数字，并切第一个数字不能大于7。第二个数字通过位于<code>0x400f75</code>的这条命令找到，这条命令的意思是，跳转到<code>0x402470(,%rax,8)</code>里面值的位置处。通过查看内存<code>0x402470</code>里面储存的值，我们很容易得到跳转后的地址。</p><p>内存<code>0x402470</code>处的地址如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x402470:       0x00400f7c      0x00000000      0x00400fb9      0x00000000</span><br><span class="line">0x402480:       0x00400f83      0x00000000      0x00400f8a      0x00000000</span><br><span class="line">0x402490:       0x00400f91      0x00000000      0x00400f98      0x00000000</span><br><span class="line">0x4024a0:       0x00400f9f      0x00000000      0x00400fa6      0x00000000</span><br></pre></td></tr></table></figure><p>答案有以下几个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 207</span><br><span class="line">1 311</span><br><span class="line">2 707</span><br><span class="line">3 256</span><br><span class="line">4 389</span><br><span class="line">5 206</span><br><span class="line">6 682</span><br><span class="line">7 327</span><br></pre></td></tr></table></figure><h2 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase_4"></a>Phase_4</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">phase_4:</span><br><span class="line">   0x000000000040100c &lt;+0&gt;:     sub    $0x18,%rsp</span><br><span class="line">   0x0000000000401010 &lt;+4&gt;:     lea    0xc(%rsp),%rcx</span><br><span class="line">   0x0000000000401015 &lt;+9&gt;:     lea    0x8(%rsp),%rdx</span><br><span class="line">   0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi</span><br><span class="line">   0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000401024 &lt;+24&gt;:    callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax</span><br><span class="line">   0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;</span><br><span class="line">   0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)</span><br><span class="line">   0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;</span><br><span class="line">   0x0000000000401035 &lt;+41&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx</span><br><span class="line">   0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi</span><br><span class="line">   0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi</span><br><span class="line">   0x0000000000401048 &lt;+60&gt;:    callq  0x400fce &lt;func4&gt;</span><br><span class="line">   0x000000000040104d &lt;+65&gt;:    test   %eax,%eax</span><br><span class="line">   0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;</span><br><span class="line">   0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)</span><br><span class="line">   0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;</span><br><span class="line">   0x0000000000401058 &lt;+76&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp</span><br><span class="line">   0x0000000000401061 &lt;+85&gt;:    retq</span><br></pre></td></tr></table></figure><p>第四阶段也是输入两个数字。首先通过<code>sscanf</code>读入两个数字放入<code>0x8(%rsp)</code>和<code>0xc(%rsp)</code>。并且第一个数字要小于等于<code>14</code>，第二个数字要等于<code>0</code>。我第一次尝试用<code>1 0</code>，加成功了，加没怎么仔细看<code>func4</code>。</p><p>答案就是:<code>1 0</code>。</p><h2 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase_5"></a>Phase_5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">phase_5:</span><br><span class="line">   0x0000000000401062 &lt;+0&gt;:     push   %rbx</span><br><span class="line">   0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp</span><br><span class="line">   0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx</span><br><span class="line">   0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax</span><br><span class="line">   0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)</span><br><span class="line">   0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax</span><br><span class="line">   0x000000000040107a &lt;+24&gt;:    callq  0x40131b &lt;string_length&gt;</span><br><span class="line">   0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax</span><br><span class="line">   0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x0000000000401084 &lt;+34&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">   0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">   0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)</span><br><span class="line">   0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx</span><br><span class="line">   0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx</span><br><span class="line">   0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">   0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">   0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax</span><br><span class="line">   0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax</span><br><span class="line">   0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)</span><br><span class="line">   0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi</span><br><span class="line">   0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi</span><br><span class="line">   0x00000000004010bd &lt;+91&gt;:    callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax</span><br><span class="line">   0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010c6 &lt;+100&gt;:   callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)</span><br><span class="line">   0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line">   0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax</span><br><span class="line">   0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;</span><br><span class="line">   0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax</span><br><span class="line">   0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax</span><br><span class="line">   0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;</span><br><span class="line">   0x00000000004010e9 &lt;+135&gt;:   callq  0x400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp</span><br><span class="line">   0x00000000004010f2 &lt;+144&gt;:   pop    %rbx</span><br><span class="line">   0x00000000004010f3 &lt;+145&gt;:   retq</span><br></pre></td></tr></table></figure><p>第五阶段输入的是一个长度为6的字符串，从地址<code>0x40108b</code>到<code>0x4010ac</code>是一个循环，通过将输入的字符的低八位作为索引，从地址<code>0x4024b0</code>中取出字符来放入到栈中(<code>0x10(%rsp)</code>)。然后将栈中的字符串与位于<code>0x40245e</code>的字符串比较，如果相等就通过。</p><p>地址<code>0x4024b0</code>存放的字符串是：<code>maduiersnfotvbyl</code>。</p><p>答案是：<code>ionefg</code>，在地址<code>0x40245e</code>里面的字符串是<code>flyers</code>。</p><h2 id="Phase-6"><a href="#Phase-6" class="headerlink" title="Phase_6"></a>Phase_6</h2><p>第六阶段的代码比较长，主要分成来一下几个阶段</p><ul><li><p>将输入的六个数字放到栈中(<code>%rsp</code>)；</p></li><li><p>查看读入的六个数字，是否互不相等，并且在1，2，3，4，5，6中取值；</p></li><li><p>用7 - 输入的六个数字，覆盖原来存放在栈中(<code>%rsp</code>)的数字；</p></li><li><p>利用现在栈中(<code>%rsp</code>)的数字和地址<code>0x6032d0</code>处的内容，填充地址<code>0x20(%rsp)</code>到<code>0x50(%rsp)</code>；</p></li><li><p>然后利用地址<code>0x20(%rsp)</code>到<code>0x50(%rsp)</code>的数据，填充地址<code>0x6032d0</code>到<code>0x603320</code>处；</p></li><li><p>最后根据<code>0x6032d0</code>到<code>0x603320</code>，如下面所示</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x6032d0 &lt;node1&gt;:       0x0000014c      0x00000001      0x00000000      0x00000000</span><br><span class="line">0x6032e0 &lt;node2&gt;:       0x000000a8      0x00000002      0x006032d0      0x00000000</span><br><span class="line">0x6032f0 &lt;node3&gt;:       0x0000039c      0x00000003      0x006032e0      0x00000000</span><br><span class="line">0x603300 &lt;node4&gt;:       0x000002b3      0x00000004      0x006032f0      0x00000000</span><br><span class="line">0x603310 &lt;node5&gt;:       0x000001dd      0x00000005      0x00603300      0x00000000</span><br><span class="line">0x603320 &lt;node6&gt;:       0x000001bb      0x00000006      0x00603310      0x00000000</span><br></pre></td></tr></table></figure><p>根据<strong>每一行地址处第一个字的数值</strong>和<strong>以第三个字数值为地址的数值</strong>相比，如果所以的第一个数大于第二个数，那么通过。举个例子，第二行的地址是<code>0x6032e0</code>，第一个字的数值是<code>0xa8</code>，第三个字的地址是<code>0x6032d0</code>，在<code>0x6032d0</code>处的数值是<code>0x14c</code>，比较<code>0x14c</code>和<code>0xa8</code>。这种比较地址<code>0x20(%rsp)</code>开始。</p><p>下面是栈和地址<code>0x6032d0</code>的变化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#输入的是1 2 3 4 5 6</span><br><span class="line">#用7- 只有的栈</span><br><span class="line">0x7fffffffe460: 0x00000006      0x00000005      0x00000004      0x00000003</span><br><span class="line">0x7fffffffe470: 0x00000002      0x00000001      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe480: 0xffffe5c0      0x00007fff      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe490: 0x00000000      0x00000000      0x004013cc      0x00000000</span><br><span class="line">0x7fffffffe4a0: 0xffffe5c8      0x00007fff      0x00603910      0x00000000</span><br><span class="line"></span><br><span class="line">#开始的使用</span><br><span class="line">0x6032d0 &lt;node1&gt;:       0x0000014c      0x00000001      0x006032e0      0x00000000</span><br><span class="line">0x6032e0 &lt;node2&gt;:       0x000000a8      0x00000002      0x006032f0      0x00000000</span><br><span class="line">0x6032f0 &lt;node3&gt;:       0x0000039c      0x00000003      0x00603300      0x00000000</span><br><span class="line">0x603300 &lt;node4&gt;:       0x000002b3      0x00000004      0x00603310      0x00000000</span><br><span class="line">0x603310 &lt;node5&gt;:       0x000001dd      0x00000005      0x00603320      0x00000000</span><br><span class="line">0x603320 &lt;node6&gt;:       0x000001bb      0x00000006      0x00000000      0x00000000</span><br><span class="line"></span><br><span class="line">#用数字填充后的栈</span><br><span class="line">0x7fffffffe460: 0x00000006      0x00000005      0x00000004      0x00000003</span><br><span class="line">0x7fffffffe470: 0x00000002      0x00000001      0x00000000      0x00000000</span><br><span class="line">0x7fffffffe480: 0x00603320      0x00000000      0x00603310      0x00000000</span><br><span class="line">0x7fffffffe490: 0x00603300      0x00000000      0x006032f0      0x00000000</span><br><span class="line">0x7fffffffe4a0: 0x006032e0      0x00000000      0x006032d0      0x00000000</span><br><span class="line"></span><br><span class="line">#反向填充后的结果</span><br><span class="line">0x6032d0 &lt;node1&gt;:       0x0000014c      0x00000001      0x00000000      0x00000000</span><br><span class="line">0x6032e0 &lt;node2&gt;:       0x000000a8      0x00000002      0x006032d0      0x00000000</span><br><span class="line">0x6032f0 &lt;node3&gt;:       0x0000039c      0x00000003      0x006032e0      0x00000000</span><br><span class="line">0x603300 &lt;node4&gt;:       0x000002b3      0x00000004      0x006032f0      0x00000000</span><br><span class="line">0x603310 &lt;node5&gt;:       0x000001dd      0x00000005      0x00603300      0x00000000</span><br><span class="line">0x603320 &lt;node6&gt;:       0x000001bb      0x00000006      0x00603310      0x00000000</span><br></pre></td></tr></table></figure><p>在将数据中栈中填充后<code>0x6032d0</code>时，是有一定顺序的；以上面的结果举例，填充回去的时候是在<code>0x603320</code>哪里填充<code>0x603310</code>，接着在<code>0x603310</code>哪里填充<code>0x603300</code>，以此类推。。。</p><p>数据的比较也是按照上面的顺序，<code>0x603320</code>要大于<code>0x603310</code>，<code>0x603310</code>要大于<code>0x603300</code>。</p><p>所以我们只要使<code>0x6032d0</code>的处的地址填充到(<code>0x20(%rsp)</code>)时，按照数值从大到小的顺序就可以了</p><p>我们观察可得(省略前缀只用后两位)<code>f0 &gt; 00 &gt;10 &gt; 20 &gt; d0 &gt; e0</code>。所以数字是<code>3 4 5 6 1 2</code>，在通过<code>7-</code>得到最终的答案<code>4 3 2 1 6 5</code>。 </p><h2 id="Secret-phase"><a href="#Secret-phase" class="headerlink" title="Secret_phase"></a>Secret_phase</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">secret_phase:</span><br><span class="line">   0x0000000000401242 &lt;+0&gt;:     push   %rbx</span><br><span class="line">   0x0000000000401243 &lt;+1&gt;:     callq  0x40149e &lt;read_line&gt;</span><br><span class="line">   0x0000000000401248 &lt;+6&gt;:     mov    $0xa,%edx</span><br><span class="line">   0x000000000040124d &lt;+11&gt;:    mov    $0x0,%esi</span><br><span class="line">   0x0000000000401252 &lt;+16&gt;:    mov    %rax,%rdi</span><br><span class="line">   0x0000000000401255 &lt;+19&gt;:    callq  0x400bd0 &lt;strtol@plt&gt;</span><br><span class="line">   0x000000000040125a &lt;+24&gt;:    mov    %rax,%rbx</span><br><span class="line">   0x000000000040125d &lt;+27&gt;:    lea    -0x1(%rax),%eax</span><br><span class="line">   0x0000000000401260 &lt;+30&gt;:    cmp    $0x3e8,%eax</span><br><span class="line">   0x0000000000401265 &lt;+35&gt;:    jbe    0x40126c &lt;secret_phase+42&gt;</span><br><span class="line">   0x0000000000401267 &lt;+37&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x000000000040126c &lt;+42&gt;:    mov    %ebx,%esi</span><br><span class="line">   0x000000000040126e &lt;+44&gt;:    mov    $0x6030f0,%edi</span><br><span class="line">   0x0000000000401273 &lt;+49&gt;:    callq  0x401204 &lt;fun7&gt;</span><br><span class="line">   0x0000000000401278 &lt;+54&gt;:    cmp    $0x2,%eax</span><br><span class="line">   0x000000000040127b &lt;+57&gt;:    je     0x401282 &lt;secret_phase+64&gt;</span><br><span class="line">   0x000000000040127d &lt;+59&gt;:    callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000401282 &lt;+64&gt;:    mov    $0x402438,%edi</span><br><span class="line">   0x0000000000401287 &lt;+69&gt;:    callq  0x400b10 &lt;puts@plt&gt;</span><br><span class="line">   0x000000000040128c &lt;+74&gt;:    callq  0x4015c4 &lt;phase_defused&gt;</span><br><span class="line">   0x0000000000401291 &lt;+79&gt;:    pop    %rbx</span><br><span class="line">   0x0000000000401292 &lt;+80&gt;:    retq</span><br></pre></td></tr></table></figure><p>当我们通过objdump将bomb反汇编以后就会在phase_6，下面发现还有这么一个小彩蛋。</p><p>这个阶段是输入一个数字，然后调用<code>fun7</code>，如果返回值等于2，那就通过来，反之失败。主要就是<code>fun7</code>这个函数。<code>fun7</code>是一个递归函数，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun7:</span><br><span class="line">   0x0000000000401204 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">   0x0000000000401208 &lt;+4&gt;:     test   %rdi,%rdi</span><br><span class="line">   0x000000000040120b &lt;+7&gt;:     je     0x401238 &lt;fun7+52&gt;</span><br><span class="line">   0x000000000040120d &lt;+9&gt;:     mov    (%rdi),%edx</span><br><span class="line">   0x000000000040120f &lt;+11&gt;:    cmp    %esi,%edx</span><br><span class="line">   0x0000000000401211 &lt;+13&gt;:    jle    0x401220 &lt;fun7+28&gt;</span><br><span class="line">   0x0000000000401213 &lt;+15&gt;:    mov    0x8(%rdi),%rdi</span><br><span class="line">   0x0000000000401217 &lt;+19&gt;:    callq  0x401204 &lt;fun7&gt;</span><br><span class="line">   0x000000000040121c &lt;+24&gt;:    add    %eax,%eax</span><br><span class="line">   0x000000000040121e &lt;+26&gt;:    jmp    0x40123d &lt;fun7+57&gt;</span><br><span class="line">   0x0000000000401220 &lt;+28&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x0000000000401225 &lt;+33&gt;:    cmp    %esi,%edx</span><br><span class="line">   0x0000000000401227 &lt;+35&gt;:    je     0x40123d &lt;fun7+57&gt;</span><br><span class="line">   0x0000000000401229 &lt;+37&gt;:    mov    0x10(%rdi),%rdi</span><br><span class="line">   0x000000000040122d &lt;+41&gt;:    callq  0x401204 &lt;fun7&gt;</span><br><span class="line">   0x0000000000401232 &lt;+46&gt;:    lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">   0x0000000000401236 &lt;+50&gt;:    jmp    0x40123d &lt;fun7+57&gt;</span><br><span class="line">   0x0000000000401238 &lt;+52&gt;:    mov    $0xffffffff,%eax</span><br><span class="line">   0x000000000040123d &lt;+57&gt;:    add    $0x8,%rsp</span><br><span class="line">   0x0000000000401241 &lt;+61&gt;:    retq</span><br></pre></td></tr></table></figure><p>在这个函数中有几个比较关键的地方，</p><ul><li>在地址<code>0x40121c</code>，可以讲<code>%eax</code>加倍；</li><li>在地址<code>0x401220</code>，可以讲<code>%eax</code>清零；</li><li>在地址<code>0x40123d</code>，可以讲<code>%eax</code>变成<code>1</code>(前提<code>%eax</code>开始等于0)。</li></ul><p>因为是递归调用，图中有两个地方可以进入递归，一个是<code>0x401217</code>，另一个是<code>0x40122d</code>。要想得到返回值是二，需要首先通过<code>0x401217</code>进入递归，然后通过<code>0x40122d</code>进入递归，最后通过<code>0x401227</code>处的代码返回。</p><p>要想实现上面的过程，就必须知道<code>%rdi(0x6030f0)</code>处，储存着什么。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0x6030f0 &lt;n1&gt;:  0x00000024      0x00000000      0x00603110      0x00000000</span><br><span class="line">0x603100 &lt;n1+16&gt;:       0x00603130      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603110 &lt;n21&gt;: 0x00000008      0x00000000      0x00603190      0x00000000</span><br><span class="line">0x603120 &lt;n21+16&gt;:      0x00603150      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603130 &lt;n22&gt;: 0x00000032      0x00000000      0x00603170      0x00000000</span><br><span class="line">0x603140 &lt;n22+16&gt;:      0x006031b0      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603150 &lt;n32&gt;: 0x00000016      0x00000000      0x00603270      0x00000000</span><br><span class="line">0x603160 &lt;n32+16&gt;:      0x00603230      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603170 &lt;n33&gt;: 0x0000002d      0x00000000      0x006031d0      0x00000000</span><br><span class="line">0x603180 &lt;n33+16&gt;:      0x00603290      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603190 &lt;n31&gt;: 0x00000006      0x00000000      0x006031f0      0x00000000</span><br><span class="line">0x6031a0 &lt;n31+16&gt;:      0x00603250      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6031b0 &lt;n34&gt;: 0x0000006b      0x00000000      0x00603210      0x00000000</span><br><span class="line">0x6031c0 &lt;n34+16&gt;:      0x006032b0      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6031d0 &lt;n45&gt;: 0x00000028      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6031e0 &lt;n45+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6031f0 &lt;n41&gt;: 0x00000001      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603200 &lt;n41+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603210 &lt;n47&gt;: 0x00000063      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603220 &lt;n47+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603230 &lt;n44&gt;: 0x00000023      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603240 &lt;n44+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603250 &lt;n42&gt;: 0x00000007      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603260 &lt;n42+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603270 &lt;n43&gt;: 0x00000014      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603280 &lt;n43+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x603290 &lt;n46&gt;: 0x0000002f      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6032a0 &lt;n46+16&gt;:      0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x6032b0 &lt;n48&gt;: 0x000003e9      0x00000000      0x00000000      0x00000000</span><br></pre></td></tr></table></figure><p>于是我们可以得到，输入的数字是<code>22</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSAPP的bomb lab是让你通过反汇编和gdb，找到六个相应的字符串，来拆掉炸弹。&lt;/p&gt;
&lt;p&gt;本实验一共六个阶段，每个阶段对应一个字符串。在完成这六个阶段以后，还有一个彩蛋secret_phase。彩蛋可以在反汇编的代码中看到，只能通过gdb进入，没有出现在&lt;code&gt;main&lt;/code&gt;函数中。&lt;/p&gt;
&lt;p&gt;整个实验的整体框架可以在&lt;code&gt;bomb.c&lt;/code&gt;文件中看到。主要是用的工具是gdb和objdump。&lt;/p&gt;
&lt;p&gt;下面的代码都是在gdb中反汇编出来的代码，通过gdb反汇编出来的代码跳转地址是用的绝对地址，比较好看。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="csapp" scheme="https://haohuaijin.github.io/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>实验5:信号量的实现与应用</title>
    <link href="https://haohuaijin.github.io/2020/11/08/%E5%AE%9E%E9%AA%8C5-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://haohuaijin.github.io/2020/11/08/%E5%AE%9E%E9%AA%8C5-%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2020-11-08T07:42:04.000Z</published>
    <updated>2020-11-08T07:47:49.958Z</updated>
    
    <content type="html"><![CDATA[<p>实验链接：<a href="https://www.lanqiao.cn/courses/115" target="_blank" rel="noopener">信号量的应用与实现</a></p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>本次实验的基本内容是：</p><ul><li>在 Ubuntu 下编写程序，用信号量解决生产者——消费者问题；</li><li>在 0.11 中实现信号量，用生产者—消费者程序检验之。</li></ul><h3 id="1-用信号量解决生产者—消费者问题"><a href="#1-用信号量解决生产者—消费者问题" class="headerlink" title="1. 用信号量解决生产者—消费者问题"></a>1. 用信号量解决生产者—消费者问题</h3><p>在 Ubuntu 上编写应用程序“pc.c”，解决经典的生产者—消费者问题，完成下面的功能：</p><ul><li>建立一个生产者进程，N 个消费者进程（N&gt;1）；</li><li>用文件建立一个共享缓冲区；</li><li>生产者进程依次向缓冲区写入整数 0,1,2,…,M，M&gt;=500；</li><li>消费者进程从缓冲区读数，每次读一个，并将读出的数字从缓冲区删除，然后将本进程 ID 和 + 数字输出到标准输出；</li><li>缓冲区同时最多只能保存 10 个数。</li></ul><p>一种可能的输出效果是：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10: 0</span><br><span class="line">10: 1</span><br><span class="line">10: 2</span><br><span class="line">10: 3</span><br><span class="line">10: 4</span><br><span class="line">11: 5</span><br><span class="line">11: 6</span><br><span class="line">……</span><br><span class="line">11: 498</span><br><span class="line">11: 499</span><br></pre></td></tr></table></figure><p>其中 ID 的顺序会有较大变化，但冒号后的数字一定是从 0 开始递增加一的。</p><p><code>pc.c</code> 中将会用到 <code>sem_open()</code>、<code>sem_close()</code>、<code>sem_wait()</code> 和 <code>sem_post()</code> 等信号量相关的系统调用，请查阅相关文档。</p><p>《UNIX 环境高级编程》是一本关于 Unix/Linux 系统级编程的相当经典的教程。如果你对 POSIX 编程感兴趣，建议买一本常备手边。</p><blockquote><p>哈尔滨工业大学校园网用户可以在 <a href="ftp://run.hit.edu.cn/study/Computer_Science/Linux_Unix/" target="_blank" rel="noopener">ftp://run.hit.edu.cn/study/Computer_Science/Linux_Unix/</a> 下载，后续实验也用得到。</p></blockquote><h3 id="2-实现信号量"><a href="#2-实现信号量" class="headerlink" title="2. 实现信号量"></a>2. 实现信号量</h3><p>Linux 在 0.11 版还没有实现信号量，Linus 把这件富有挑战的工作留给了你。如果能实现一套山寨版的完全符合 POSIX 规范的信号量，无疑是很有成就感的。但时间暂时不允许我们这么做，所以先弄一套缩水版的类 POSIX 信号量，它的函数原型和标准并不完全相同，而且只包含如下系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sem_t</span> *<span class="title">sem_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>sem_open()</code>的功能是创建一个信号量，或打开一个已经存在的信号量。</p><ul><li><code>sem_t</code> 是信号量类型，根据实现的需要自定义。</li><li><code>name</code> 是信号量的名字。不同的进程可以通过提供同样的 name 而共享同一个信号量。如果该信号量不存在，就创建新的名为 name 的信号量；如果存在，就打开已经存在的名为 name 的信号量。</li></ul></li><li><p><code>value</code> 是信号量的初值，仅当新建信号量时，此参数才有效，其余情况下它被忽略。当成功时，返回值是该信号量的唯一标识（比如，在内核的地址、ID 等），由另两个系统调用使用。如失败，返回值是 NULL。</p></li><li><p><code>sem_wait()</code> 就是信号量的 P 原子操作。如果继续运行的条件不满足，则令调用进程等待在信号量 sem 上。返回 0 表示成功，返回 -1 表示失败。</p></li><li><p><code>sem_post()</code> 就是信号量的 V 原子操作。如果有等待 sem 的进程，它会唤醒其中的一个。返回 0 表示成功，返回 -1 表示失败。</p></li><li><p><code>sem_unlink()</code> 的功能是删除名为 name 的信号量。返回 0 表示成功，返回 -1 表示失败。</p></li></ul><p>在 <code>kernel</code> 目录下新建 <code>sem.c</code> 文件实现如上功能。然后将 pc.c 从 Ubuntu 移植到 0.11 下，测试自己实现的信号量。</p><h2 id="要修改的文件目录"><a href="#要修改的文件目录" class="headerlink" title="要修改的文件目录"></a>要修改的文件目录</h2><p>主要就是系统调用的添加，和实验二<a href="https://github.com/haohuaijin/hit-linux-0.11-lab/blob/main/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%E5%8F%8A%E7%AC%94%E8%AE%B0/2.%20%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/%E5%AE%9E%E9%AA%8C2:%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.md" target="_blank" rel="noopener">系统调用一样</a>。</p><h2 id="1-在ubuntu下的pc-c文件"><a href="#1-在ubuntu下的pc-c文件" class="headerlink" title="1. 在ubuntu下的pc.c文件"></a>1. 在ubuntu下的<code>pc.c</code>文件</h2><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_PROC 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUMBER 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUFFER 10</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 由于没有函数可以直接对文件进行删除，所以我们要想对文件读取后删除，这里有两种方法</span></span><br><span class="line"><span class="comment"> * 第一种：将文件全部读取出来，然后关闭文件，重新打开时利用open()将文件清0，然后将</span></span><br><span class="line"><span class="comment"> * 读取的文件中第一个打印出来，剩下的全部在重新写入到文件里。不过这样太浪费时间来。</span></span><br><span class="line"><span class="comment"> * 第二种：在文件的第一个位置设置一个标志，里面存放的是上一个消费者从里面读出来的数据，</span></span><br><span class="line"><span class="comment"> * 这样本次就可以通过上一个消费者读取的数据，来找到本次数据应该读取的位置。从而实现</span></span><br><span class="line"><span class="comment"> * 同步。</span></span><br><span class="line"><span class="comment"> * 第二中方法参考了：https://github.com/Wangzhike/HIT-Linux-0.11</span></span><br><span class="line"><span class="comment"> * 下面的是第二种方法, 第一种有空补上：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建信号量</span></span><br><span class="line">    <span class="keyword">sem_t</span>* full = sem_open(<span class="string">"/full"</span>, O_CREAT, <span class="number">0666</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">sem_t</span>* mutex = sem_open(<span class="string">"/mutex"</span>, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">sem_t</span>* empty = sem_open(<span class="string">"/empty"</span>, O_CREAT, <span class="number">0666</span>, MAX_BUFFER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid[NR_PROC];</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>, <span class="built_in">position</span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fp = <span class="built_in">open</span>(<span class="string">"file"</span>, O_CREAT | O_RDWR | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NR_PROC; i++) &#123;<span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">pid_t</span> cur_pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(cur_pid == <span class="number">0</span>) &#123; <span class="comment">//子进程调用fork后，返回0</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                sem_wait(full);</span><br><span class="line">                sem_wait(mutex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//读取上一次读取出来的数字</span></span><br><span class="line">                lseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">                <span class="built_in">read</span>(fp, &amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">                <span class="keyword">if</span>(tmp == MAX_NUMBER)&#123;</span><br><span class="line">                    sem_post(mutex);</span><br><span class="line">                    sem_post(empty);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//读取本次的数据</span></span><br><span class="line">                <span class="built_in">position</span> = ((tmp+<span class="number">1</span>) % MAX_BUFFER) + <span class="number">1</span>;</span><br><span class="line">                lseek(fp, <span class="built_in">position</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>), SEEK_SET);</span><br><span class="line">                <span class="built_in">read</span>(fp, &amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d: %d\n"</span>, getpid(), tmp);</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//写入本次读取的数据</span></span><br><span class="line">                lseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">                <span class="built_in">write</span>(fp, (<span class="keyword">void</span>*)&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">                sem_post(mutex);</span><br><span class="line">                sem_post(empty);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = <span class="number">-1</span>; <span class="built_in">position</span> = <span class="number">0</span>;</span><br><span class="line">    lseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="built_in">write</span>(fp, (<span class="keyword">void</span>*)&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//写入标志位</span></span><br><span class="line">    <span class="comment">//这里在循环中加上NR_PROC是为了让子进程能够退出循环。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; MAX_NUMBER+NR_PROC+<span class="number">1</span>; i++)&#123; <span class="comment">//生产者</span></span><br><span class="line">        sem_wait(empty);</span><br><span class="line">        sem_wait(mutex);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">position</span> = (i % MAX_BUFFER) + <span class="number">1</span>;</span><br><span class="line">        lseek(fp, <span class="built_in">position</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>), SEEK_SET);</span><br><span class="line">        <span class="built_in">write</span>(fp, (<span class="keyword">void</span>*)&amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">        sem_post(mutex);</span><br><span class="line">        sem_post(full);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NR_PROC; i++)&#123;</span><br><span class="line">        wait(&amp;pid[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fp);</span><br><span class="line">    sem_close(full);</span><br><span class="line">    sem_close(mutex);</span><br><span class="line">    sem_close(empty);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几个需要注意的点：</p><ul><li><p>信号量的使用；</p></li><li><p>如何利用文件作为缓冲区(没有直接的函数可以删除文件里面的内容)；</p></li><li><p><code>read()</code>，<code>write()</code>和<code>lseek()</code>函数的用法；</p></li><li><p>编译的时，要使用如下的命令<code>gcc -o pc pc.c -pthread</code>；</p></li><li><p>如果是macOS，那么信号量前面必须加上<code>/</code>。</p></li></ul><h2 id="2-信号量的实现-编写sem-c文件"><a href="#2-信号量的实现-编写sem-c文件" class="headerlink" title="2. 信号量的实现(编写sem.c文件)"></a>2. 信号量的实现(编写<code>sem.c</code>文件)</h2><p>首先需要将要用到的结构体放到<code>unistd.h</code>文件里面：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> errno;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add start </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sem_tx</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">quence</span>[20];</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sem_tx</span> <span class="title">sem_tx</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">sem_t</span>;</span><br><span class="line"><span class="comment">// add end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * filename, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是<code>sem.c</code>文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/system.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/segment.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_sem_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_sem_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line">sem_tx total_sem[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> count_sem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_sem_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, count;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123; </span><br><span class="line">        str[count] = get_fs_byte(name + count);</span><br><span class="line">    &#125; <span class="keyword">while</span> (count &lt;= <span class="number">20</span> &amp;&amp; str[count++] != <span class="string">'\0'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;count_sem; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(total_sem[i].name, str))&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    total_sem[count_sem].value = value;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;count; i++)</span><br><span class="line">        total_sem[count_sem].name[i] = str[i];</span><br><span class="line">    total_sem[count_sem].name[i] = <span class="string">'\0'</span>; </span><br><span class="line">    <span class="comment">//printk("the open name is %s, name is %s.\n", total_sem[count_sem].name, str);</span></span><br><span class="line">    total_sem[count_sem].count = <span class="number">0</span>; <span class="comment">//the count of wait pid process.</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line">        total_sem[count_sem].quence[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    count_sem++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (count_sem<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>&#123;</span><br><span class="line">    cli();</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">/*printk("the wait is %d, pid is %d.\n", (int)sem, current-&gt;pid);*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;count_sem; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == (<span class="keyword">int</span>)sem)&#123;</span><br><span class="line">            <span class="comment">/* 第一种方法 */</span></span><br><span class="line">            total_sem[i].value--;</span><br><span class="line">            <span class="keyword">if</span>(total_sem[i].value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                current-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">                total_sem[i].quence[total_sem[i].count] = current;</span><br><span class="line">                total_sem[i].count++;</span><br><span class="line">                schedule();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 第二种方法</span></span><br><span class="line"><span class="comment">            total_sem[i].value--;</span></span><br><span class="line"><span class="comment">            if(total_sem[i].value &lt; 0)&#123;</span></span><br><span class="line"><span class="comment">                sleep_on(&amp;(total_sem[i].quence[total_sem[i].count++]));</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sti();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>&#123;</span><br><span class="line">    cli();</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">/*printk("the post is %d, pid is %d.\n", (int)sem, current-&gt;pid);*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;count_sem; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == (<span class="keyword">int</span>)sem)&#123;</span><br><span class="line">            <span class="comment">/* 第一种方法 */</span></span><br><span class="line">            total_sem[i].value++;</span><br><span class="line">            <span class="keyword">if</span>(total_sem[i].value &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                total_sem[i].count--; <span class="comment">// in the front of tmp-&gt;state = 0;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span> = <span class="title">total_sem</span>[<span class="title">i</span>].<span class="title">quence</span>[<span class="title">total_sem</span>[<span class="title">i</span>].<span class="title">count</span>];</span></span><br><span class="line">                <span class="keyword">if</span>(tmp) </span><br><span class="line">                    tmp-&gt;state = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 第二种方法</span></span><br><span class="line"><span class="comment">            total_sem[i].value++;</span></span><br><span class="line"><span class="comment">            if(total_sem[i].value &lt;= 0)&#123;</span></span><br><span class="line"><span class="comment">                wake_up(&amp;(total_sem[i].quence[--total_sem[i].count]));</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sti();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_sem_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123; </span><br><span class="line">        str[i] = get_fs_byte(name + i);</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt;= <span class="number">20</span> &amp;&amp; str[i++] != <span class="string">'\0'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;count_sem; i++)&#123;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        printk("the name is %s, name is %s, the i is %d.\n", </span></span><br><span class="line"><span class="comment">                total_sem[i].name, str, i);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(total_sem[i].name, str))&#123;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i == count_sem)&#123;</span><br><span class="line">        printk(<span class="string">"No sem of the %s name.\n"</span>, str);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=i; j&lt;count_sem; j++)&#123;</span><br><span class="line">        total_sem[j] = total_sem[j+<span class="number">1</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    count_sem--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意的几个点：</p><ol><li>核心态使用<code>get_fs_byte</code>来访问用户态的数据，这个函数在实验二介绍过；</li><li>信号量队列的实现与应用；</li><li>因为不知道如何在核心态申请空间，所以通过定义全局变量来获得内核空间，不过这样的缺点就是限制来信号量的大小。</li><li>这里<code>sem_open</code>的返回值是他们在数组中的下标，所以如果删除中间的信号量的话可能导致程序出错，解决的方法可以增加一个标记数组来确认数组中的位置是不是被使用，这样就不用通过<code>count_sem</code>和删除时前移来记录信号量的多少，从而解决了上面的问题。</li></ol><p>在linux-0.11里面的<code>pc.c</code>文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_PROC 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUMBER 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_BUFFER 10</span></span><br><span class="line"></span><br><span class="line">_syscall2(<span class="keyword">int</span>, sem_open, <span class="keyword">const</span> <span class="keyword">char</span>*,name, <span class="keyword">unsigned</span> <span class="keyword">int</span>,value);</span><br><span class="line">_syscall1(<span class="keyword">int</span>, sem_wait, <span class="keyword">sem_t</span>*, sem);</span><br><span class="line">_syscall1(<span class="keyword">int</span>, sem_post, <span class="keyword">sem_t</span>*, sem);</span><br><span class="line">_syscall1(<span class="keyword">int</span>, sem_unlink, <span class="keyword">const</span> <span class="keyword">char</span>*, name);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">sem_t</span>* full = (<span class="keyword">sem_t</span>*)sem_open(<span class="string">"full"</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">sem_t</span>* mutex = (<span class="keyword">sem_t</span>*)sem_open(<span class="string">"mutex"</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">sem_t</span>* empty = (<span class="keyword">sem_t</span>*)sem_open(<span class="string">"empty"</span>, MAX_BUFFER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid[NR_PROC];</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">0</span>, <span class="built_in">position</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> fp = <span class="built_in">open</span>(<span class="string">"fl"</span>, O_CREAT | O_RDWR | O_TRUNC, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NR_PROC; i++) &#123;</span><br><span class="line">        <span class="keyword">pid_t</span> cur_pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(cur_pid == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                sem_wait(full);</span><br><span class="line">                sem_wait(mutex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*读取上一次读取出来的数字*/</span></span><br><span class="line">                lseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">                <span class="built_in">read</span>(fp, (<span class="keyword">void</span>*)&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">                <span class="keyword">if</span>(tmp == MAX_NUMBER)&#123;</span><br><span class="line">                    sem_post(mutex);</span><br><span class="line">                    sem_post(empty);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 读取本次的数据 */</span></span><br><span class="line">                <span class="built_in">position</span> = ((tmp+<span class="number">1</span>) % MAX_BUFFER) + <span class="number">1</span>;</span><br><span class="line">                lseek(fp, <span class="built_in">position</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>), SEEK_SET);</span><br><span class="line">                <span class="built_in">read</span>(fp, (<span class="keyword">void</span>*)&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d: %d\n"</span>, getpid(), tmp);</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*写入本次读取的数据*/</span></span><br><span class="line">                lseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">                <span class="built_in">write</span>(fp, (<span class="keyword">void</span>*)&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">                </span><br><span class="line">                sem_post(mutex);</span><br><span class="line">                sem_post(empty);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*printf("I'm exit, pid: %d\n", getpid());*/</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = <span class="number">-1</span>; <span class="built_in">position</span> = <span class="number">0</span>;</span><br><span class="line">    lseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="built_in">write</span>(fp, (<span class="keyword">void</span>*)&amp;tmp, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">/*写入标志位*/</span></span><br><span class="line">    <span class="comment">/*这里在循环中加上NR_PROC是为了让子进程能够退出循环。*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; MAX_NUMBER+NR_PROC+<span class="number">1</span>; i++)&#123; </span><br><span class="line">        sem_wait(empty);</span><br><span class="line">        sem_wait(mutex);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">position</span> = (i % MAX_BUFFER) + <span class="number">1</span>;</span><br><span class="line">        lseek(fp, <span class="built_in">position</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>), SEEK_SET);</span><br><span class="line">        <span class="built_in">write</span>(fp, (<span class="keyword">void</span>*)&amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="comment">/*printf("%d\n", i);*/</span></span><br><span class="line">        <span class="comment">/*fflush(stdout);*/</span></span><br><span class="line"></span><br><span class="line">        sem_post(mutex);</span><br><span class="line">        sem_post(full);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NR_PROC; i++)&#123;</span><br><span class="line">        wait(&amp;pid[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fp);</span><br><span class="line">    sem_unlink(<span class="string">"empty"</span>);</span><br><span class="line">    sem_unlink(<span class="string">"mutex"</span>);</span><br><span class="line">    sem_unlink(<span class="string">"full"</span>);</span><br><span class="line">    <span class="comment">/*printf("the father exit\n");*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体的结构和ubuntu里面的差不多，修改了细节使程序和linux-0.11对应起来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实验链接：&lt;a href=&quot;https://www.lanqiao.cn/courses/115&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;信号量的应用与实现&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot; class=&quot;headerlink&quot; title=&quot;实验内容&quot;&gt;&lt;/a&gt;实验内容&lt;/h2&gt;&lt;p&gt;本次实验的基本内容是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Ubuntu 下编写程序，用信号量解决生产者——消费者问题；&lt;/li&gt;
&lt;li&gt;在 0.11 中实现信号量，用生产者—消费者程序检验之。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-用信号量解决生产者—消费者问题&quot;&gt;&lt;a href=&quot;#1-用信号量解决生产者—消费者问题&quot; class=&quot;headerlink&quot; title=&quot;1. 用信号量解决生产者—消费者问题&quot;&gt;&lt;/a&gt;1. 用信号量解决生产者—消费者问题&lt;/h3&gt;&lt;p&gt;在 Ubuntu 上编写应用程序“pc.c”，解决经典的生产者—消费者问题，完成下面的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立一个生产者进程，N 个消费者进程（N&amp;gt;1）；&lt;/li&gt;
&lt;li&gt;用文件建立一个共享缓冲区；&lt;/li&gt;
&lt;li&gt;生产者进程依次向缓冲区写入整数 0,1,2,…,M，M&amp;gt;=500；&lt;/li&gt;
&lt;li&gt;消费者进程从缓冲区读数，每次读一个，并将读出的数字从缓冲区删除，然后将本进程 ID 和 + 数字输出到标准输出；&lt;/li&gt;
&lt;li&gt;缓冲区同时最多只能保存 10 个数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一种可能的输出效果是：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="https://haohuaijin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>实验4:基于内核栈的进程切换</title>
    <link href="https://haohuaijin.github.io/2020/10/26/%E5%AE%9E%E9%AA%8C4-%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E6%A0%88%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/"/>
    <id>https://haohuaijin.github.io/2020/10/26/%E5%AE%9E%E9%AA%8C4-%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E6%A0%88%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/</id>
    <published>2020-10-26T01:21:54.000Z</published>
    <updated>2020-10-26T01:24:45.501Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：<a href="https://www.lanqiao.cn/courses/115/learning/?id=571" target="_blank" rel="noopener">基于内核栈切换的进程切换</a></p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>本次实践项目就是将 Linux 0.11 中采用的 TSS 切换部分去掉，取而代之的是基于堆栈的切换程序。具体的说，就是将 Linux 0.11 中的 switch_to 实现去掉，写成一段基于堆栈切换的代码。</p><p>在现在的 Linux 0.11 中，真正完成进程切换是依靠任务状态段（Task State Segment，简称 TSS）的切换来完成的。具体的说，在设计“Intel 架构”（即 x86 系统结构）时，每个任务（进程或线程）都对应一个独立的 TSS，TSS 就是内存中的一个结构体，里面包含了几乎所有的 CPU 寄存器的映像。有一个任务寄存器（Task Register，简称 TR）指向当前进程对应的 TSS 结构体，所谓的 TSS 切换就将 CPU 中几乎所有的寄存器都复制到 TR 指向的那个 TSS 结构体中保存起来，同时找到一个目标 TSS，即要切换到的下一个进程对应的 TSS，将其中存放的寄存器映像“扣在”CPU 上，就完成了执行现场的切换。</p><a id="more"></a><p>要实现基于内核栈的任务切换，主要完成如下三件工作：</p><ul><li>（1）重写 <code>switch_to</code>；</li><li>（2）将重写的 <code>switch_to</code> 和 <code>schedule()</code> 函数接在一起；</li><li>（3）修改现在的 <code>fork()</code>。</li></ul><h2 id="修改的文件列表"><a href="#修改的文件列表" class="headerlink" title="修改的文件列表"></a>修改的文件列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linux-0.11/kernel/sched.c</span><br><span class="line">linux-0.11/kernel/fork.c</span><br><span class="line">linux-0.11/kernel/system_call.s</span><br><span class="line">linux-0.11/include/linux/sched.h</span><br></pre></td></tr></table></figure><h2 id="1-修改sched-c文件"><a href="#1-修改sched-c文件" class="headerlink" title="1. 修改sched.c文件"></a>1. 修改<code>sched.c</code>文件</h2><p>主要修改的有两个地方，一个是定义一个变量<code>tss</code>在<code>system_call.s</code>中使用，另一个在函数<code>schedule()</code>中。</p><p>定义<code>tss</code>变量，添加在第一条语句的后面，在前面的话<code>init_task</code>还没有定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">union</span> task_union init_task = &#123;INIT_TASK,&#125;;</span><br><span class="line"><span class="comment">/* add lab4 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> *<span class="title">tss</span> = &amp;(<span class="title">init_task</span>.<span class="title">task</span>.<span class="title">tss</span>);</span></span><br></pre></td></tr></table></figure><p>修改<code>schedule()</code>函数，修改下面三个地方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pnext</span> = &amp;(<span class="title">init_task</span>.<span class="title">task</span>);</span> <span class="comment">//lab4</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">        </span><br><span class="line"><span class="keyword">while</span> (--i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!*--p)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">c = (*p)-&gt;counter, next = i, pnext = *p; <span class="comment">//lab4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch_to(pnext, _LDT(next)); <span class="comment">//lab4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面对<code>pnext</code>的初始化十分重要。</p><h2 id="2-修改fork-c文件"><a href="#2-修改fork-c文件" class="headerlink" title="2. 修改fork.c文件"></a>2. 修改<code>fork.c</code>文件</h2><p>只需要修改<code>copy_process()</code>即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">p = (struct task_struct *) get_free_page();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> *krnstack;</span><br><span class="line">krnstack = (<span class="keyword">long</span> *) (PAGE_SIZE + (<span class="keyword">long</span>) p);</span><br><span class="line">*(--krnstack) = ss &amp; <span class="number">0xffff</span>;</span><br><span class="line">*(--krnstack) = esp;</span><br><span class="line">*(--krnstack) = eflags;</span><br><span class="line">*(--krnstack) = cs &amp; <span class="number">0xffff</span>;</span><br><span class="line">*(--krnstack) = eip;</span><br><span class="line">*(--krnstack) = ds &amp; <span class="number">0xffff</span>;</span><br><span class="line">*(--krnstack) = es &amp; <span class="number">0xffff</span>;</span><br><span class="line">*(--krnstack) = fs &amp; <span class="number">0xffff</span>;</span><br><span class="line">*(--krnstack) = gs &amp; <span class="number">0xffff</span>;</span><br><span class="line">*(--krnstack) = esi;</span><br><span class="line">*(--krnstack) = edi;</span><br><span class="line">*(--krnstack) = edx;</span><br><span class="line">*(--krnstack) = (<span class="keyword">long</span>) first_return_from_kernel; </span><br><span class="line">*(--krnstack) = ebp;</span><br><span class="line">*(--krnstack) = ecx;</span><br><span class="line">*(--krnstack) = ebx;</span><br><span class="line">*(--krnstack) = <span class="number">0</span>;</span><br><span class="line">p-&gt;kernelstack = krnstack;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> last_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-修改system-call-s"><a href="#3-修改system-call-s" class="headerlink" title="3. 修改system_call.s"></a>3. 修改<code>system_call.s</code></h2><p>因为我们要能够在c文件中调用汇编的函数，同时我们也需要在汇编文件中使用c语言定义的变量，所以下面的内容是为汇编和c文件完成链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># modified for lab4, because I add kernelstack in front of signal in the task_struct(PCB).</span><br><span class="line">signal= 16</span><br><span class="line">sigaction = 20</span><br><span class="line">blocked = (33*16+4)</span><br><span class="line"></span><br><span class="line"># add for lab4</span><br><span class="line">KERNEL_STACK = 12</span><br><span class="line">ESP0 = 4 </span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Ok, I get parallel printer interrupts while using the floppy for some</span><br><span class="line"> * strange reason. Urgel. Now I just ignore them.</span><br><span class="line"> */</span><br><span class="line">.globl system_call,sys_fork,timer_interrupt,sys_execve</span><br><span class="line">.globl hd_interrupt,floppy_interrupt,parallel_interrupt</span><br><span class="line">.globl device_not_available, coprocessor_error</span><br><span class="line"></span><br><span class="line">.globl switch_to, first_return_from_kernel # add for lab4</span><br></pre></td></tr></table></figure><p>下面是编写的<code>switch_to</code>和<code>first_return_from_kernel</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">switch_to:</span><br><span class="line">    pushl %ebp</span><br><span class="line">    movl %esp,%ebp</span><br><span class="line">    pushl %ecx</span><br><span class="line">    pushl %ebx</span><br><span class="line">    pushl %eax</span><br><span class="line">    movl 8(%ebp),%ebx</span><br><span class="line">    cmpl %ebx,current</span><br><span class="line">    je 1f</span><br><span class="line">movl %ebx,%eax</span><br><span class="line">xchgl %eax,current </span><br><span class="line">    movl tss,%ecx</span><br><span class="line">addl $4096,%ebx</span><br><span class="line">movl %ebx,ESP0(%ecx)</span><br><span class="line">movl %esp,KERNEL_STACK(%eax)</span><br><span class="line">movl 8(%ebp),%ebx</span><br><span class="line">movl KERNEL_STACK(%ebx),%esp</span><br><span class="line">movl 12(%ebp),%ecx</span><br><span class="line">lldt %cx </span><br><span class="line">    movl $0x17,%ecx</span><br><span class="line">    mov %cx,%fs</span><br><span class="line">    cmpl %eax,last_task_used_math</span><br><span class="line">    jne 1f</span><br><span class="line">    clts</span><br><span class="line">1:  popl %eax</span><br><span class="line">    popl %ebx</span><br><span class="line">    popl %ecx</span><br><span class="line">    popl %ebp</span><br><span class="line">ret</span><br><span class="line">first_return_from_kernel:</span><br><span class="line">popl %edx</span><br><span class="line">popl %edi</span><br><span class="line">popl %esi</span><br><span class="line">pop %gs</span><br><span class="line">pop %fs</span><br><span class="line">pop %es</span><br><span class="line">pop %ds</span><br><span class="line">iret</span><br></pre></td></tr></table></figure><h2 id="4-修改sched-h"><a href="#4-修改sched-h" class="headerlink" title="4. 修改sched.h"></a>4. 修改<code>sched.h</code></h2><p>这里主要是在<code>task_struct</code>中添加<code>kernelstack</code>。然后为c语言中能够使用汇编函数，添加外部定义。还有修改<code>INIT_TASK</code>。</p><p>添加<code>kernelstack</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* these are hardcoded - don't touch */</span></span><br><span class="line"><span class="keyword">long</span> state;<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line"><span class="keyword">long</span> counter;</span><br><span class="line"><span class="keyword">long</span> priority;</span><br><span class="line"><span class="keyword">long</span> kernelstack; <span class="comment">/* add for lab4 */</span></span><br><span class="line"><span class="keyword">long</span> signal;</span><br></pre></td></tr></table></figure><p>添加外部定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">tty_write</span><span class="params">(<span class="keyword">unsigned</span> minor,<span class="keyword">char</span> * buf,<span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">switch_to</span><span class="params">(struct task_struct *pnext, <span class="keyword">unsigned</span> <span class="keyword">long</span> ldt)</span></span>; <span class="comment">/* add for lab4 */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">first_return_from_kernel</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">/* add for lab4 */</span></span><br></pre></td></tr></table></figure><p>修改<code>INIT_TASK</code>，中间添加了<code>PAGE_SIZE+(long)&amp;init_task</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* add for lab4 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK \</span></span><br><span class="line"><span class="comment">/* state etc */</span>&#123; <span class="number">0</span>,<span class="number">15</span>,<span class="number">15</span>,PAGE_SIZE+(<span class="keyword">long</span>)&amp;init_task, \</span><br><span class="line"><span class="comment">/* signals */</span><span class="number">0</span>,&#123;&#123;&#125;,&#125;,<span class="number">0</span>, \</span><br><span class="line"><span class="comment">/* ec,brk... */</span><span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \</span><br></pre></td></tr></table></figure><p>最后还要把<code>sched.h</code>里面的<code>switch_to</code>函数注释掉。</p><h2 id="5-回答问题"><a href="#5-回答问题" class="headerlink" title="5. 回答问题"></a>5. 回答问题</h2><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h4><p>针对下面的代码片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl tss,%ecx</span><br><span class="line">addl $4096,%ebx</span><br><span class="line">movl %ebx,ESP0(%ecx)</span><br></pre></td></tr></table></figure><p>回答问题：</p><p>(1) 为什么要加 4096 ?</p><p><strong>答：因为<code>%ebx</code>指向的是PCB，他和内核栈<code>esp0</code>距离<code>4k</code>大小。</strong></p><p>(2) 为什么没有设置 tss 中的 ss0 ?</p><p><strong>答：不是很清楚。</strong></p><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h4><p>针对代码片段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*(--krnstack) = ebp;</span><br><span class="line">*(--krnstack) = ecx;</span><br><span class="line">*(--krnstack) = ebx;</span><br><span class="line">*(--krnstack) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>回答问题：</p><p>(1) 子进程第一次执行时，eax=？为什么要等于这个数？哪里的工作让 eax 等于这样一个数？</p><p><strong>答：<code>eax=0</code>；子进程从<code>fork()</code>返回<code>0</code>；从<code>fork()</code>返回时。</strong></p><p>(2) 这段代码中的 ebx 和 ecx 来自哪里，是什么含义，为什么要通过这些代码将其写到子进程的内核栈中？</p><p><strong>答：函数参数里有，在进程切换<code>switch_to</code>里面使用。</strong></p><p>(3) 这段代码中的 ebp 来自哪里，是什么含义，为什么要做这样的设置？可以不设置吗？为什么？</p><p><strong>答：函数的参数，含义：内核栈底，构造出可以切换的样子。</strong></p><h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题 3"></a>问题 3</h4><p>为什么要在切换完 LDT 之后要重新设置 fs=0x17？而且为什么重设操作要出现在切换完 LDT 之后，出现在 LDT 之前又会怎么样？</p><p><strong>答：重新初始化<code>fs</code>使段寄存器的隐藏部分重置；如果在LDT之前没有什么用，切换之后换需要重新初始化。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;课程链接：&lt;a href=&quot;https://www.lanqiao.cn/courses/115/learning/?id=571&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;基于内核栈切换的进程切换&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot; class=&quot;headerlink&quot; title=&quot;实验内容&quot;&gt;&lt;/a&gt;实验内容&lt;/h2&gt;&lt;p&gt;本次实践项目就是将 Linux 0.11 中采用的 TSS 切换部分去掉，取而代之的是基于堆栈的切换程序。具体的说，就是将 Linux 0.11 中的 switch_to 实现去掉，写成一段基于堆栈切换的代码。&lt;/p&gt;
&lt;p&gt;在现在的 Linux 0.11 中，真正完成进程切换是依靠任务状态段（Task State Segment，简称 TSS）的切换来完成的。具体的说，在设计“Intel 架构”（即 x86 系统结构）时，每个任务（进程或线程）都对应一个独立的 TSS，TSS 就是内存中的一个结构体，里面包含了几乎所有的 CPU 寄存器的映像。有一个任务寄存器（Task Register，简称 TR）指向当前进程对应的 TSS 结构体，所谓的 TSS 切换就将 CPU 中几乎所有的寄存器都复制到 TR 指向的那个 TSS 结构体中保存起来，同时找到一个目标 TSS，即要切换到的下一个进程对应的 TSS，将其中存放的寄存器映像“扣在”CPU 上，就完成了执行现场的切换。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="https://haohuaijin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>实验3:进程运行轨迹的跟踪与统计</title>
    <link href="https://haohuaijin.github.io/2020/10/17/%E5%AE%9E%E9%AA%8C3:%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/"/>
    <id>https://haohuaijin.github.io/2020/10/17/%E5%AE%9E%E9%AA%8C3:%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/</id>
    <published>2020-10-17T03:30:13.000Z</published>
    <updated>2020-10-17T03:31:38.790Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：<a href="https://www.lanqiao.cn/courses/115/learning/?id=570" target="_blank" rel="noopener">进程运行轨迹跟踪与统计</a></p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>进程从创建（Linux 下调用 fork()）到结束的整个过程就是进程的生命期，进程在其生命期中的运行轨迹实际上就表现为进程状态的多次切换，如进程创建以后会成为就绪态；当该进程被调度以后会切换到运行态；在运行的过程中如果启动了一个文件读写操作，操作系统会将该进程切换到阻塞态（等待态）从而让出 CPU；当文件读写完毕以后，操作系统会在将其切换成就绪态，等待进程调度算法来调度该进程执行……</p><p>本次实验包括如下内容：</p><ul><li>基于模板 <code>process.c</code> 编写多进程的样本程序，实现如下功能： + 所有子进程都并行运行，每个子进程的实际运行时间一般不超过 30 秒； + 父进程向标准输出打印所有q子进程的 id，并在所有子进程都退出后才退出；</li><li>在 <code>Linux0.11</code> 上实现进程运行轨迹的跟踪。 + 基本任务是在内核中维护一个日志文件 <code>/var/process.log</code>，把从操作系统启动到系统关机过程中所有进程的运行轨迹都记录在这一 log 文件中。</li><li>在修改过的 0.11 上运行样本程序，通过分析 log 文件，统计该程序建立的所有进程的等待时间、完成时间（周转时间）和运行时间，然后计算平均等待时间，平均完成时间和吞吐量。可以自己编写统计程序，也可以使用 python 脚本程序—— <code>stat_log.py</code>（在 <code>/home/teacher/</code> 目录下） ——进行统计。</li><li>修改 0.11 进程调度的时间片，然后再运行同样的样本程序，统计同样的时间数据，和原有的情况对比，体会不同时间片带来的差异。</li></ul><a id="more"></a><p><code>/var/process.log</code> 文件的格式必须为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid    X    time</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>pid 是进程的 ID；</li><li>X 可以是 N、J、R、W 和 E 中的任意一个，分别表示进程新建(N)、进入就绪态(J)、进入运行态(R)、进入阻塞态(W) 和退出(E)；l</li><li>time 表示 X 发生的时间。这个时间不是物理时间，而是系统的滴答时间(tick)；</li></ul><p>三个字段之间用制表符分隔。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">12    N    1056</span><br><span class="line">12    J    1057</span><br><span class="line">4    W    1057</span><br><span class="line">12    R    1057</span><br><span class="line">13    N    1058</span><br><span class="line">13    J    1059</span><br><span class="line">14    N    1059</span><br><span class="line">14    J    1060</span><br><span class="line">15    N    1060</span><br><span class="line">15    J    1061</span><br><span class="line">12    W    1061</span><br><span class="line">15    R    1061</span><br><span class="line">15    J    1076</span><br><span class="line">14    R    1076</span><br><span class="line">14    E    1076</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="修改代码列表-主目录linux-0-11"><a href="#修改代码列表-主目录linux-0-11" class="headerlink" title="修改代码列表(主目录linux-0.11)"></a>修改代码列表(主目录linux-0.11)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">linux-0.11/process.c</span><br><span class="line"></span><br><span class="line">linux-0.11/kernel/fork.c</span><br><span class="line">linux-0.11/kernel/sched.c</span><br><span class="line">linux-0.11/kernel/exit.c</span><br><span class="line">linux-0.11/kernel/printk.c //根据实验楼的提示修改</span><br><span class="line">linux-0.11/init/main.c     //根据实验楼的提示修改</span><br></pre></td></tr></table></figure><h2 id="1-编写process-c"><a href="#1-编写process-c" class="headerlink" title="1. 编写process.c"></a>1. 编写<code>process.c</code></h2><p>实验的要求是多进程并行，并且在子进程全部退出之后，父进程在才退出。代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add head</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HZ100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpuio_bound</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> cpu_time, <span class="keyword">int</span> io_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_PROC 5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid[N_PROC];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NR_PROC; i++) &#123;</span><br><span class="line">        <span class="keyword">pid_t</span> cur_pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(cur_pid == <span class="number">0</span>) &#123; <span class="comment">//子进程调用fork后，返回0</span></span><br><span class="line">cpuio_bound(<span class="number">2</span>*(i+<span class="number">1</span>), <span class="number">0</span>, <span class="number">1</span>); <span class="comment">//子进程的运行设置为递增</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the pid is %d, the father pid is %d.\n"</span>, getpid(), getppid());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//退出子进程</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//父进程返回的是子进程的pid</span></span><br><span class="line">pid[i] = cur_pid;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the %d child pid is %d\n"</span>, i, pid[i]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NR_PROC; i++)&#123;</span><br><span class="line">wait(&amp;pid[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the parent is finished.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpuio_bound</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> cpu_time, <span class="keyword">int</span> io_time)</span></span>&#123;</span><br><span class="line"><span class="comment">// teach code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环创建子进程，然后在父进程利用<code>wait()</code>来等待子进程结束，然后父进程才退出。测试如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc process.c</span><br><span class="line">$ ./a.out</span><br></pre></td></tr></table></figure><p>可以通过注释掉<code>wait()</code>部分的代码，看到父进程提前结束的情况。</p><p>运行结果如下：</p><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/process.c_with_wait.jpg" width="500"></center><p>可以看出进程并行计算，如何设置每个进程运行时间一样的话，你将看到输出中下面的五行的顺序是乱序的，这里我就不演示了。</p><p>注释掉<code>wait()</code>代码后的结果如下：</p><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/process.c_without_wait.jpg" width="500"></center><p>可以看出当我们注释掉<code>wait()</code>后，父进程提前退出了。子进程重新关联1号进程为父进程。</p><h2 id="2-写process-log文件"><a href="#2-写process-log文件" class="headerlink" title="2. 写process.log文件"></a>2. 写process.log文件</h2><p>一开始的时候，我看到实验楼那里老师说：<strong>“只有进程 0 和进程 1 的文件描述符肯定关联着 log 文件”</strong>，所以我就在每个地方要写入<code>process.log</code>时，都重新打开<code>process.log</code>文件，并且关闭。然而我发现根本没法在<code>sched.c</code>文件里面这样做，一直在报错说有问题。所以看一了下网上的参考答案，发现他们都没有重新打开😂😂，直接用老师给的函数直接写入<code>process.log</code>文件。瞬间有种被老师坑了的感觉。。。</p><h3 id="2-1-修改fork-c文件"><a href="#2-1-修改fork-c文件" class="headerlink" title="2.1 修改fork.c文件"></a>2.1 修改<code>fork.c</code>文件</h3><p>在<code>fork.c</code>中的<code>copy_process()</code>是复制创建进程的主要代码，在这里进程被创建和进入就绪态。</p><p>添加的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">(<span class="keyword">int</span> nr,<span class="keyword">long</span> ebp,<span class="keyword">long</span> edi,<span class="keyword">long</span> esi,<span class="keyword">long</span> gs,<span class="keyword">long</span> none,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> ebx,<span class="keyword">long</span> ecx,<span class="keyword">long</span> edx,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> fs,<span class="keyword">long</span> es,<span class="keyword">long</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> eip,<span class="keyword">long</span> cs,<span class="keyword">long</span> eflags,<span class="keyword">long</span> esp,<span class="keyword">long</span> ss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">....</span><br><span class="line">p-&gt;state = TASK_RUNNING;<span class="comment">/* do this last, just in case */</span></span><br><span class="line"></span><br><span class="line">  fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, p-&gt;pid, <span class="string">'N'</span>, jiffies);</span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, p-&gt;pid, <span class="string">'J'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> last_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-修改sched-c文件"><a href="#2-2-修改sched-c文件" class="headerlink" title="2.2 修改sched.c文件"></a>2.2 修改<code>sched.c</code>文件</h3><p>在<code>sched.c</code>里面我们要修改如下的几个函数<code>schedule()</code>，<code>sys_puase()</code>，<code>sleep_on()</code>，<code>interruptible_sleep_on</code>，<code>wake_up()</code>。</p><h4 id="1-修改进程调度函数schedule-函数"><a href="#1-修改进程调度函数schedule-函数" class="headerlink" title="1. 修改进程调度函数schedule()函数"></a>1. 修改进程调度函数<code>schedule()</code>函数</h4><p>这里参考了<a href="https://github.com/Wangzhike/HIT-Linux-0.11/blob/master/3-processTrack/linux-0.11/kernel/sched.c" target="_blank" rel="noopener">github.com/Wangzhike/HIT-linux-0.11</a>，当时把next的意思理解错了，导致耽误了很久没做出来(其实是因为我没仔细看源码😂😂)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,next,c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span></span><br><span class="line"><span class="comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line"><span class="keyword">if</span> (*p) &#123;</span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123;</span><br><span class="line">(*p)-&gt;signal |= (<span class="number">1</span>&lt;&lt;(SIGALRM<span class="number">-1</span>));</span><br><span class="line">(*p)-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;</span><br><span class="line">(*p)-&gt;state==TASK_INTERRUPTIBLE)&#123;</span><br><span class="line">(*p)-&gt;state=TASK_RUNNING;</span><br><span class="line"></span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, (*p)-&gt;pid, <span class="string">'J'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* this is the scheduler proper: */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">c = <span class="number">-1</span>;next = <span class="number">0</span>;i = NR_TASKS;p = &amp;task[NR_TASKS];</span><br><span class="line"><span class="keyword">while</span> (--i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!*--p) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">c = (*p)-&gt;counter, next = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line"><span class="keyword">if</span> (*p)</span><br><span class="line">(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) +</span><br><span class="line">(*p)-&gt;priority;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span>(current-&gt;pid != task[next] -&gt;pid)&#123; <span class="comment">//这里应该是task[next]-&gt;pid</span></span><br><span class="line">        <span class="keyword">if</span>(current-&gt;state == TASK_RUNNING)</span><br><span class="line">            fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, current-&gt;pid, <span class="string">'J'</span>, jiffies);</span><br><span class="line">        fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, task[next]-&gt;pid, <span class="string">'R'</span>, jiffies);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">switch_to(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-修改sys-pause-函数"><a href="#2-修改sys-pause-函数" class="headerlink" title="2. 修改sys_pause()函数"></a>2. 修改<code>sys_pause()</code>函数</h4><p>因为系统无事可做的时候，进程 0 会不停地调用 <code>sys_pause()</code>，以激活调度算法。所以我们要判断是不是0进程调用<code>sys_pause()</code>，如果是0进程的话，我们不向process.log添加内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_pause</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(current-&gt;pid != <span class="number">0</span>)</span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, current-&gt;pid, <span class="string">'W'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">schedule();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-修改sleep-on-函数"><a href="#3-修改sleep-on-函数" class="headerlink" title="3. 修改sleep_on()函数"></a>3. 修改<code>sleep_on()</code>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_on</span><span class="params">(struct task_struct **p)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (current == &amp;(init_task.task)) panic(<span class="string">"task[0] trying to sleep"</span>);</span><br><span class="line">tmp = *p; *p = current;</span><br><span class="line">current-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line"></span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, current-&gt;pid, <span class="string">'W'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">schedule();</span><br><span class="line"><span class="keyword">if</span> (tmp)&#123;</span><br><span class="line">tmp-&gt;state=<span class="number">0</span>; <span class="comment">// 0对应的是TASK_RUNNING</span></span><br><span class="line"></span><br><span class="line">    fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, tmp-&gt;pid, <span class="string">'J'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-修改interruptible-sleep-on函数"><a href="#4-修改interruptible-sleep-on函数" class="headerlink" title="4. 修改interruptible_sleep_on函数"></a>4. 修改<code>interruptible_sleep_on</code>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptible_sleep_on</span><span class="params">(struct task_struct **p)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (current == &amp;(init_task.task)) panic(<span class="string">"task[0] trying to sleep"</span>);</span><br><span class="line">tmp=*p; *p=current;</span><br><span class="line">repeat:current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line"></span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, current-&gt;pid, <span class="string">'W'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">schedule();</span><br><span class="line"><span class="keyword">if</span> (*p &amp;&amp; *p != current) &#123;</span><br><span class="line">(**p).state=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, (**p).pid, <span class="string">'J'</span>, jiffies);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> repeat;</span><br><span class="line">&#125;</span><br><span class="line">*p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp)&#123;</span><br><span class="line">tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, tmp-&gt;pid, <span class="string">'J'</span>, jiffies);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-修改wake-up-函数"><a href="#5-修改wake-up-函数" class="headerlink" title="5. 修改wake_up()函数"></a>5. 修改<code>wake_up()</code>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up</span><span class="params">(struct task_struct **p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp;&amp; *p) &#123;</span><br><span class="line">(**p).state=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, (**p).pid, <span class="string">'J'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">*p=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-修改exit-c文件"><a href="#2-3-修改exit-c文件" class="headerlink" title="2.3 修改exit.c文件"></a>2.3 修改<code>exit.c</code>文件</h3><p>主要修改<code>do_exit()</code>和<code>sys_waitpid()</code>这两个函数。</p><h4 id="1-修改do-exit-函数"><a href="#1-修改do-exit-函数" class="headerlink" title="1. 修改do_exit()函数"></a>1. 修改<code>do_exit()</code>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_exit</span><span class="params">(<span class="keyword">long</span> code)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">current-&gt;state = TASK_ZOMBIE;</span><br><span class="line">current-&gt;exit_code = code;</span><br><span class="line"></span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, current-&gt;pid, <span class="string">'E'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">tell_father(current-&gt;father);</span><br><span class="line">schedule();</span><br><span class="line"><span class="keyword">return</span> (<span class="number">-1</span>);<span class="comment">/* just to suppress warnings */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-修改sys-waitpid-函数"><a href="#2-修改sys-waitpid-函数" class="headerlink" title="2. 修改sys_waitpid()函数"></a>2. 修改<code>sys_waitpid()</code>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">unsigned</span> <span class="keyword">long</span> * stat_addr, <span class="keyword">int</span> options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flag, code;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">verify_area(stat_addr,<span class="number">4</span>);</span><br><span class="line">repeat:</span><br><span class="line">  </span><br><span class="line">....</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="keyword">if</span> (options &amp; WNOHANG)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">current-&gt;state=TASK_INTERRUPTIBLE;</span><br><span class="line"></span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, current-&gt;pid, <span class="string">'W'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">schedule();</span><br><span class="line"><span class="keyword">if</span> (!(current-&gt;signal &amp;= ~(<span class="number">1</span>&lt;&lt;(SIGCHLD<span class="number">-1</span>))))</span><br><span class="line"><span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> -EINTR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -ECHILD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-统计process-log文件"><a href="#2-4-统计process-log文件" class="headerlink" title="2.4 统计process.log文件"></a>2.4 统计process.log文件</h3><p>下面是在我电脑上运行的结果</p><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/process.log.jpg" width="500"></center><h2 id="3-修改时间片"><a href="#3-修改时间片" class="headerlink" title="3. 修改时间片"></a>3. 修改时间片</h2><p>在目录<code>linux-0.11/include/linux/sched.h</code>中的<code>INIT_TASK</code>里面，可以修改0进程的时间片的大小，源代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里可以修改时间片</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK \</span></span><br><span class="line"><span class="comment">/* state etc */</span>&#123; <span class="number">0</span>,<span class="number">15</span>,<span class="number">15</span>, \<span class="comment">//这里的0，15，15 分别对应着state、counter 和 priority;</span></span><br><span class="line"><span class="comment">/* signals */</span><span class="number">0</span>,&#123;&#123;&#125;,&#125;,<span class="number">0</span>, \</span><br><span class="line"><span class="comment">/* ec,brk... */</span><span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \</span><br><span class="line"><span class="comment">/* pid etc.. */</span><span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \</span><br><span class="line"><span class="comment">/* uid etc */</span><span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \</span><br><span class="line"><span class="comment">/* alarm */</span><span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \</span><br><span class="line"><span class="comment">/* math */</span><span class="number">0</span>, \</span><br></pre></td></tr></table></figure><p>可以通过给改这里的东西来修改时间片的大小。具体的比较我感觉不是很明显，在这里就不给出了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;课程链接：&lt;a href=&quot;https://www.lanqiao.cn/courses/115/learning/?id=570&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;进程运行轨迹跟踪与统计&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot; class=&quot;headerlink&quot; title=&quot;实验内容&quot;&gt;&lt;/a&gt;实验内容&lt;/h2&gt;&lt;p&gt;进程从创建（Linux 下调用 fork()）到结束的整个过程就是进程的生命期，进程在其生命期中的运行轨迹实际上就表现为进程状态的多次切换，如进程创建以后会成为就绪态；当该进程被调度以后会切换到运行态；在运行的过程中如果启动了一个文件读写操作，操作系统会将该进程切换到阻塞态（等待态）从而让出 CPU；当文件读写完毕以后，操作系统会在将其切换成就绪态，等待进程调度算法来调度该进程执行……&lt;/p&gt;
&lt;p&gt;本次实验包括如下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于模板 &lt;code&gt;process.c&lt;/code&gt; 编写多进程的样本程序，实现如下功能： + 所有子进程都并行运行，每个子进程的实际运行时间一般不超过 30 秒； + 父进程向标准输出打印所有q子进程的 id，并在所有子进程都退出后才退出；&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;Linux0.11&lt;/code&gt; 上实现进程运行轨迹的跟踪。 + 基本任务是在内核中维护一个日志文件 &lt;code&gt;/var/process.log&lt;/code&gt;，把从操作系统启动到系统关机过程中所有进程的运行轨迹都记录在这一 log 文件中。&lt;/li&gt;
&lt;li&gt;在修改过的 0.11 上运行样本程序，通过分析 log 文件，统计该程序建立的所有进程的等待时间、完成时间（周转时间）和运行时间，然后计算平均等待时间，平均完成时间和吞吐量。可以自己编写统计程序，也可以使用 python 脚本程序—— &lt;code&gt;stat_log.py&lt;/code&gt;（在 &lt;code&gt;/home/teacher/&lt;/code&gt; 目录下） ——进行统计。&lt;/li&gt;
&lt;li&gt;修改 0.11 进程调度的时间片，然后再运行同样的样本程序，统计同样的时间数据，和原有的情况对比，体会不同时间片带来的差异。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="https://haohuaijin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>实验1:操作系统的引导</title>
    <link href="https://haohuaijin.github.io/2020/10/06/%E5%AE%9E%E9%AA%8C1:%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC/"/>
    <id>https://haohuaijin.github.io/2020/10/06/%E5%AE%9E%E9%AA%8C1:%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC/</id>
    <published>2020-10-06T08:31:49.000Z</published>
    <updated>2020-10-06T08:43:04.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验的准备工作操作"><a href="#实验的准备工作操作" class="headerlink" title="实验的准备工作操作"></a>实验的准备工作操作</h2><ul><li>解压源码用<code>tar -zxvf hit-oslab-linux-20110823.tar.gz</code> 可以使用<code>-C</code>来指定解压路径，<code>tar -zxvf hit-oslab-linux-20110823.tar.gz -C [path]</code></li><li>编译linux-0.11的源码，在<code>linux-0.11</code>的文件夹下运行<code>make all</code>或者<code>make</code>。</li><li>在oslab文件目录下运行<code>./run</code>运行<code>bochs 中的linux-0.11</code>。</li><li>访问linux-0.11里面的文件，使用<code>sudo ./mount-hdc</code>来装载硬盘，然后在<code>hdc</code>中访问，卸载硬盘<code>sudo umount hdc</code>。</li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol><li>阅读《Linux 内核完全注释》的第 6 章，对计算机和 Linux 0.11 的引导过程进行初步的了解；</li><li>按照下面的要求改写 0.11 的引导程序 bootsect.s</li><li>有兴趣同学可以做做进入保护模式前的设置程序 setup.s。</li></ol><a id="more"></a><h3 id="改写-bootsect-s-主要完成如下功能："><a href="#改写-bootsect-s-主要完成如下功能：" class="headerlink" title="改写 bootsect.s 主要完成如下功能："></a>改写 bootsect.s 主要完成如下功能：</h3><ul><li>bootsect.s 能在屏幕上打印一段提示信息“XXX is booting…”，其中 XXX 是你给自己的操作系统起的名字，也可以显示一个特色 logo，以表示自己操作系统的与众不同。</li></ul><h3 id="改写-setup-s-主要完成如下功能："><a href="#改写-setup-s-主要完成如下功能：" class="headerlink" title="改写 setup.s 主要完成如下功能："></a>改写 setup.s 主要完成如下功能：</h3><ol><li>bootsect.s 能完成 setup.s 的载入，并跳转到 setup.s 开始地址执行。而 setup.s 向屏幕输出一行”Now we are in SETUP”。</li><li>setup.s 能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。</li><li>setup.s 不再加载 Linux 内核，保持上述信息显示在屏幕上即可。</li></ol><h2 id="bootsect-s的修改"><a href="#bootsect-s的修改" class="headerlink" title="bootsect.s的修改"></a>bootsect.s的修改</h2><p><code>bootsect.s</code>的功能是将自己从<code>0x7c00</code>处移动到了<code>0x90000</code>处。显示字符<code>loding system ...</code>，然后将磁盘上的<code>setup.s</code>和<code>system</code>模块加载到内存中来，最后跳转到<code>setup.s</code>所在的位置，执行<code>setup.s</code>。</p><p><strong>实验内容：</strong></p><ol><li><p>bootsect.s 能在屏幕上打印一段提示信息“XXX is booting…”；</p></li><li><p>bootsect.s 能完成 setup.s 的载入，并跳转到 setup.s 开始地址执行。</p></li></ol><h3 id="1-bootsect-s-打印字符"><a href="#1-bootsect-s-打印字符" class="headerlink" title="1. bootsect.s 打印字符"></a>1. bootsect.s 打印字符</h3><p>首先使用<strong>BIOS</strong><code>0x10</code>号中断的子功能<code>0x03</code>获得光标的位置，然后再利用<strong>BIOS</strong><code>0x10</code>号中断的子功能<code>0x13</code>打印字符到屏幕上。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">entry start</span><br><span class="line">start:</span><br><span class="line">    movah,#0x03! read cursor pos</span><br><span class="line">  xorbh,bh</span><br><span class="line">  int0x10</span><br><span class="line"></span><br><span class="line">    mov cx,#26</span><br><span class="line">    mov bl,#07</span><br><span class="line">    mov bp,#msg !寻址es:bp</span><br><span class="line">    mov ax,#0x7c0 !因为bootsect的代码放在0x7c00处</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10 </span><br><span class="line">msg:</span><br><span class="line">    .byte 13,10 !回车和换行</span><br><span class="line">    .ascii &quot;HaoOS is loading ...&quot;</span><br><span class="line">    .byte 13,10,13,10</span><br><span class="line"></span><br><span class="line">.org 510</span><br><span class="line">boot_flag:</span><br><span class="line">    .word 0xAA55</span><br></pre></td></tr></table></figure><p>在<strong>BIOS</strong>中断指令<code>int</code>前面的代码都是为中断设置一些参数。最后的三行是因为bootsect的大小必须为512字节，所以添加到后面使编译后的文件大小为512字节，最后两个字节为<code>0xAA55</code>。</p><h3 id="2-载入setup并跳转"><a href="#2-载入setup并跳转" class="headerlink" title="2. 载入setup并跳转"></a>2. 载入setup并跳转</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">entry start</span><br><span class="line">start:</span><br><span class="line">    movah,#0x03! read cursor pos</span><br><span class="line">  xorbh,bh</span><br><span class="line">  int0x10</span><br><span class="line"></span><br><span class="line">    mov cx,#26</span><br><span class="line">    mov bl,#07</span><br><span class="line">    mov bp,#msg !寻址es:bp</span><br><span class="line">    mov ax,#0x7c0 !因为bootsect的代码放在0x7c00处</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">load_setup:</span><br><span class="line">movdx,#0x0000! drive 0, head 0</span><br><span class="line">movcx,#0x0002! sector 2, track 0</span><br><span class="line">movbx,#0x0200! address = 512, in INITSEG</span><br><span class="line">movax,#0x0200+4    ! service 2, nr of sectors</span><br><span class="line">int0x13! read it</span><br><span class="line"></span><br><span class="line">  jmpi 0,#0x07e0      ! jump to setup 0x07e0 = 0x07c0 + 0x0200</span><br><span class="line">                        ! there is set cs to 0x07e0, in the setup the cs be used.</span><br><span class="line"></span><br><span class="line">msg:</span><br><span class="line">    .byte 13,10 !回车和换行</span><br><span class="line">    .ascii &quot;HaoOS is loading ...&quot;</span><br><span class="line">    .byte 13,10,13,10</span><br><span class="line"></span><br><span class="line">.org 510</span><br><span class="line">boot_flag:</span><br><span class="line">    .word 0xAA55</span><br></pre></td></tr></table></figure><p>在第一部分的代码中添加了load_step的部分，这一部分利用BIOS<code>0x13</code>中断读入<code>setup.s</code>然后利用<code>jmpi</code>跳转到<code>setup.s</code>模块开始的地方。</p><p><strong>注意</strong>：</p><p>由于在bootsect中我们并没有移动bootsect的位置，所以在跳转的时候的地址是<code>0x07c0 + 0x0200 = 0x07e0</code>，而不是和linux-0.11中一样跳转到<code>0x90200</code>处。</p><h2 id="setup的修改"><a href="#setup的修改" class="headerlink" title="setup的修改"></a>setup的修改</h2><p>setup的主要功能是使用BIOS中断读取系统参数，然后放到内存中的指定位置，同时将cpu从实模式转化到保护模式。</p><p><strong>实验内容</strong>：</p><ol><li>setup.s 向屏幕输出一行”Now we are in SETUP”。</li><li>setup.s 能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。</li><li>setup.s 不再加载 Linux 内核，保持上述信息显示在屏幕上即可。</li></ol><h3 id="1-setup向屏幕输出字符"><a href="#1-setup向屏幕输出字符" class="headerlink" title="1. setup向屏幕输出字符"></a>1. setup向屏幕输出字符</h3><p>这一部分代码和bootsect部分类似。有的部分需要修改，比如<code>es</code>寄存器的指向，还有打印的字符的长度。</p><h3 id="2-获取硬件参数并打印"><a href="#2-获取硬件参数并打印" class="headerlink" title="2. 获取硬件参数并打印"></a>2. 获取硬件参数并打印</h3><p>这里如何获取硬件参数，既可以参考linux-0.11的源码，也可以自己查看BIOS中断的手册。我在这里比较迷惑的是如何将获得的参数打印到屏幕上？看了老师的实现后，发现还是比较简单的，主要问题是自己对汇编语言还是不够熟悉。老师的代码如下(大体的思路是先读参数，然后获取光标，打印，获取光标，打印…..)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">INITSEG  = 0x9000</span><br><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">! Print &quot;NOW we are in SETUP&quot;</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#25</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg2</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov es,ax</span><br><span class="line">! init ss:sp</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,#0xFF00</span><br><span class="line"></span><br><span class="line">! Get Params</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov [0],dx</span><br><span class="line">    </span><br><span class="line">    mov ah,#0x88</span><br><span class="line">    int 0x15</span><br><span class="line">    mov [2],ax</span><br><span class="line">! 这里是如何把参数保存到数据段里面的</span><br><span class="line">    mov ax,#0x0000</span><br><span class="line">    mov ds,ax</span><br><span class="line">    lds si,[4*0x41]</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,#0x0004</span><br><span class="line">    mov cx,#0x10</span><br><span class="line">    rep</span><br><span class="line">    movsb</span><br><span class="line"></span><br><span class="line">! Be Ready to Print</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">! Cursor Position</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#18</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_cursor</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[0]</span><br><span class="line">    call    print_hex</span><br><span class="line">! Memory Size</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#14</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_memory</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[2]</span><br><span class="line">    call    print_hex</span><br><span class="line">! Add KB</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#2</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_kb</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">! Cyles</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#7</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_cyles</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[4]</span><br><span class="line">    call    print_hex</span><br><span class="line">! Heads</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#8</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_heads</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[6]</span><br><span class="line">    call    print_hex</span><br><span class="line">! Secotrs</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#10</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_sectors</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[12]</span><br><span class="line">    call    print_hex</span><br><span class="line"></span><br><span class="line">inf_loop:</span><br><span class="line">    jmp inf_loop</span><br><span class="line"></span><br><span class="line">print_hex:</span><br><span class="line">    mov    cx,#4</span><br><span class="line">print_digit:</span><br><span class="line">    rol    dx,#4</span><br><span class="line">    mov    ax,#0xe0f</span><br><span class="line">    and    al,dl</span><br><span class="line">    add    al,#0x30</span><br><span class="line">    cmp    al,#0x3a</span><br><span class="line">    jl     outp</span><br><span class="line">    add    al,#0x07</span><br><span class="line">outp:</span><br><span class="line">    int    0x10</span><br><span class="line">    loop   print_digit</span><br><span class="line">    ret</span><br><span class="line">print_nl:</span><br><span class="line">    mov    ax,#0xe0d     ! CR</span><br><span class="line">    int    0x10</span><br><span class="line">    mov    al,#0xa     ! LF</span><br><span class="line">    int    0x10</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">msg2:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;NOW we are in SETUP&quot;</span><br><span class="line">    .byte 13,10,13,10</span><br><span class="line">msg_cursor:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Cursor position:&quot;</span><br><span class="line">msg_memory:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Memory Size:&quot;</span><br><span class="line">msg_cyles:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Cyls:&quot;</span><br><span class="line">msg_heads:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Heads:&quot;</span><br><span class="line">msg_sectors:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Sectors:&quot;</span><br><span class="line">msg_kb:</span><br><span class="line">    .ascii &quot;KB&quot;</span><br><span class="line"></span><br><span class="line">.org 510</span><br><span class="line">boot_flag:</span><br><span class="line">    .word 0xAA55</span><br></pre></td></tr></table></figure><p>这里如何使用的bootsect还是上个实验的代码的话，需要把前面的<code>INITSEG</code>改成<code>0x07e0</code>。</p><p><strong>疑问：</strong></p><p>在上面代码的获取参数部分，不明白是如何把数据保存到特定位置的？如何循环的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,#0x0000</span><br><span class="line">mov ds,ax</span><br><span class="line">lds si,[4*0x41]</span><br><span class="line">mov ax,#INITSEG</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,#0x0004</span><br><span class="line">mov cx,#0x10</span><br><span class="line">rep</span><br><span class="line">movsb</span><br></pre></td></tr></table></figure><p>试着解释：在这里是从原地址到目的地址移动1字节的内容，这里设置<code>cs=16</code>，意思是移动16次，共16字节。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实验的准备工作操作&quot;&gt;&lt;a href=&quot;#实验的准备工作操作&quot; class=&quot;headerlink&quot; title=&quot;实验的准备工作操作&quot;&gt;&lt;/a&gt;实验的准备工作操作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;解压源码用&lt;code&gt;tar -zxvf hit-oslab-linux-20110823.tar.gz&lt;/code&gt; 可以使用&lt;code&gt;-C&lt;/code&gt;来指定解压路径，&lt;code&gt;tar -zxvf hit-oslab-linux-20110823.tar.gz -C [path]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;编译linux-0.11的源码，在&lt;code&gt;linux-0.11&lt;/code&gt;的文件夹下运行&lt;code&gt;make all&lt;/code&gt;或者&lt;code&gt;make&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在oslab文件目录下运行&lt;code&gt;./run&lt;/code&gt;运行&lt;code&gt;bochs 中的linux-0.11&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;访问linux-0.11里面的文件，使用&lt;code&gt;sudo ./mount-hdc&lt;/code&gt;来装载硬盘，然后在&lt;code&gt;hdc&lt;/code&gt;中访问，卸载硬盘&lt;code&gt;sudo umount hdc&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot; class=&quot;headerlink&quot; title=&quot;实验内容&quot;&gt;&lt;/a&gt;实验内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;阅读《Linux 内核完全注释》的第 6 章，对计算机和 Linux 0.11 的引导过程进行初步的了解；&lt;/li&gt;
&lt;li&gt;按照下面的要求改写 0.11 的引导程序 bootsect.s&lt;/li&gt;
&lt;li&gt;有兴趣同学可以做做进入保护模式前的设置程序 setup.s。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="https://haohuaijin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>实验2:系统调用</title>
    <link href="https://haohuaijin.github.io/2020/10/06/%E5%AE%9E%E9%AA%8C2:%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>https://haohuaijin.github.io/2020/10/06/%E5%AE%9E%E9%AA%8C2:%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</id>
    <published>2020-10-06T07:23:38.000Z</published>
    <updated>2020-10-06T07:33:17.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验2-系统调用"><a href="#实验2-系统调用" class="headerlink" title="实验2: 系统调用"></a>实验2: 系统调用</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>在 Linux 0.11 上添加两个系统调用，并编写两个简单的应用程序测试它们。</p><h3 id="1-iam"><a href="#1-iam" class="headerlink" title="1. iam()"></a>1. <code>iam()</code></h3><p>第一个系统调用是 iam()，其原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * name)</span></span>;</span><br></pre></td></tr></table></figure><p>完成的功能是将字符串参数 <code>name</code> 的内容拷贝到内核中保存下来。要求 <code>name</code> 的长度不能超过 23 个字符。返回值是拷贝的字符数。如果 <code>name</code> 的字符个数超过了 <code>23</code>，则返回 “-1”，并置 errno 为 EINVAL。</p><p>在 <code>kernal/who.c</code> 中实现此系统调用。</p><h3 id="2-whoami"><a href="#2-whoami" class="headerlink" title="2. whoami()"></a>2. <code>whoami()</code></h3><p>第二个系统调用是 whoami()，其原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">whoami</span><span class="params">(<span class="keyword">char</span>* name, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>它将内核中由 <code>iam()</code> 保存的名字拷贝到 name 指向的用户地址空间中，同时确保不会对 <code>name</code> 越界访存（<code>name</code> 的大小由 <code>size</code> 说明）。返回值是拷贝的字符数。如果 <code>size</code> 小于需要的空间，则返回“-1”，并置 errno 为 EINVAL。</p><p>也是在 <code>kernal/who.c</code> 中实现。</p><h3 id="3-测试程序"><a href="#3-测试程序" class="headerlink" title="3. 测试程序"></a>3. 测试程序</h3><p>运行添加过新系统调用的 Linux 0.11，在其环境下编写两个测试程序 iam.c 和 whoami.c。最终的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./iam lizhijun</span><br><span class="line">$ ./whoami</span><br><span class="line">lizhijun</span><br></pre></td></tr></table></figure><h2 id="系统调用简介"><a href="#系统调用简介" class="headerlink" title="系统调用简介"></a>系统调用简介</h2><p>系统调用和一般的函数调用在使用方式上没有区别，区别在于调用之后函数内部如何处理。</p><a id="more"></a><p>系统调用中使用<code>int 0x80</code>来切换到内核态，使用内核中的系统函数来完成系统调用，如下面的步骤：</p><ol><li>应用程序调用库函数（API）；</li><li>API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态；</li><li>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</li><li>系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数；</li><li>中断处理函数返回到 API 中；</li><li>API 将 EAX 返回给应用程序。</li></ol><p>下图是一个系统调用在内核里面的调用流程：</p><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/系统调用.png" width="600"></center><p>需要修改的文件(以linux-0.11为主文件夹)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">linux-0.11/include/linux/sys.h</span><br><span class="line">linux-0.11/kernel/system_call.s</span><br><span class="line">linux-0.11/kernel/Makefile</span><br><span class="line">在linux-0.11/kernel中添加文件</span><br><span class="line">who.c</span><br><span class="line"></span><br><span class="line">下面的需要在虚拟机中的linux系统中修改:</span><br><span class="line">在linux-0.11的文件目录下修改</span><br><span class="line">/usr/root/include/unistd.h</span><br><span class="line">~/iam.c</span><br><span class="line">~/whoami.c</span><br></pre></td></tr></table></figure><h2 id="修改sys-h"><a href="#修改sys-h" class="headerlink" title="修改sys.h"></a>修改<code>sys.h</code></h2><p>在<code>sys.h</code>中维护了一个<code>sys_call_table</code>是一个函数指针数组，通过系统调用号，然后在数组中找到相应的中断处理函数。我们要将自己编写的系统调用添加到里面，就如以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_iam</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_whoami</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">fn_ptr sys_call_table[] = &#123;......,sys_setregid,sys_iam,sys_whoami&#125;;</span><br></pre></td></tr></table></figure><h2 id="修改unistd-h"><a href="#修改unistd-h" class="headerlink" title="修改unistd.h"></a>修改<code>unistd.h</code></h2><p>在<code>unistd.h</code>中定义了系统调用的编号，和一些宏，如下面所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define __NR_setregid71</span><br><span class="line">//在这里添加我们自己的系统调用编号，使我们的系统调用可以在sys.h中找到</span><br><span class="line">#define __NR_iam72</span><br><span class="line">#define __NR_whoami73</span><br><span class="line"></span><br><span class="line">//这里定义了一个没有参数输入的系统调用宏。</span><br><span class="line">#define _syscall0(type,name) \</span><br><span class="line">type name(void) \</span><br><span class="line">&#123; \</span><br><span class="line">long __res; \</span><br><span class="line">__asm__ volatile (&quot;int $0x80&quot; \</span><br><span class="line">: &quot;=a&quot; (__res) \</span><br><span class="line">: &quot;0&quot; (__NR_##name)); \  //这里就是把系统调用编号，存入EAX中。</span><br><span class="line">if (__res &gt;= 0) \</span><br><span class="line">return (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line">return -1; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改system-call-s"><a href="#修改system-call-s" class="headerlink" title="修改system_call.s"></a>修改<code>system_call.s</code></h2><p>将其中第61行的<code>nr_system_calls = 72</code>里面的72改成74，因为这里的<code>nr_system_calls</code>指的是总共有多少个系统调用。</p><h2 id="修改Makefile"><a href="#修改Makefile" class="headerlink" title="修改Makefile"></a>修改<code>Makefile</code></h2><p>修改内容如下，在<code>OBJS</code>最后添加<code>who.o</code>，让内核中包含<code>who.c</code>里面的内容。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJS  = sched.o system_call.o traps.o asm.o fork.o \</span><br><span class="line">panic.o printk.o vsprintf.o sys.o exit.o \</span><br><span class="line">signal.o mktime.o who.o</span><br></pre></td></tr></table></figure><p>然后在末尾添加如下内容，对<code>who.c</code>编译，链接。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who.s who.o: who.c  ../<span class="keyword">include</span>/linux/kernel.h ../<span class="keyword">include</span>/unistd.h <span class="comment">#! add who.c</span></span><br></pre></td></tr></table></figure><h2 id="编写who-c"><a href="#编写who-c" class="headerlink" title="编写who.c"></a>编写<code>who.c</code></h2><p>在<code>who.c</code>中要实现<code>iam()</code>和<code>whami()</code>这两个函数，这里参考了[<a href="https://ehye.github.io/2020/04/01/hit-oslab2/][https://ehye.github.io/2020/04/01/hit-oslab2/]" target="_blank" rel="noopener">https://ehye.github.io/2020/04/01/hit-oslab2/][https://ehye.github.io/2020/04/01/hit-oslab2/]</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/segment.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> myname[<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_iam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">25</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123; <span class="comment">// get char from user input</span></span><br><span class="line">        str[i] = get_fs_byte(name + i);</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt;= <span class="number">25</span> &amp;&amp; str[i++] != <span class="string">'\0'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">24</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(myname, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_whoami</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>(myname);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt; length)&#123;</span><br><span class="line">        <span class="keyword">return</span> -(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// copy from kernel mode to user mode</span></span><br><span class="line">        put_fs_byte(myname[i], name + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上面的代码要注意的是，这里代码是位于内核态的。我们定义的数据都是在内核态中定义的。无法直接获取用户态的内容，所以这里用了两个函数<code>get_fs_byte</code>和<code>put_fs_byte</code>，第一个用来得到用户态的数据，第二个用来将数据存入用户态</strong>。</p><h2 id="编写iam-和whoami"><a href="#编写iam-和whoami" class="headerlink" title="编写iam()和whoami()"></a>编写<code>iam()</code>和<code>whoami()</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//iam()在用户空间的接口函数</span></span><br><span class="line"><span class="comment">// 这是定义在unistd.h里面的一个宏，展开后是一个包含int 0x80中断的代码。</span></span><br><span class="line">_syscall1(<span class="keyword">int</span>, iam, <span class="keyword">const</span> <span class="keyword">char</span>*, name);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    iam(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// whoami()在用户空间的接口函数</span></span><br><span class="line"><span class="comment">// 这是定义在unistd.h里面的一个宏，展开后是一个包含int 0x80中断的代码。</span></span><br><span class="line">_syscall2(<span class="keyword">int</span>, whoami,<span class="keyword">char</span>*,name,<span class="keyword">unsigned</span> <span class="keyword">int</span>,<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">    whoami(name, <span class="number">30</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里要注意的是，<strong><code>#define __LIBRARY__</code>一定要在<code>#include &lt;unistd.h&gt;</code>前面，要不然就会报错</strong>，具体是什么原因，我现在还不清楚。</p><h2 id="调试运行"><a href="#调试运行" class="headerlink" title="调试运行"></a>调试运行</h2><p>完成上述的修改，并且重新编译运行linux-0.11后，在linux-0.11里面输入下面的命令，验证结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o iam iam.c</span><br><span class="line">$ gcc -o whoami whoami.c</span><br><span class="line">$ ./iam hello,world</span><br><span class="line">$ ./whoami</span><br><span class="line">hello,world</span><br></pre></td></tr></table></figure><h2 id="提交验证"><a href="#提交验证" class="headerlink" title="提交验证"></a>提交验证</h2><p>使用老师提供的<code>testlab2.c</code>和<code>testlab2.sh</code>来验证我们的代码，过程如下，需要在linux-0.11里面运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o iam iam.c</span><br><span class="line">$ gcc -o whoami whoami.c</span><br><span class="line">$ gcc testlab2.c</span><br><span class="line">$ ./a.out</span><br><span class="line"></span><br><span class="line">$ ./testlab2.sh</span><br></pre></td></tr></table></figure><p>运行<code>a.out</code>和<code>testlab2.sh</code>后的结果如下：</p><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/testlab2.c.jpg" width="600"></center><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/testlab2.sh.jpg" width="600"></center>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实验2-系统调用&quot;&gt;&lt;a href=&quot;#实验2-系统调用&quot; class=&quot;headerlink&quot; title=&quot;实验2: 系统调用&quot;&gt;&lt;/a&gt;实验2: 系统调用&lt;/h1&gt;&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot; class=&quot;headerlink&quot; title=&quot;实验内容&quot;&gt;&lt;/a&gt;实验内容&lt;/h2&gt;&lt;p&gt;在 Linux 0.11 上添加两个系统调用，并编写两个简单的应用程序测试它们。&lt;/p&gt;
&lt;h3 id=&quot;1-iam&quot;&gt;&lt;a href=&quot;#1-iam&quot; class=&quot;headerlink&quot; title=&quot;1. iam()&quot;&gt;&lt;/a&gt;1. &lt;code&gt;iam()&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;第一个系统调用是 iam()，其原型为：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;iam&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * name)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;完成的功能是将字符串参数 &lt;code&gt;name&lt;/code&gt; 的内容拷贝到内核中保存下来。要求 &lt;code&gt;name&lt;/code&gt; 的长度不能超过 23 个字符。返回值是拷贝的字符数。如果 &lt;code&gt;name&lt;/code&gt; 的字符个数超过了 &lt;code&gt;23&lt;/code&gt;，则返回 “-1”，并置 errno 为 EINVAL。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;kernal/who.c&lt;/code&gt; 中实现此系统调用。&lt;/p&gt;
&lt;h3 id=&quot;2-whoami&quot;&gt;&lt;a href=&quot;#2-whoami&quot; class=&quot;headerlink&quot; title=&quot;2. whoami()&quot;&gt;&lt;/a&gt;2. &lt;code&gt;whoami()&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;第二个系统调用是 whoami()，其原型为：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;whoami&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* name, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;它将内核中由 &lt;code&gt;iam()&lt;/code&gt; 保存的名字拷贝到 name 指向的用户地址空间中，同时确保不会对 &lt;code&gt;name&lt;/code&gt; 越界访存（&lt;code&gt;name&lt;/code&gt; 的大小由 &lt;code&gt;size&lt;/code&gt; 说明）。返回值是拷贝的字符数。如果 &lt;code&gt;size&lt;/code&gt; 小于需要的空间，则返回“-1”，并置 errno 为 EINVAL。&lt;/p&gt;
&lt;p&gt;也是在 &lt;code&gt;kernal/who.c&lt;/code&gt; 中实现。&lt;/p&gt;
&lt;h3 id=&quot;3-测试程序&quot;&gt;&lt;a href=&quot;#3-测试程序&quot; class=&quot;headerlink&quot; title=&quot;3. 测试程序&quot;&gt;&lt;/a&gt;3. 测试程序&lt;/h3&gt;&lt;p&gt;运行添加过新系统调用的 Linux 0.11，在其环境下编写两个测试程序 iam.c 和 whoami.c。最终的运行结果是：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ./iam lizhijun&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ./whoami&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lizhijun&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;系统调用简介&quot;&gt;&lt;a href=&quot;#系统调用简介&quot; class=&quot;headerlink&quot; title=&quot;系统调用简介&quot;&gt;&lt;/a&gt;系统调用简介&lt;/h2&gt;&lt;p&gt;系统调用和一般的函数调用在使用方式上没有区别，区别在于调用之后函数内部如何处理。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="https://haohuaijin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>华为云ubuntu配置nginx踩坑记录</title>
    <link href="https://haohuaijin.github.io/2020/09/06/%E5%8D%8E%E4%B8%BA%E4%BA%91ubuntu%E9%85%8D%E7%BD%AEnginx%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://haohuaijin.github.io/2020/09/06/%E5%8D%8E%E4%B8%BA%E4%BA%91ubuntu%E9%85%8D%E7%BD%AEnginx%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2020-09-06T00:46:41.000Z</published>
    <updated>2020-09-06T01:29:11.830Z</updated>
    
    <content type="html"><![CDATA[<p>服务器：华为云<br>操作系统： ubuntu 18.04<br>今天在华为云上配置nginx发现怎么也配置不成功，<strong>不能在浏览器上访问，同时也ping不通，不过在云服务器上的nginx是成功运行的。</strong></p><p>最后终于找到了解决办法，更改华为云的安全组配置，配置80端口，同时将它设置下面的内容，如图</p><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/华为云.png" width="700"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;服务器：华为云&lt;br&gt;操作系统： ubuntu 18.04&lt;br&gt;今天在华为云上配置nginx发现怎么也配置不成功，&lt;strong&gt;不能在浏览器上访问，同时也ping不通，不过在云服务器上的nginx是成功运行的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后终于找到了解决办法，更
      
    
    </summary>
    
    
    
      <category term="踩坑" scheme="https://haohuaijin.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>macos vim 进入可视块模式</title>
    <link href="https://haohuaijin.github.io/2020/08/08/macos-vim-%E8%BF%9B%E5%85%A5%E5%8F%AF%E8%A7%86%E5%9D%97%E6%A8%A1%E5%BC%8F/"/>
    <id>https://haohuaijin.github.io/2020/08/08/macos-vim-%E8%BF%9B%E5%85%A5%E5%8F%AF%E8%A7%86%E5%9D%97%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-08-08T14:43:16.000Z</published>
    <updated>2020-08-08T14:55:03.515Z</updated>
    
    <content type="html"><![CDATA[<p>在windows的vim上进入vim的块模式是<code>&lt;ctrl&gt;-v</code>。于是我以为在mac上应该是<code>&lt;command&gt;-v</code> ，试了试发现<code>&lt;command&gt;-v</code>是粘贴。然后去google搜索发现没有具体讲这个的，在这里记录一下。</p><p><strong>在macos中使用<code>&lt;control&gt;-v</code>就可以进入vim的块模式(列选择)。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在windows的vim上进入vim的块模式是&lt;code&gt;&amp;lt;ctrl&amp;gt;-v&lt;/code&gt;。于是我以为在mac上应该是&lt;code&gt;&amp;lt;command&amp;gt;-v&lt;/code&gt; ，试了试发现&lt;code&gt;&amp;lt;command&amp;gt;-v&lt;/code&gt;是粘贴。然后
      
    
    </summary>
    
    
    
      <category term="vim" scheme="https://haohuaijin.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>matlab for mac 打开cftool卡死解决方案</title>
    <link href="https://haohuaijin.github.io/2020/08/01/matlab-for-mac-%E6%89%93%E5%BC%80cftool%E5%8D%A1%E6%AD%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://haohuaijin.github.io/2020/08/01/matlab-for-mac-%E6%89%93%E5%BC%80cftool%E5%8D%A1%E6%AD%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2020-08-01T00:53:57.000Z</published>
    <updated>2020-08-01T01:17:44.620Z</updated>
    
    <content type="html"><![CDATA[<p>在mac上安装完matlab后，想试一试cftool的打开速度，结果一打开cftool就卡死了，然后去网上找了许多的资料，多没有想到相关的信息。</p><p>最后在matlab中文论坛发现有人在用matlab仿真时死机，解决方案是<strong>magnet对matlab仅用</strong>。于是我就试了试，成功解决问题。</p><p>如果你也有类似的问题，不妨试一试把Magnet对matlab禁用。</p><p>原地址：<a href="https://www.ilovematlab.cn/thread-579451-1-1.html" target="_blank" rel="noopener">https://www.ilovematlab.cn/thread-579451-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在mac上安装完matlab后，想试一试cftool的打开速度，结果一打开cftool就卡死了，然后去网上找了许多的资料，多没有想到相关的信息。&lt;/p&gt;
&lt;p&gt;最后在matlab中文论坛发现有人在用matlab仿真时死机，解决方案是&lt;strong&gt;magnet对matlab
      
    
    </summary>
    
    
    
      <category term="bugs" scheme="https://haohuaijin.github.io/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>遗传算法学习笔记</title>
    <link href="https://haohuaijin.github.io/2020/07/30/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://haohuaijin.github.io/2020/07/30/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-30T01:45:58.000Z</published>
    <updated>2020-08-01T01:14:32.125Z</updated>
    
    <content type="html"><![CDATA[<p>遗传算法是一种启发式的优化算法，具有很大的灵活性。之所以较遗传算法，这要是因为算法的过程模拟了自然选择。遗传算法的应用领域非常的广，适用于复杂的问题，同时还具有很大的灵活性，可以自主设计很多算子。</p><p>下面介绍遗传算法的主要流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">初始化种群</span><br><span class="line">计算种群的适应度和累积概率</span><br><span class="line">while iter &lt; itermax:</span><br><span class="line">复制 //剔除适应度低的，将适应度好的复制一份</span><br><span class="line">交叉 //二进制数字位数交换</span><br><span class="line">变异 //二进制位数取否</span><br><span class="line">重新计算适应度和累积概率</span><br><span class="line">end</span><br><span class="line">解码输出结果</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h2><p>编码的主要方式有<strong>二进制码，实数码和格雷码</strong>。一般用二进制来编码。在这一阶段是将一个变量或多个变量，根据其约束的定义域以及我们要得到的自变量的精度，选择合适的二进制位数将问题编码。例如变量$x$的区间是$(L,U)$，要求的精度是小数点后四位，也就意味着每个变量应该被分成至少$(L,U)\times 10^4$个部分，对一个变量的二进制数串位数用以下公式计算：<br>$$<br>2^{m_j-1} &lt; (U-L)\times 10^4 \le 2^{m_j}-1<br>$$<br>如果是多个变量的话，可以将他们各自编码后，连在一起。</p><p>解码的话使用下面的公式：<br>$$<br>x = L + \left( \sum_{i=1}^{k}b_i2^{i-1}\right)\cfrac{U-L}{2^k-1}<br>$$</p><h2 id="2-评价个体的适应度"><a href="#2-评价个体的适应度" class="headerlink" title="2. 评价个体的适应度"></a>2. 评价个体的适应度</h2><p>这里的适应度函数对应于自然选择，我们需要根据自己的实际问题来设定适应度函数，适应度函数的目的是，将种群中好的和差的区分开来。例如在求函数最大值的时候，适应度函数就是函数本身。下面是步骤：</p><ol><li>计算染色体$U_k$的适应度值</li></ol><p>$$<br>eval(U_k) = f(x^k),\quad k = 1,2,···<br>$$</p><ol start="2"><li>计算种群的适应度总和</li></ol><p>$$<br>F = \sum_{k=1}^{n}eval(U_k)<br>$$</p><ol start="3"><li>计算每个染色体被复制的概率</li></ol><p>$$<br>P_k = \cfrac{eval(U_k)}{F}<br>$$</p><ol start="4"><li>计算每个染色体被复制的累积概率</li></ol><p>$$<br>Q_k = \sum_{j-1}^kP_k<br>$$</p><h2 id="3-新种群复制"><a href="#3-新种群复制" class="headerlink" title="3. 新种群复制"></a>3. 新种群复制</h2><p>可以有好几种方法，常见的是根据前面计算的累积概率$Q_k$，利用计算机随机生成<code>0-1</code>的随机数，看看随机数落到那个区间里面，取区间右边那个累积概率对应的$k$值，复制个体。</p><p>举个例子现在有四个个体他们的累积概率是<code>0.2</code>，<code>0.3</code>，<code>0.5</code>，<code>1.0</code>。假设现在生成了个随机数为<code>0.4</code>，他现在是落在了<code>0.3-0.5</code>的区间里，所以我们将右侧的<code>0.5</code>复制一遍。</p><h2 id="4-种群的交配和变异"><a href="#4-种群的交配和变异" class="headerlink" title="4. 种群的交配和变异"></a>4. 种群的交配和变异</h2><p>和染色体的交换类似，<strong>交配</strong>就是在两个二进制数中选取一位，然后将他们后面的所有为进行交换。</p><p><strong>变异</strong>是将二进制数，其中的一位取否。</p><h2 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h2><p>将上面的过程不断的重复，直到最大的迭代次数或者种群不在进化。</p><p>在遗传算法中，我认为比较重要的几个方面是，</p><ul><li><strong>适应度函数的确定</strong>，面对实际问题时我们要设计适应度函数往往与实验相结合(假死酵母菌)。同时在遗传算法不同的阶段使用不同的适应度函数，回去的不同的效果。</li><li><strong>各种算子的设计</strong>，在我们进行遗传算法的过程中，现在已经有的算子有复制，交叉，变异等等，算子应该满足的条件是<strong>稳定，可变</strong>。我们可以根据不同的问题设计不同的算子。</li></ul><h2 id="6-应用"><a href="#6-应用" class="headerlink" title="6. 应用"></a>6. 应用</h2><ul><li>假丝酵母菌求解最优的浓度。</li><li>我的想法是将遗传算法，用来求解神经网络的参数。</li><li>各种复杂的，非线性的优化问题。</li></ul><h2 id="7-代码"><a href="#7-代码" class="headerlink" title="7. 代码"></a>7. 代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%主程序：用遗传算法求解y=200*exp(-0.05*x).*sin(x)在[-2 2]区间上的最大值</span></span><br><span class="line">clc;</span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line"><span class="keyword">global</span> BitLength</span><br><span class="line"><span class="keyword">global</span> boundsbegin</span><br><span class="line"><span class="keyword">global</span> boundsend</span><br><span class="line">bounds=[<span class="number">-2</span> <span class="number">2</span>];<span class="comment">%一维自变量的取值范围</span></span><br><span class="line">precision=<span class="number">0.0001</span>; <span class="comment">%运算精度</span></span><br><span class="line">boundsbegin=bounds(:,<span class="number">1</span>);</span><br><span class="line">boundsend=bounds(:,<span class="number">2</span>);</span><br><span class="line"><span class="comment">%计算如果满足求解精度至少需要多长的染色体</span></span><br><span class="line">BitLength=<span class="built_in">ceil</span>(<span class="built_in">log2</span>((boundsend-boundsbegin)' ./ precision));</span><br><span class="line">popsize=<span class="number">50</span>; <span class="comment">%初始种群大小</span></span><br><span class="line">Generationnmax=<span class="number">12</span>;  <span class="comment">%最大代数</span></span><br><span class="line">pcrossover=<span class="number">0.90</span>; <span class="comment">%交配概率</span></span><br><span class="line">pmutation=<span class="number">0.09</span>; <span class="comment">%变异概率</span></span><br><span class="line"><span class="comment">%产生初始种群</span></span><br><span class="line">population=<span class="built_in">round</span>(<span class="built_in">rand</span>(popsize,BitLength));</span><br><span class="line"><span class="comment">%计算适应度,返回适应度Fitvalue和累积概率cumsump</span></span><br><span class="line">[Fitvalue,cumsump]=fitnessfun(population);  </span><br><span class="line">Generation=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> Generation&lt;Generationnmax+<span class="number">1</span></span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="number">2</span>:popsize </span><br><span class="line">      <span class="comment">%选择操作</span></span><br><span class="line">      seln=selection(population,cumsump);</span><br><span class="line">      <span class="comment">%交叉操作</span></span><br><span class="line">      scro=crossover(population,seln,pcrossover);</span><br><span class="line">      scnew(<span class="built_in">j</span>,:)=scro(<span class="number">1</span>,:);</span><br><span class="line">      scnew(<span class="built_in">j</span>+<span class="number">1</span>,:)=scro(<span class="number">2</span>,:);</span><br><span class="line">      <span class="comment">%变异操作</span></span><br><span class="line">      smnew(<span class="built_in">j</span>,:)=mutation(scnew(<span class="built_in">j</span>,:),pmutation);</span><br><span class="line">      smnew(<span class="built_in">j</span>+<span class="number">1</span>,:)=mutation(scnew(<span class="built_in">j</span>+<span class="number">1</span>,:),pmutation);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   population=smnew;  <span class="comment">%产生了新的种群</span></span><br><span class="line">   <span class="comment">%计算新种群的适应度   </span></span><br><span class="line">   [Fitvalue,cumsump]=fitnessfun(population);</span><br><span class="line">   <span class="comment">%记录当前代最好的适应度和平均适应度</span></span><br><span class="line">   [fmax,nmax]=<span class="built_in">max</span>(Fitvalue);</span><br><span class="line">   fmean=<span class="built_in">mean</span>(Fitvalue);</span><br><span class="line">   ymax(Generation)=fmax;</span><br><span class="line">   ymean(Generation)=fmean;</span><br><span class="line">   <span class="comment">%记录当前代的最佳染色体个体</span></span><br><span class="line">   x=transform2to10(population(nmax,:));</span><br><span class="line">   <span class="comment">%自变量取值范围是[-2 2],需要把经过遗传运算的最佳染色体整合到[-2 2]区间</span></span><br><span class="line">   xx=boundsbegin+x*(boundsend-boundsbegin)/(power((boundsend),BitLength)<span class="number">-1</span>);</span><br><span class="line">   xmax(Generation)=xx;</span><br><span class="line">   Generation=Generation+<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Generation=Generation<span class="number">-1</span>;</span><br><span class="line">Bestpopulation=xx</span><br><span class="line">Besttargetfunvalue=targetfun(xx)</span><br><span class="line"></span><br><span class="line"><span class="comment">%绘制经过遗传运算后的适应度曲线。一般地，如果进化过程中种群的平均适应度与最大适</span></span><br><span class="line"><span class="comment">%应度在曲线上有相互趋同的形态，表示算法收敛进行得很顺利，没有出现震荡；在这种前</span></span><br><span class="line"><span class="comment">%提下，最大适应度个体连续若干代都没有发生进化表明种群已经成熟。</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">hand1=<span class="built_in">plot</span>(<span class="number">1</span>:Generation,ymax);</span><br><span class="line">set(hand1,<span class="string">'linestyle'</span>,<span class="string">'-'</span>,<span class="string">'linewidth'</span>,<span class="number">1.8</span>,<span class="string">'marker'</span>,<span class="string">'*'</span>,<span class="string">'markersize'</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">hand2=<span class="built_in">plot</span>(<span class="number">1</span>:Generation,ymean);</span><br><span class="line">set(hand2,<span class="string">'color'</span>,<span class="string">'r'</span>,<span class="string">'linestyle'</span>,<span class="string">'-'</span>,<span class="string">'linewidth'</span>,<span class="number">1.8</span>,...</span><br><span class="line"><span class="string">'marker'</span>,<span class="string">'h'</span>,<span class="string">'markersize'</span>,<span class="number">6</span>)</span><br><span class="line">xlabel(<span class="string">'进化代数'</span>);ylabel(<span class="string">'最大/平均适应度'</span>);xlim([<span class="number">1</span> Generationnmax]);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'最大适应度'</span>,<span class="string">'平均适应度'</span>);</span><br><span class="line">box off;<span class="built_in">hold</span> off;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遗传算法是一种启发式的优化算法，具有很大的灵活性。之所以较遗传算法，这要是因为算法的过程模拟了自然选择。遗传算法的应用领域非常的广，适用于复杂的问题，同时还具有很大的灵活性，可以自主设计很多算子。&lt;/p&gt;
&lt;p&gt;下面介绍遗传算法的主要流程：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;初始化种群&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;计算种群的适应度和累积概率&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while iter &amp;lt; itermax:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	复制 //剔除适应度低的，将适应度好的复制一份&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	交叉 //二进制数字位数交换&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	变异 //二进制位数取否&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	重新计算适应度和累积概率&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解码输出结果&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="数学建模" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之运输层</title>
    <link href="https://haohuaijin.github.io/2020/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>https://haohuaijin.github.io/2020/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2020-07-07T03:23:49.000Z</published>
    <updated>2020-09-06T01:28:34.294Z</updated>
    
    <content type="html"><![CDATA[<p>这里主要讲的是在运输层几个比较重要的技术，即多路分解和复用，可靠数据传输原理和拥塞原理。</p><h2 id="1-多路复用-分解"><a href="#1-多路复用-分解" class="headerlink" title="1. 多路复用/分解"></a>1. 多路复用/分解</h2><p>先给出官方定义，将主机间交付扩展到进程间交付被称为<strong>运输层的多路复用和分解</strong>。<strong>多路分解</strong>就是在运输层接收到来自网络层数据后，根据运输层报文特殊字段的信息，将运输层报文段的数据交付到正确的套接字中。<strong>多路复用</strong>就是在运输层接受到<strong>套接字</strong>数据后，根据套接字的不同，生成<strong>运输层报文特殊字段</strong>(用于分解)，然后将报文发送到网络层。通俗来说，多路复用和分解可以让<strong>不同进程的报文</strong>来使用<strong>相同的运输层协议</strong>(TCP，UDP)运输报文。</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/多路复用分解.png" width="600"></center><p>如图，运输层通过多路复用和分解，实现数据的正确交付。</p><p>下面这句话引用自计算机网络自顶向下方法，可以加深我们的理解：</p><blockquote><p>尽管我们在因特网运输层协议的环境下引入了多路复用和多路分解，认识到下列事实是重要的：</p><p>他们与在某层(在运输层或别处)的单一协议何时被位于接下来的较高层的多个协议使用有关。</p></blockquote><h5 id="那么如何实现多路复用和分解呢？"><a href="#那么如何实现多路复用和分解呢？" class="headerlink" title="那么如何实现多路复用和分解呢？"></a>那么如何实现多路复用和分解呢？</h5><a id="more"></a><p>需要两个条件：</p><ol><li>每个套接字有唯一的<strong>标识符</strong>(也就是<strong>端口号</strong>)</li><li>也就是前面讲的，运输层报文的特殊字段(<strong>包含源端口号和目的端口号</strong>)</li></ol><p>根据运输层协议的不同，UDP和TCP的报文中的特殊字段不同。</p><p><strong>补充：</strong></p><ol><li><strong>套接字接口</strong>的作用，把来自进程的数据传输到运输层，并且把来自运输层的数据传送的特定的进程。</li><li>每一个套接字分配一个<strong>端口号</strong>用来作为套接字的标识符。</li><li>运输层报文的格式基本如下所示：</li></ol><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/运输层报文格式.png" width="350"></center><p>下面具体讲一下UDP和TCP的多路复用和分解。</p><h3 id="1-1-UDP的多路复用-分解"><a href="#1-1-UDP的多路复用-分解" class="headerlink" title="1.1 UDP的多路复用/分解"></a>1.1 UDP的多路复用/分解</h3><p>在UDP中一个套接字是由一个二元组全面标识的，二元组中包含了一个<strong>目的IP地址和目的端口号</strong>。</p><p>举个例子：假设现在有A，B，C三个主机，A和B同时通过2333端口号与C主机的3333端口号通信，这是A和B的目的端口号都是3333，所以他们<strong>通过相同的套接字进入相同的进程</strong>。这里的源端口号是用来从C向A，B发送报文时使用的。</p><h3 id="1-2-TCP的多路复用-分解"><a href="#1-2-TCP的多路复用-分解" class="headerlink" title="1.2 TCP的多路复用/分解"></a>1.2 TCP的多路复用/分解</h3><p>TCP中的一个套接字是有四元组标识的，即<strong>目的IP地址，目的端口号，源IP地址和源端口号</strong>。</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/TCP多路复用.png" width="700"></center><p>如图很好展示了TCP如何来识别套接字。</p><h2 id="2-可靠数据传输原理"><a href="#2-可靠数据传输原理" class="headerlink" title="2. 可靠数据传输原理"></a>2. 可靠数据传输原理</h2><p>首先要明确，我们真实的网络环境会发生<strong>比特差错</strong>和<strong>丢包的</strong>。</p><p>可靠数据传输主要包含以下几个技术，差错检验，肯定确认(ACK)，序号，定时器，回退N步，累计确认，选择确认等等。</p><p><strong>注意：</strong> 我这里讲的是，可靠数据传输用到的一些技术方法，并没有具体TCP或UDP报文。</p><p>下面分别介绍上面的技术:</p><h3 id="2-1-差错检验"><a href="#2-1-差错检验" class="headerlink" title="2.1 差错检验"></a>2.1 差错检验</h3><p>差错检验用来检测报文在传输的过程中有没有发生错误，具体的方法还没学到。</p><h3 id="2-2-肯定确认ACK-positive-Acknowledgment-和否定确认-NAK"><a href="#2-2-肯定确认ACK-positive-Acknowledgment-和否定确认-NAK" class="headerlink" title="2.2 肯定确认ACK(positive Acknowledgment)和否定确认(NAK)"></a>2.2 肯定确认ACK(positive Acknowledgment)和否定确认(NAK)</h3><p>简单地说，就是接受端每当收到一个<strong>正确报文</strong>，就发送一个<strong>ACK</strong>来告诉发送端他收到了。而如果报文在运输的过程中出现了错误(比如差错检验没通过)，这时接收端就会<strong>丢弃刚刚收到的报文</strong>，并且发送一个<strong>NAK</strong>来告诉发送端重新发送上一个报文。</p><p><strong>注意:</strong>  由于我们真实的网络环境是会发生<strong>比特差错的</strong>，所以ACK和NAK也会发生错误。举个例子，现在 接收端正确收到了报文A，并且发送了一个ACK，不过由于传输中发生了错误，<strong>ACK变成了NAK</strong>。这时接受端收到了错误的ACK，由于不确定，发送端会重新发送上一个报文，但是这时接受端<strong>已经正确接受到了报文</strong>，所以接受端再次接受的正确的报文A时，接受端就发生了冗余(他自己没办法判断是不是冗余)。解决这个问题这个问题的方法就是接下来要讲的序号。</p><h3 id="2-3-序号"><a href="#2-3-序号" class="headerlink" title="2.3 序号"></a>2.3 序号</h3><p>序号就是给每一个发送报文附上一个<strong>递增的序号</strong>，同时返回的ACK上也包含这个序号，表示此序号的确认。通过序号就可以完美的解决2.2出现的问题，<strong>根据序号的不同</strong>接受端就可以准确的判断报文是不是相同。</p><p>在TCP中，初始序号是由计算随机计生成，而返回的ACK的序号是<strong>报文的编号</strong>加上<strong>报文数据部分的字节数</strong>。分送端第二次发送的报文的编号，则是由上一次的ACK指定。</p><p>其实，我们现在可以只用ACK来确认，在接受端收到<strong>受损报文</strong>后，发送上一个报文ACK，当接收端再一次收到ACK时(<strong>冗余ACK，对一个报文的ACK接收端到多次ACK</strong>)，他就知到报文受损了，所以他重新发送报文。下面只使用ACK。</p><h3 id="2-4-定时器"><a href="#2-4-定时器" class="headerlink" title="2.4 定时器"></a>2.4 定时器</h3><p>定时器的设定是因为在真实的网络环境中，会出现<strong>丢包</strong>的情况。</p><p>举个例子，假设现在发送端向接受端发送了一个报文A，考虑一下两种情况：</p><ol><li>报文A，在发送的途中丢失了</li><li>接受端收到了报文了，但是返回的ACK丢失了</li></ol><p>以上的情况都会导致发送端收不到ACK，于是我们可以设定一个<strong>定时器</strong>和一个<strong>超时间隔</strong>，当发送方在指定的超时间隔内没有收到ACK后，发送端就<strong>重新发送报文A</strong>。</p><h3 id="2-5-流水线技术"><a href="#2-5-流水线技术" class="headerlink" title="2.5 流水线技术"></a>2.5 流水线技术</h3><p>到现在为止，我们讨论的运输都是发送一个数据，返回一个ACK，然后在发送一个数据，这样的方式叫做<strong>停等协议</strong>。但是如果数据运输的时间比较长的话，停等协议的信道利用率是非常低的。所以引入了<strong>流水线协议</strong>，即一次可以发送多个报文。如图a是停等协议，图b是流水线协议。</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/流水线1.png" width="350"></center><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/流水线2.png" width="350"></center><p>使用流水线协议会带来以下的影响(参考Top-Down，这里的逻辑我没怎么理清)：</p><ol><li><strong>必须增加序号的范围</strong>，因为每个输送中的的分组(不计算重传的)必须有一个唯一的序号，而且有多个在输送中的未确认报文。</li><li><strong>协议的发送方和接收方两端也许不得不缓存多个分组</strong>。发送方最低限应当能缓冲哪些已发送但未确认的分组，如下面们讨论的那样，接收方或许也需要缓存那些以正确接受的分组。</li><li>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失，损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是：<strong>回退N步</strong>(Go-Back-N，GBN)和<strong>选择重传</strong>(Selective Repeat，SR)。</li></ol><h3 id="2-6-回退N步"><a href="#2-6-回退N步" class="headerlink" title="2.6 回退N步"></a>2.6 回退N步</h3><p>流水线技术，可以使我们不用等待<strong>上一个发送报文ACK</strong>，就可以发送新的报文。但是我们不能无限制的发送新报文，所以规定了一个数字N(也叫窗口长度，把N个报文称为<strong>窗口</strong>)，作为最大的<strong>已发送还未确认报文</strong>的数目。如图</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/回退N步.png" width="800"></center><p><strong>发送端的功能：</strong></p><ol><li>接受上层的调用</li><li>发送数据时，<strong>已发送还未确认的报文</strong>最多不超过N。只有当现在的报文被确认后才能发送新的报文(在图上的表现就是，把窗口右移)。</li><li><strong>超时后</strong>，把现在窗口中所有的报文所有的<strong>已经发送还未确认的报文</strong>重新发送一遍。</li></ol><p><strong>接收端的功能：</strong></p><ol><li>接收到的报文序号正确时，发送一个ACK。</li><li>接收到的报文序号不正确时，不发送ACK。</li><li>采取<strong>累计确认</strong>的方法，即ACK是对他以及他之前所有报文的确认。</li></ol><p>如图下面的窗口的大小为4，当出现超时后，发送端重新发送所有的报文。</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/回退N步演示.png" width="500"></center><h3 id="2-7-选择重传"><a href="#2-7-选择重传" class="headerlink" title="2.7 选择重传"></a>2.7 选择重传</h3><p>GBN可以提高信道的利用率，但是它也会到来一些问题。当窗口的长度N比较大的时候，前面报文的丢失会导致后面所有报文的重传，这样显然效率不高。于是有了选择重传。</p><p>选择重传就是接受端将那些失序到达的报文，接受并且发送一个ACK。所以他采取的不是累计确认，而是一个ACK确认一个报文。在发送端只有接收到每一个发送报文的ACK，才确切的知道报文已经发送。下面描述发送端，和接收端的功能。</p><p><strong>发送端：</strong></p><ol><li>接受上层的调用</li><li>发送端维护一个大小N的窗口(<strong>从第一个发送未确认报文开始，大小为N</strong>)，第一个报文接受的ACK是窗口右移。</li><li>超时时，发送端重新发送窗口N中，那些<strong>发送但未确认的报文</strong>。</li></ol><p><strong>接收端：</strong></p><ol><li>只要有报文到达，就发送ACK。</li></ol><p>如图展示了选择重传协议的作用：</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/选择重传.png" width="600"></center><h2 id="3-拥塞控制原理"><a href="#3-拥塞控制原理" class="headerlink" title="3. 拥塞控制原理"></a>3. 拥塞控制原理</h2><p>拥塞控制主要有两种方法：</p><ol><li><strong>端到端的拥塞控制</strong>，在运输层实现，TCP的拥塞控制。</li><li><strong>网络辅助的拥塞控制</strong>，路由器向发送方提供关于网络的拥塞情况。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里主要讲的是在运输层几个比较重要的技术，即多路分解和复用，可靠数据传输原理和拥塞原理。&lt;/p&gt;
&lt;h2 id=&quot;1-多路复用-分解&quot;&gt;&lt;a href=&quot;#1-多路复用-分解&quot; class=&quot;headerlink&quot; title=&quot;1. 多路复用/分解&quot;&gt;&lt;/a&gt;1. 多路复用/分解&lt;/h2&gt;&lt;p&gt;先给出官方定义，将主机间交付扩展到进程间交付被称为&lt;strong&gt;运输层的多路复用和分解&lt;/strong&gt;。&lt;strong&gt;多路分解&lt;/strong&gt;就是在运输层接收到来自网络层数据后，根据运输层报文特殊字段的信息，将运输层报文段的数据交付到正确的套接字中。&lt;strong&gt;多路复用&lt;/strong&gt;就是在运输层接受到&lt;strong&gt;套接字&lt;/strong&gt;数据后，根据套接字的不同，生成&lt;strong&gt;运输层报文特殊字段&lt;/strong&gt;(用于分解)，然后将报文发送到网络层。通俗来说，多路复用和分解可以让&lt;strong&gt;不同进程的报文&lt;/strong&gt;来使用&lt;strong&gt;相同的运输层协议&lt;/strong&gt;(TCP，UDP)运输报文。&lt;/p&gt;
&lt;center class=&quot;third&quot;&gt;
    &lt;img src=&quot;https://gitee.com/Hao-132/blogimage/raw/master/img/多路复用分解.png&quot; width=&quot;600&quot;&gt;
&lt;/center&gt;

&lt;p&gt;如图，运输层通过多路复用和分解，实现数据的正确交付。&lt;/p&gt;
&lt;p&gt;下面这句话引用自计算机网络自顶向下方法，可以加深我们的理解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;尽管我们在因特网运输层协议的环境下引入了多路复用和多路分解，认识到下列事实是重要的：&lt;/p&gt;
&lt;p&gt;他们与在某层(在运输层或别处)的单一协议何时被位于接下来的较高层的多个协议使用有关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;那么如何实现多路复用和分解呢？&quot;&gt;&lt;a href=&quot;#那么如何实现多路复用和分解呢？&quot; class=&quot;headerlink&quot; title=&quot;那么如何实现多路复用和分解呢？&quot;&gt;&lt;/a&gt;那么如何实现多路复用和分解呢？&lt;/h5&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="https://haohuaijin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>7-11 Saving James Bond - Hard Version (30 分)</title>
    <link href="https://haohuaijin.github.io/2019/11/05/7-11%20Saving%20James%20Bond%20-%20Hard%20Version%20(30%20%E5%88%86)/"/>
    <id>https://haohuaijin.github.io/2019/11/05/7-11%20Saving%20James%20Bond%20-%20Hard%20Version%20(30%20%E5%88%86)/</id>
    <published>2019-11-05T09:40:31.000Z</published>
    <updated>2019-11-05T09:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>原题链接：<a href="https://pintia.cn/problem-sets/16/problems/673" target="_blank" rel="noopener">https://pintia.cn/problem-sets/16/problems/673</a><br>这道题本质是就是一道BFS，只不过要加上路径。<br>&emsp;开始做的时候比较顺利，但是总是有一个测试点没过去，找了半天还是找不到错误。于是google一下，发现是没仔细看题。<br>&emsp;题目中说，当有<strong>多条最短路径时，选择第一跳最短的</strong>。我竟然么看见(😭😭找了两个多小时)。处理第一条最短，比较简单的做法时我们在用BFS，一开始把鳄鱼入队时，就把顺序排好，这样出来的一定是最终的结果。</p><h6 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h6><p>在处理能不能在两个鳄鱼之间跳时，一是可以先计算好能不能跳，然后直接在BFS里用结果。二是在BFS的过程中，判断能不能跳。<br>其实我个人比较推荐第二种，没必要先计算好，现算现用就行。不过如果计算的结构要多次使用的话，保存下来了比较好。</p><a id="more"></a><h6 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INFO = <span class="number">1000000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> X,Y;</span><br><span class="line">    Node() &#123;&#125; <span class="comment">//用来不初始化定义Ver[101]</span></span><br><span class="line">    Node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y) : X(_x),Y(_y) &#123;&#125; <span class="comment">//用来提供X和Y的初始值</span></span><br><span class="line">&#125;Ver[MAX];</span><br><span class="line"><span class="keyword">int</span> Path[MAX]; <span class="comment">//记录路径</span></span><br><span class="line"><span class="keyword">int</span> N,D;</span><br><span class="line"><span class="keyword">bool</span> book[MAX]; <span class="comment">//记录是否访问</span></span><br><span class="line"><span class="keyword">int</span> last = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsVertexJump</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123; <span class="comment">//能不能从a到b</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">pow</span>(Ver[a].X-Ver[b].X,<span class="number">2</span>) + <span class="built_in">pow</span>(Ver[a].Y-Ver[b].Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsSave</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; <span class="comment">//a能不能到岸</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">pow</span>(Ver[a].X,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D,<span class="number">2</span>) || <span class="built_in">pow</span>(Ver[a].Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D,<span class="number">2</span>) || \</span><br><span class="line">        <span class="built_in">pow</span>(<span class="number">100</span>-Ver[a].X,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D,<span class="number">2</span>) || <span class="built_in">pow</span>(<span class="number">100</span>-Ver[a].Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsCenterJump</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; <span class="comment">//能不能从中心跳出</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pow</span>(Ver[a].X<span class="number">-50</span>,<span class="number">2</span>) + <span class="built_in">pow</span>(Ver[a].Y<span class="number">-50</span>,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D + <span class="number">7.5</span>,<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">pow</span>(Ver[a].X<span class="number">-50</span>,<span class="number">2</span>) + <span class="built_in">pow</span>(Ver[a].Y<span class="number">-50</span>,<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//排序的比较函数</span></span><br><span class="line">    <span class="keyword">return</span> IsCenterJump(x)&lt;IsCenterJump(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Save007</span><span class="params">()</span></span>&#123; <span class="comment">//无权图单源最短路</span></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> b[MAX]; <span class="comment">//用来把第一跳排序</span></span><br><span class="line">    <span class="built_in">fill</span>(Path, Path+N+<span class="number">1</span>, INFO);</span><br><span class="line">    <span class="built_in">fill</span>(book, book+N+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    Path[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    book[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(IsSave(<span class="number">0</span>))&#123;</span><br><span class="line">        last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123; <span class="comment">//对第一跳排序</span></span><br><span class="line">        b[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b+<span class="number">1</span>,b+N+<span class="number">1</span>,cmp); <span class="comment">//why 第二个是N + 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123; <span class="comment">//按靠近center的顺序，放入queue</span></span><br><span class="line">        <span class="keyword">if</span>(IsCenterJump(b[i]))&#123;</span><br><span class="line">            q.push(b[i]);</span><br><span class="line">            Path[b[i]] = <span class="number">0</span>;</span><br><span class="line">            book[b[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        temp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(IsSave(temp))&#123; <span class="comment">//能不能到岸</span></span><br><span class="line">            last = temp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!book[i] &amp;&amp; IsVertexJump(temp,i))&#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">                Path[i] = temp;</span><br><span class="line">                book[i] = <span class="literal">true</span>; <span class="comment">//在入队时就book</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> a[MAX]; <span class="comment">//记录最短路径</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Ver[<span class="number">0</span>] = Node(<span class="number">50</span>,<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;D);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        Ver[i] = Node(x+<span class="number">50</span>,y+<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Save007();</span><br><span class="line">    <span class="keyword">if</span>(last == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);<span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(last &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            a[count++] = last;</span><br><span class="line">            last = Path[last];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,count+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=count<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,Ver[a[i]].X<span class="number">-50</span>,Ver[a[i]].Y<span class="number">-50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原题链接：&lt;a href=&quot;https://pintia.cn/problem-sets/16/problems/673&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pintia.cn/problem-sets/16/problems/673&lt;/a&gt;&lt;br&gt;这道题本质是就是一道BFS，只不过要加上路径。&lt;br&gt;&amp;emsp;开始做的时候比较顺利，但是总是有一个测试点没过去，找了半天还是找不到错误。于是google一下，发现是没仔细看题。&lt;br&gt;&amp;emsp;题目中说，当有&lt;strong&gt;多条最短路径时，选择第一跳最短的&lt;/strong&gt;。我竟然么看见(😭😭找了两个多小时)。处理第一条最短，比较简单的做法时我们在用BFS，一开始把鳄鱼入队时，就把顺序排好，这样出来的一定是最终的结果。&lt;/p&gt;
&lt;h6 id=&quot;思路：&quot;&gt;&lt;a href=&quot;#思路：&quot; class=&quot;headerlink&quot; title=&quot;思路：&quot;&gt;&lt;/a&gt;思路：&lt;/h6&gt;&lt;p&gt;在处理能不能在两个鳄鱼之间跳时，一是可以先计算好能不能跳，然后直接在BFS里用结果。二是在BFS的过程中，判断能不能跳。&lt;br&gt;其实我个人比较推荐第二种，没必要先计算好，现算现用就行。不过如果计算的结构要多次使用的话，保存下来了比较好。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="BFS" scheme="https://haohuaijin.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>7-10 Saving James Bond - Easy Version (25分)</title>
    <link href="https://haohuaijin.github.io/2019/11/02/7-10-Saving%20James-Bond-Easy-Version-25%E5%88%86/"/>
    <id>https://haohuaijin.github.io/2019/11/02/7-10-Saving%20James-Bond-Easy-Version-25%E5%88%86/</id>
    <published>2019-11-02T07:59:34.000Z</published>
    <updated>2019-11-02T08:01:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个题主要是审好题目，做起来就简单了。<br>下面有两种方法：</p><h3 id="一、先将是不是有边，是否与岸有连接算出来"><a href="#一、先将是不是有边，是否与岸有连接算出来" class="headerlink" title="一、先将是不是有边，是否与岸有连接算出来"></a>一、先将是不是有边，是否与岸有连接算出来</h3><p><strong>步骤：</strong><br>1、读入数据，计算输入点是不是可以到岸。<br>2、对权值初始化，计算各点之间是不是有线。<br>3、一次DFS搜索，看看是不是能从中心到岸边。</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">101</span>]; <span class="comment">//是否访问</span></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Flee[<span class="number">101</span>]; <span class="comment">//是否可以逃跑</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INFO = <span class="number">100000</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> G[][<span class="number">101</span>],<span class="keyword">int</span> Nv)</span></span>&#123;</span><br><span class="line">    book[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(Flee[i] == <span class="number">1</span>) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= Nv;j++)&#123; <span class="comment">//注意一共Nv+1个点</span></span><br><span class="line">        <span class="keyword">if</span>(!book[j] &amp;&amp; G[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">            DFS(j,G,Nv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> Nv; <span class="comment">//顶点数</span></span><br><span class="line">    <span class="keyword">int</span> X[<span class="number">101</span>],Y[<span class="number">101</span>]; <span class="comment">//顶点坐标</span></span><br><span class="line">    <span class="keyword">int</span> Dist; <span class="comment">//跳的最远距离</span></span><br><span class="line">    <span class="keyword">int</span> G[<span class="number">101</span>][<span class="number">101</span>]; <span class="comment">//是否有边</span></span><br><span class="line">    X[<span class="number">0</span>] = Y[<span class="number">0</span>] = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;Nv,&amp;Dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= Nv;i++)&#123; <span class="comment">//读入X，Y并计算能不能从哪里逃出</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        X[i] = x + <span class="number">50</span>;</span><br><span class="line">        Y[i] = y + <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pow</span>(Y[i],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>) || <span class="built_in">pow</span>(X[i],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>)||\</span><br><span class="line">            <span class="built_in">pow</span>(<span class="number">100</span>-Y[i],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>) || <span class="built_in">pow</span>(<span class="number">100</span>-X[i],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>))</span><br><span class="line">            Flee[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= Nv;i++)&#123; <span class="comment">//初始化权值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= Nv;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) G[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> G[i][j] = INFO;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pow</span>(X[i]-X[j],<span class="number">2</span>) + <span class="built_in">pow</span>(Y[i]-Y[j],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>))&#123;</span><br><span class="line">                G[i][j] = <span class="number">1</span>;</span><br><span class="line">                G[j][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= Nv;j++)&#123; <span class="comment">//中间有一个直径15的陆地</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pow</span>(X[<span class="number">0</span>]-X[j],<span class="number">2</span>) + <span class="built_in">pow</span>(Y[<span class="number">0</span>]-Y[j],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist+<span class="number">7.5</span>,<span class="number">2</span>))&#123;</span><br><span class="line">            G[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            G[j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(<span class="number">0</span>,G,Nv);</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、在线处理，是不是有边，是否到岸"><a href="#二、在线处理，是不是有边，是否到岸" class="headerlink" title="二、在线处理，是不是有边，是否到岸"></a>二、在线处理，是不是有边，是否到岸</h3><p><strong>思路：</strong><br>主要的思路就是用<strong>DFS</strong>，由于在湖中心时有一个平台，所以要进行特殊处理。<br>对于图的结构的选择，可以用也可以不用。图只是一个抽象的结构来帮助我们解题，怎么简单怎么写，不用拘泥于使用什么结构(比如邻接表，邻接矩阵，或者不用图的结构)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> X,Y;</span><br><span class="line">    <span class="keyword">bool</span> book;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsSave</span><span class="params">(Graph V,<span class="keyword">int</span> Dist)</span></span>&#123; <span class="comment">//能否到岸</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">pow</span>(V.X,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>) || <span class="built_in">pow</span>(V.Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>) || \</span><br><span class="line">        <span class="built_in">pow</span>(<span class="number">100</span>-V.X,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>) || <span class="built_in">pow</span>(<span class="number">100</span>-V.Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsCanJump</span><span class="params">(Graph V1,Graph V2,<span class="keyword">int</span> Dist)</span></span>&#123; <span class="comment">//能否从V1跳到V2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(V1.X-V2.X,<span class="number">2</span>) + <span class="built_in">pow</span>(V1.Y-V2.Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> Nv,<span class="keyword">int</span> Dist,Graph G[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> answer = <span class="literal">false</span>;</span><br><span class="line">    G[index].book = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(IsSave(G[index],Dist))&#123;</span><br><span class="line">        answer = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= Nv; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!G[i].book &amp;&amp; IsCanJump(G[index],G[i],Dist))&#123;</span><br><span class="line">                answer = DFS(i,Nv,Dist,G);</span><br><span class="line">                <span class="keyword">if</span>(answer == <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsCenterJump</span><span class="params">(Graph V,<span class="keyword">int</span> Dist)</span></span>&#123; <span class="comment">//计算从中心跳出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(V.X<span class="number">-50</span>,<span class="number">2</span>) + <span class="built_in">pow</span>(V.Y<span class="number">-50</span>,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist + <span class="number">7.5</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Save007</span><span class="params">(<span class="keyword">int</span> Nv,<span class="keyword">int</span> Dist,Graph G[])</span></span>&#123; <span class="comment">// 对起点特殊处理</span></span><br><span class="line">    <span class="keyword">bool</span> answer = <span class="literal">false</span>;</span><br><span class="line">    G[<span class="number">0</span>].book = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Nv; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!G[i].book &amp;&amp; IsCenterJump(G[i],Dist))&#123;</span><br><span class="line">            answer = DFS(i,Nv,Dist,G);</span><br><span class="line">            <span class="keyword">if</span>(answer == <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Nv,Dist,x,y;</span><br><span class="line">    <span class="keyword">int</span> answer;</span><br><span class="line">    Graph G[<span class="number">101</span>]; <span class="comment">//发生了一次运行时错误,指针越界</span></span><br><span class="line">    G[<span class="number">0</span>].X = G[<span class="number">0</span>].Y = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;Nv,&amp;Dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Nv; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        G[i].X = x + <span class="number">50</span>;</span><br><span class="line">        G[i].Y = y + <span class="number">50</span>;</span><br><span class="line">        G[i].book = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    answer = Save007(Nv,Dist,G);</span><br><span class="line">    <span class="keyword">if</span>(answer) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个题主要是审好题目，做起来就简单了。&lt;br&gt;下面有两种方法：&lt;/p&gt;
&lt;h3 id=&quot;一、先将是不是有边，是否与岸有连接算出来&quot;&gt;&lt;a href=&quot;#一、先将是不是有边，是否与岸有连接算出来&quot; class=&quot;headerlink&quot; title=&quot;一、先将是不是有边，是否与岸有连接算出来&quot;&gt;&lt;/a&gt;一、先将是不是有边，是否与岸有连接算出来&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;br&gt;1、读入数据，计算输入点是不是可以到岸。&lt;br&gt;2、对权值初始化，计算各点之间是不是有线。&lt;br&gt;3、一次DFS搜索，看看是不是能从中心到岸边。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DFS" scheme="https://haohuaijin.github.io/tags/DFS/"/>
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>7-6 列出连通集 (25分)</title>
    <link href="https://haohuaijin.github.io/2019/10/26/7-6-%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86-25%E5%88%86/"/>
    <id>https://haohuaijin.github.io/2019/10/26/7-6-%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86-25%E5%88%86/</id>
    <published>2019-10-26T12:04:11.000Z</published>
    <updated>2019-10-26T12:05:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要考察了DFS，和BFS的基本操作。考察我们对图的构建，以及运用DFS和BFS对图进行遍历。<br>DFS是运用了递归的思想，<br>而BFS则可以通过队列来实现。<br>我在做题时遇到的困难，主要是在<strong>BFS的思路</strong>和<strong>队列</strong>的实现上。因为队列原来以为很熟，但现在一写很多细节都忘了。<br><strong>所以数据结构要经常写，要不然忘得很快。</strong><br>下面是代码，可能有点冗杂。</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">Graph</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;</span><br><span class="line">    <span class="keyword">int</span> Ne;</span><br><span class="line">    <span class="keyword">int</span> Vertex[<span class="number">11</span>];</span><br><span class="line">    <span class="keyword">int</span> Edge[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">QNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    QNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QNode rear,front;</span><br><span class="line">&#125;*Queue;</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">11</span>]; <span class="comment">//纪录访问的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v1,v2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;G-&gt;Nv,&amp;G-&gt;Ne);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Nv;i++) G-&gt;Vertex[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Nv;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G-&gt;Nv;j++)</span><br><span class="line">            G-&gt;Edge[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Ne;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;v1,&amp;v2);</span><br><span class="line">        G-&gt;Edge[v1][v2] = <span class="number">1</span>;</span><br><span class="line">        G-&gt;Edge[v2][v1] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QNode <span class="title">CreateQNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QNode q = (QNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    q-&gt;Data = <span class="number">-1</span>;</span><br><span class="line">    q-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Queue <span class="title">CreateQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Queue q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    q-&gt;rear = q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(Queue Q,<span class="keyword">int</span> X)</span></span>&#123;</span><br><span class="line">    QNode q = CreateQNode();</span><br><span class="line">    q-&gt;Data = X;</span><br><span class="line">    q-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front == <span class="literal">NULL</span>)</span><br><span class="line">        Q-&gt;rear = Q-&gt;front = q;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q-&gt;rear-&gt;Next = q; <span class="comment">//使q成为最后一个元素</span></span><br><span class="line">        Q-&gt;rear = q; <span class="comment">//更新rear</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteQ</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear == Q-&gt;front)&#123; <span class="comment">//分类讨论</span></span><br><span class="line">        x = Q-&gt;front-&gt;Data;</span><br><span class="line">        Q-&gt;rear = Q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        QNode q = Q-&gt;front;</span><br><span class="line">        x = q-&gt;Data;</span><br><span class="line">        Q-&gt;front = q-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(book[i] == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        book[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G-&gt;Nv;j++)</span><br><span class="line">            <span class="keyword">if</span>(G-&gt;Edge[i][j] == <span class="number">1</span>) <span class="comment">//加不加book[j] == 0</span></span><br><span class="line">                DFS(G,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Queue Q,Graph G,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X;</span><br><span class="line">    AddQ(Q,i);</span><br><span class="line">    book[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(Q-&gt;front != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        X = DeleteQ(Q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>,X);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G-&gt;Nv;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(book[j] == <span class="number">0</span> &amp;&amp; G-&gt;Edge[j][X] == <span class="number">1</span>)&#123;</span><br><span class="line">                AddQ(Q,j);</span><br><span class="line">                book[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Graph G;</span><br><span class="line">    G = (Graph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GNode));</span><br><span class="line">    CreateGraph(G);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Nv;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(book[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&#123;"</span>);</span><br><span class="line">            DFS(G,i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" &#125;\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Nv;i++) book[i] = <span class="number">0</span>;</span><br><span class="line">    Queue Q = CreateQueue();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Nv;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(book[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&#123;"</span>);</span><br><span class="line">            BFS(Q,G,i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" &#125;\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要考察了DFS，和BFS的基本操作。考察我们对图的构建，以及运用DFS和BFS对图进行遍历。&lt;br&gt;DFS是运用了递归的思想，&lt;br&gt;而BFS则可以通过队列来实现。&lt;br&gt;我在做题时遇到的困难，主要是在&lt;strong&gt;BFS的思路&lt;/strong&gt;和&lt;strong&gt;队列&lt;/strong&gt;的实现上。因为队列原来以为很熟，但现在一写很多细节都忘了。&lt;br&gt;&lt;strong&gt;所以数据结构要经常写，要不然忘得很快。&lt;/strong&gt;&lt;br&gt;下面是代码，可能有点冗杂。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DFS" scheme="https://haohuaijin.github.io/tags/DFS/"/>
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="BFS" scheme="https://haohuaijin.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>7-2 Reversing Linked List (25分)</title>
    <link href="https://haohuaijin.github.io/2019/10/13/7-2-Reversing-Linked-List-25%E5%88%86/"/>
    <id>https://haohuaijin.github.io/2019/10/13/7-2-Reversing-Linked-List-25%E5%88%86/</id>
    <published>2019-10-13T01:40:46.000Z</published>
    <updated>2019-10-13T01:45:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题可能一开始看题目一头雾水，但是仔细思考就会发现并不太难。<br>下面是我的思路：<br><strong>1、</strong>用类似静态链表的方法，来表示List，即一个数组存Data，一个数组存Next<br><strong>2、</strong>循环遍历链表，用<code>a[]</code>记录下标。<br><strong>3、</strong>根据K来转置链表，修改Next，然后转置<code>a[]</code>(<strong>顺序很重要</strong>)。</p><a id="more"></a><p><strong>AC代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> <span class="comment">//类此静态链表</span></span><br><span class="line">    <span class="keyword">int</span> Address,Next,Data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reavers</span><span class="params">(<span class="keyword">int</span> *front,<span class="keyword">int</span> *rear,<span class="keyword">int</span> k)</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,a[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> *p = front;p != rear+<span class="number">1</span>;p++)&#123; <span class="comment">//先储存</span></span><br><span class="line">        a[i++] = *p;</span><br><span class="line">    &#125; </span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> *p = rear;p != front<span class="number">-1</span>;p--)&#123; </span><br><span class="line">        *p = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first,total,k,count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">    List *p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;first,&amp;total,&amp;k);</span><br><span class="line">    p = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node)*total);</span><br><span class="line">    a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*total); <span class="comment">//存索引</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;p[i].Address,&amp;p[i].Data,&amp;p[i].Next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">//将List恢复正常序列,用a[]记录索引。 复杂度n^2 应优化这里(结果去掉break)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first == p[i].Address)&#123;</span><br><span class="line">                a[count++] = i;</span><br><span class="line">                first = p[i].Next;</span><br><span class="line"><span class="comment">//                break; //原来找到1个就break,改进后一直往下找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(first == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用count代表有多少结点在链表上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(count/k);i++)&#123; <span class="comment">//逆转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            p[a[j+i*k]].Next = p[a[j+i*k<span class="number">-1</span>]].Address;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>) p[a[i*k<span class="number">-1</span>]].Next = p[a[k+i*k<span class="number">-1</span>]].Address; <span class="comment">//修改逆转序列的前一个元素的Next</span></span><br><span class="line">        <span class="comment">//注意前后的连接</span></span><br><span class="line">        <span class="keyword">if</span>(i == count/k - <span class="number">1</span> &amp;&amp; (count%k == <span class="number">0</span>)) p[a[i*k]].Next = <span class="number">-1</span>; <span class="comment">//修改逆转序列的最后元素的Next</span></span><br><span class="line">        <span class="keyword">else</span> p[a[i*k]].Next = p[a[i*k+k]].Address;</span><br><span class="line">        Reavers((a+k*i),(a+k*(i+<span class="number">1</span>)<span class="number">-1</span>),k); <span class="comment">//逆转索引a[]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == count - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%05d %d %d\n"</span>,p[a[i]].Address,p[a[i]].Data,p[a[i]].Next);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>,p[a[i]].Address,p[a[i]].Data,p[a[i]].Next);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题可能一开始看题目一头雾水，但是仔细思考就会发现并不太难。&lt;br&gt;下面是我的思路：&lt;br&gt;&lt;strong&gt;1、&lt;/strong&gt;用类似静态链表的方法，来表示List，即一个数组存Data，一个数组存Next&lt;br&gt;&lt;strong&gt;2、&lt;/strong&gt;循环遍历链表，用&lt;code&gt;a[]&lt;/code&gt;记录下标。&lt;br&gt;&lt;strong&gt;3、&lt;/strong&gt;根据K来转置链表，修改Next，然后转置&lt;code&gt;a[]&lt;/code&gt;(&lt;strong&gt;顺序很重要&lt;/strong&gt;)。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="https://haohuaijin.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>7-3 Pop Sequence (25分)</title>
    <link href="https://haohuaijin.github.io/2019/10/11/7-3-Pop-Sequence-25%E5%88%86/"/>
    <id>https://haohuaijin.github.io/2019/10/11/7-3-Pop-Sequence-25%E5%88%86/</id>
    <published>2019-10-11T08:28:44.000Z</published>
    <updated>2019-10-11T08:30:36.000Z</updated>
    
    <content type="html"><![CDATA[<p> <strong>1、</strong>刚开始受严蔚敏数据结构的启发，想用比较大小的方法来判断是不是出栈序列。但是发现最后一个测试点就是卡这个算法。<br> <strong>2、</strong>然后看了柳神的博客，自己根据理解重新写了算法，但是第二个测试点还是过不去，下面是我的想法。<br> 步骤：循环判断数组中的每一个数，初始化temp=1 ，用temp来判断当前数组的最大值。如果数组当前值<strong>小于temp</strong>，就出栈，若<strong>大于等于temp就入栈</strong>，直到temp等于最大值。如果超过栈的容量标记flag=0并且break。最后根据flag判断YES或NO。<br> <strong>3、</strong>但是上面的步骤不能通过第二个测试点。<br>于是参考了柳神的程序，得到了下面的程序：</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> <span class="comment">//栈的定义</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    Stack *Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Stack *<span class="title">CreateNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack *p;</span><br><span class="line">    p = (Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line">    p-&gt;Data = <span class="number">0</span>;</span><br><span class="line">    p-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack *p,<span class="keyword">int</span> item)</span></span>&#123;</span><br><span class="line">    Stack *ptr = CreateNode();</span><br><span class="line">    ptr-&gt;Data = item;</span><br><span class="line">    ptr-&gt;Next = p-&gt;Next;</span><br><span class="line">    p-&gt;Next = ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;Next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(Stack *p)</span></span>&#123;</span><br><span class="line">    Stack *ptr = p-&gt;Next;</span><br><span class="line">    <span class="keyword">int</span> temp = ptr-&gt;Data;</span><br><span class="line">    p-&gt;Next = ptr-&gt;Next;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">(Stack *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;Next-&gt;Data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> **<span class="title">ReadData</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span> <span class="comment">//读取数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> **arr;</span><br><span class="line">    arr = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*(k));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123; <span class="comment">//为每一行分配地址</span></span><br><span class="line">        arr[j] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">            arr[i][j] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,k;</span><br><span class="line">    <span class="keyword">int</span> **ptr;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;m,&amp;n,&amp;k);</span><br><span class="line">    ptr = ReadData(m,n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123; <span class="comment">//真正的模拟了栈</span></span><br><span class="line">        Stack *p = CreateNode();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//记录栈的容量</span></span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>; <span class="comment">//记录要检测数组下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            Push(p,j);count++;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; m) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span>(!IsEmpty(p) &amp;&amp; GetTop(p) == ptr[i][current])&#123;</span><br><span class="line">                Pop(p);count--;</span><br><span class="line">                current++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!IsEmpty) Pop(p);</span><br><span class="line">        <span class="keyword">if</span>(current == n) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123; <span class="comment">//为每一行分配地址</span></span><br><span class="line">        <span class="built_in">free</span>(*(ptr+j));</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;strong&gt;1、&lt;/strong&gt;刚开始受严蔚敏数据结构的启发，想用比较大小的方法来判断是不是出栈序列。但是发现最后一个测试点就是卡这个算法。&lt;br&gt; &lt;strong&gt;2、&lt;/strong&gt;然后看了柳神的博客，自己根据理解重新写了算法，但是第二个测试点还是过不去，下面是我的想法。&lt;br&gt; 步骤：循环判断数组中的每一个数，初始化temp=1 ，用temp来判断当前数组的最大值。如果数组当前值&lt;strong&gt;小于temp&lt;/strong&gt;，就出栈，若&lt;strong&gt;大于等于temp就入栈&lt;/strong&gt;，直到temp等于最大值。如果超过栈的容量标记flag=0并且break。最后根据flag判断YES或NO。&lt;br&gt; &lt;strong&gt;3、&lt;/strong&gt;但是上面的步骤不能通过第二个测试点。&lt;br&gt;于是参考了柳神的程序，得到了下面的程序：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="https://haohuaijin.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>7-20 表达式的转换(25分)</title>
    <link href="https://haohuaijin.github.io/2019/10/07/7-20%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%20(25%20%E5%88%86)/"/>
    <id>https://haohuaijin.github.io/2019/10/07/7-20%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%20(25%20%E5%88%86)/</id>
    <published>2019-10-07T00:47:22.000Z</published>
    <updated>2019-10-07T00:47:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="历时三个半小时终于完成。"><a href="#历时三个半小时终于完成。" class="headerlink" title="历时三个半小时终于完成。"></a>历时三个半小时终于完成。</h3><p>这道题的难点主要是在处理<strong>数字前的正负号</strong>上，同时还应该注意数字<strong>有小数点</strong>并且<strong>不是一位数字</strong>。<br>因为在做题之前同学给我说过这道题，也知道几个坑，所以做题的过程比较顺利。</p><hr><p><strong>我的步骤如下：</strong><br>1、先完成不考虑<strong>数字前的正负号</strong>的程序。<br>2、考虑<strong>数字前的正负号</strong>，完善程序。<br>通过上面的步骤，做题的过程比较的顺利，把难题变成了简单的的题目。<br>在第二步的时候比较烧脑，因为我的<strong>想法比较简单</strong>，就是把所有的可能全都列出来，所以<strong>要花很多的时间考虑，验证</strong>。</p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>1、考虑问题要全面，在数字前正负号时要尽量列出所有的可能。<br>2、开始做题时有一个大体的思路就行，不必考虑的很周到。<br>3、要善于<strong>猜测试点</strong>。。在考试时测试点不会告诉我们，而是需要自己取探索。</p><h4 id="坑："><a href="#坑：" class="headerlink" title="坑："></a>坑：</h4><p><strong>这个题的一个坑就是，会在有的正数前加正号，但输出的时候不用输出正号。</strong>我就一直没过这个测试点，直到搜到了测试数据。</p><hr><h5 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h5><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带有头结点 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> s;</span><br><span class="line">    Stack Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//操作</span></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">()</span></span>; <span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack p,<span class="keyword">char</span> str)</span></span>; <span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack p)</span></span>; <span class="comment">//判断是不是为空</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Pop</span><span class="params">(Stack p)</span></span>; <span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetTop</span><span class="params">(Stack p)</span></span>; <span class="comment">//得到栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">majoy</span><span class="params">(Stack p,<span class="keyword">char</span> *s)</span></span>; <span class="comment">//后缀表达式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack p = CreateStack();</span><br><span class="line">    <span class="keyword">char</span> S[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[^\n]"</span>,S);</span><br><span class="line">    majoy(p,S); <span class="comment">//得到后缀表达式</span></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后缀表达式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">majoy</span><span class="params">(Stack p,<span class="keyword">char</span> *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *ptr = S;</span><br><span class="line">    <span class="keyword">while</span>(*ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理数字</span></span><br><span class="line">        <span class="keyword">if</span>((*ptr &gt;= <span class="string">'0'</span> &amp;&amp; *ptr &lt;= <span class="string">'9'</span>) || *ptr == <span class="string">'.'</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//处理小数点</span></span><br><span class="line">            <span class="keyword">while</span>((*ptr &gt;= <span class="string">'1'</span> &amp;&amp; *ptr &lt;= <span class="string">'9'</span>) || *ptr == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c"</span>,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 可有可无，为了防止指针错误可以用这个</span></span><br><span class="line"><span class="comment">        //处理开始的-5 </span></span><br><span class="line"><span class="comment">        else if((*ptr == '-' || *ptr == '+') &amp;&amp; ptr == S)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">        ptr++;</span></span><br><span class="line"><span class="comment">        if(*(ptr-1) == '+') printf("");</span></span><br><span class="line"><span class="comment">            else printf("-");</span></span><br><span class="line"><span class="comment">            while((*ptr &gt;= '1' &amp;&amp; *ptr &lt;= '9') || *ptr == '.')&#123;</span></span><br><span class="line"><span class="comment">                printf("%c",*ptr);</span></span><br><span class="line"><span class="comment">                ptr++;</span></span><br><span class="line"><span class="comment">                flag = 1;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">        <span class="comment">//专门处理-5这种情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((*ptr == <span class="string">'-'</span> || *ptr == <span class="string">'+'</span>) &amp;&amp; (*(ptr<span class="number">-1</span>)&gt;<span class="string">'9'</span> || *(ptr<span class="number">-1</span>)&lt;<span class="string">'0'</span>) &amp;&amp; *(ptr<span class="number">-1</span>) != <span class="string">')'</span> &amp;&amp; (*(ptr+<span class="number">1</span>)&gt;=<span class="string">'1'</span> &amp;&amp; *(ptr+<span class="number">1</span>)&lt;=<span class="string">'9'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ptr++;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span>(*(ptr<span class="number">-1</span>) == <span class="string">'+'</span>) <span class="built_in">printf</span>(<span class="string">""</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">            <span class="keyword">while</span>((*ptr &gt;= <span class="string">'1'</span> &amp;&amp; *ptr &lt;= <span class="string">'9'</span>) || *ptr == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c"</span>,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理左括号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*ptr == <span class="string">'('</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Push(p,*ptr);</span><br><span class="line">            ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理右括号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*ptr == <span class="string">')'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将里面的全部抛出</span></span><br><span class="line">            <span class="keyword">while</span>(GetTop(p) != <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %c"</span>,Pop(p));</span><br><span class="line">            &#125;</span><br><span class="line">            Pop(p);</span><br><span class="line">            ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理加减号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*ptr == <span class="string">'-'</span> || *ptr == <span class="string">'+'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//处理空栈，或遇到左括号</span></span><br><span class="line">            <span class="keyword">if</span>(IsEmpty(p) || GetTop(p) == <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Push(p,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//全部抛出直到空栈或左括号</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!IsEmpty(p))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(GetTop(p) == <span class="string">'('</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %c"</span>,Pop(p));</span><br><span class="line">                &#125;</span><br><span class="line">                Push(p,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理乘除号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*ptr == <span class="string">'*'</span> || *ptr == <span class="string">'/'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//处理空栈，或遇到左括号</span></span><br><span class="line">            <span class="keyword">if</span>(IsEmpty(p) || GetTop(p) == <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Push(p,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遇到加减号同上</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(GetTop(p) == <span class="string">'-'</span> || GetTop(p) == <span class="string">'+'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Push(p,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理出栈的情况</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!IsEmpty(p) &amp;&amp; (GetTop(p) == <span class="string">'*'</span> || GetTop(p) == <span class="string">'/'</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(GetTop(p) == <span class="string">'('</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %c"</span>,Pop(p));</span><br><span class="line">                &#125;</span><br><span class="line">                Push(p,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后输出剩下运算符</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %c"</span>,Pop(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack q;</span><br><span class="line">    q = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    q-&gt;s = <span class="string">'\0'</span>;</span><br><span class="line">    q-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack p,<span class="keyword">char</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack ptr;</span><br><span class="line">    ptr = CreateStack();</span><br><span class="line">    ptr-&gt;s = str;</span><br><span class="line">    ptr-&gt;Next = p-&gt;Next; <span class="comment">//注意指向的位置</span></span><br><span class="line">    p-&gt;Next = ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Pop</span><span class="params">(Stack p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack ptr;</span><br><span class="line">    <span class="keyword">char</span> str;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(p))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈空\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = p-&gt;Next;</span><br><span class="line">    str = ptr-&gt;s;</span><br><span class="line">    p-&gt;Next = ptr-&gt;Next;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是不是为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p-&gt;Next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetTop</span><span class="params">(Stack p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(p)) <span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;Next-&gt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文献:<a href="https://blog.csdn.net/SiKongPop/article/details/77972879#comments" target="_blank" rel="noopener">https://blog.csdn.net/SiKongPop/article/details/77972879#comments</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;历时三个半小时终于完成。&quot;&gt;&lt;a href=&quot;#历时三个半小时终于完成。&quot; class=&quot;headerlink&quot; title=&quot;历时三个半小时终于完成。&quot;&gt;&lt;/a&gt;历时三个半小时终于完成。&lt;/h3&gt;&lt;p&gt;这道题的难点主要是在处理&lt;strong&gt;数字前的正负号&lt;/strong&gt;上，同时还应该注意数字&lt;strong&gt;有小数点&lt;/strong&gt;并且&lt;strong&gt;不是一位数字&lt;/strong&gt;。&lt;br&gt;因为在做题之前同学给我说过这道题，也知道几个坑，所以做题的过程比较顺利。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;我的步骤如下：&lt;/strong&gt;&lt;br&gt;1、先完成不考虑&lt;strong&gt;数字前的正负号&lt;/strong&gt;的程序。&lt;br&gt;2、考虑&lt;strong&gt;数字前的正负号&lt;/strong&gt;，完善程序。&lt;br&gt;通过上面的步骤，做题的过程比较的顺利，把难题变成了简单的的题目。&lt;br&gt;在第二步的时候比较烧脑，因为我的&lt;strong&gt;想法比较简单&lt;/strong&gt;，就是把所有的可能全都列出来，所以&lt;strong&gt;要花很多的时间考虑，验证&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;总结：&quot;&gt;&lt;a href=&quot;#总结：&quot; class=&quot;headerlink&quot; title=&quot;总结：&quot;&gt;&lt;/a&gt;总结：&lt;/h4&gt;&lt;p&gt;1、考虑问题要全面，在数字前正负号时要尽量列出所有的可能。&lt;br&gt;2、开始做题时有一个大体的思路就行，不必考虑的很周到。&lt;br&gt;3、要善于&lt;strong&gt;猜测试点&lt;/strong&gt;。。在考试时测试点不会告诉我们，而是需要自己取探索。&lt;/p&gt;
&lt;h4 id=&quot;坑：&quot;&gt;&lt;a href=&quot;#坑：&quot; class=&quot;headerlink&quot; title=&quot;坑：&quot;&gt;&lt;/a&gt;坑：&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;这个题的一个坑就是，会在有的正数前加正号，但输出的时候不用输出正号。&lt;/strong&gt;我就一直没过这个测试点，直到搜到了测试数据。&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&quot;AC代码&quot;&gt;&lt;a href=&quot;#AC代码&quot; class=&quot;headerlink&quot; title=&quot;AC代码&quot;&gt;&lt;/a&gt;AC代码&lt;/h5&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="PTA" scheme="https://haohuaijin.github.io/tags/PTA/"/>
    
  </entry>
  
  <entry>
    <title>7-4 是否同一棵二叉搜索树(25分).md</title>
    <link href="https://haohuaijin.github.io/2019/10/06/7-4-%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-25%E5%88%86-/"/>
    <id>https://haohuaijin.github.io/2019/10/06/7-4-%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-25%E5%88%86-/</id>
    <published>2019-10-06T04:25:03.000Z</published>
    <updated>2019-10-06T14:21:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>开始是卡在怎么<strong>读数据</strong>上(果然还是读数据可怕，好几次都是卡在这里😭😭)，中间有1、2天没有再碰这道题。然后今天想着不能再拖了，就硬着头皮解出来了。</p><h6 id="想法："><a href="#想法：" class="headerlink" title="想法："></a>想法：</h6><p>一开始是想着不用构建树，用数组处理的，但是左思右想没有思路。<br>然后我就构建了<strong>树</strong>的结构，用<strong>前序遍历的方法来比较树是不是相同</strong>。<br>所以整体上来看思路比较简单。</p><a id="more"></a><h6 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这道题的主要思路是：</span></span><br><span class="line"><span class="comment"> * 就是让比结点大的数的插入顺序相同，比结点小的数的插入顺序相同。</span></span><br><span class="line"><span class="comment"> * 但是感觉上面的比较麻烦，我好像写不出来😭😭</span></span><br><span class="line"><span class="comment"> * 所以我把树建立了起来，然后用遍历的方法比较是不是相同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Leaves</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Leaves</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    Tree left,right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> **<span class="title">ReadData</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> l)</span></span>; <span class="comment">//读取数据</span></span><br><span class="line"><span class="function">Tree <span class="title">CreateNode</span><span class="params">(<span class="keyword">int</span> item)</span></span>; <span class="comment">//创造节点</span></span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree q,<span class="keyword">int</span> item)</span></span>; <span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreTraverse</span><span class="params">(Tree q)</span></span>; <span class="comment">//前序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> vec1[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> vec2[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,l;</span><br><span class="line">    <span class="keyword">int</span> **arr;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Tree front,rear; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;l);</span><br><span class="line">        <span class="comment">//读取到arr数据</span></span><br><span class="line">        arr = ReadData(n,l); </span><br><span class="line">        <span class="comment">//每一次循环将vec1，vec2化为零</span></span><br><span class="line">        <span class="built_in">memset</span>(vec1, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">100</span>); <span class="comment">//memset函数,将数组元素全化为0</span></span><br><span class="line">        <span class="built_in">memset</span>(vec2, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">100</span>); <span class="comment">//memset函数,将数组元素全化为0</span></span><br><span class="line">        <span class="comment">//初始化好第一棵树</span></span><br><span class="line">        front = CreateNode(arr[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) Insert(front,arr[<span class="number">0</span>][i]); <span class="comment">//初始化第一棵树</span></span><br><span class="line">        <span class="comment">//前序遍历第一棵树，保存在vec1中</span></span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        PreTraverse(front);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) vec1[i] = vec2[i]; <span class="comment">//将前序遍历的结果都存放在vec2中。见PreTraverse函数</span></span><br><span class="line">        <span class="comment">//遍历剩余的树并比较</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//初始化树</span></span><br><span class="line">            m = <span class="number">0</span>;flag = <span class="number">1</span>;</span><br><span class="line">            rear = CreateNode(arr[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++) Insert(rear,arr[i][j]); </span><br><span class="line">            <span class="comment">//遍历树</span></span><br><span class="line">            PreTraverse(rear);</span><br><span class="line">            <span class="comment">//比较</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;m<span class="number">-1</span>;n++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vec1[n] != vec2[n]) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放每一行的地址</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l; ++i) <span class="built_in">free</span>(*(arr + i));</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> **<span class="title">ReadData</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> **arr;</span><br><span class="line">    arr = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*(l+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=l;j++)&#123; <span class="comment">//为每一行分配地址</span></span><br><span class="line">        arr[j] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=l;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">            arr[i][j] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">CreateNode</span><span class="params">(<span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree q;</span><br><span class="line">    q = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Leaves));</span><br><span class="line">    q-&gt;Data = item;</span><br><span class="line">    q-&gt;left = q-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree q,<span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!q)&#123;</span><br><span class="line">        q = CreateNode(<span class="number">0</span>);</span><br><span class="line">        q-&gt;Data = item;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(item &gt; q-&gt;Data)&#123;</span><br><span class="line">        q-&gt;right = Insert(q-&gt;right,item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(item &lt; q-&gt;Data)&#123;</span><br><span class="line">        q-&gt;left = Insert(q-&gt;left,item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreTraverse</span><span class="params">(Tree q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec2[m++] = q-&gt;Data;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;left) PreTraverse(q-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;right) PreTraverse(q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始是卡在怎么&lt;strong&gt;读数据&lt;/strong&gt;上(果然还是读数据可怕，好几次都是卡在这里😭😭)，中间有1、2天没有再碰这道题。然后今天想着不能再拖了，就硬着头皮解出来了。&lt;/p&gt;
&lt;h6 id=&quot;想法：&quot;&gt;&lt;a href=&quot;#想法：&quot; class=&quot;headerlink&quot; title=&quot;想法：&quot;&gt;&lt;/a&gt;想法：&lt;/h6&gt;&lt;p&gt;一开始是想着不用构建树，用数组处理的，但是左思右想没有思路。&lt;br&gt;然后我就构建了&lt;strong&gt;树&lt;/strong&gt;的结构，用&lt;strong&gt;前序遍历的方法来比较树是不是相同&lt;/strong&gt;。&lt;br&gt;所以整体上来看思路比较简单。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="PTA" scheme="https://haohuaijin.github.io/tags/PTA/"/>
    
      <category term="树" scheme="https://haohuaijin.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>scanf()的用法总结</title>
    <link href="https://haohuaijin.github.io/2019/10/03/scanf-%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://haohuaijin.github.io/2019/10/03/scanf-%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2019-10-03T12:42:26.000Z</published>
    <updated>2019-10-03T12:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>最近在刷PTA数据结构时，发现自己对于scanf()的用法还不是很熟练，写下此篇做一记录。</strong></p><hr><h2 id="1、scanf-读入数字"><a href="#1、scanf-读入数字" class="headerlink" title="1、scanf() 读入数字"></a>1、scanf() 读入数字</h2><p>如果是只用<code>sacnf()</code>读入数字的话比较简单。<br>可以分为以下集中情况：</p><h6 id="1-1-在一行中，读入数字"><a href="#1-1-在一行中，读入数字" class="headerlink" title="1.1 在一行中，读入数字"></a>1.1 在一行中，读入数字</h6><p>假设读入三个：<br>用<code>scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</code>来处理就足够了。</p><h6 id="1-2-在多行中，读入数字"><a href="#1-2-在多行中，读入数字" class="headerlink" title="1.2 在多行中，读入数字"></a>1.2 在多行中，读入数字</h6><p>假设读入两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br></pre></td></tr></table></figure><p>因为读入的是数字，<code>scanf()</code>可以自动忽略空格和换行符，所以不需要特别的处理，和上面一样就行。<br><code>scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</code></p><a id="more"></a><h6 id="1-3-读入数字时，有特殊的要求"><a href="#1-3-读入数字时，有特殊的要求" class="headerlink" title="1.3 读入数字时，有特殊的要求"></a>1.3 读入数字时，有特殊的要求</h6><p>例如:<br>要读入以下的数据，得到年月日。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-10-3</span><br></pre></td></tr></table></figure><p>因为里面有<code>-</code>字符所以你<strong>没有办法直接的把数据读进来</strong>，但幸运的是<code>scanf()</code>给了我们一种简单的方法来处理这种情况。<br><code>scanf(&quot;%d-%d-%d&quot;,&amp;a,&amp;b,&amp;c);</code>，这样你就可以得到年月日，也就是a，b，c。<br>这样做的原因是，<strong>在<code>scanf()</code>里面写了什么，在输入时就要原样的输入</strong>，即在<code>scanf()</code>里面写了<code>-</code>，输入的时候也要在那个位置加上<code>-</code>。</p><hr><h2 id="2、scanf-读入字符"><a href="#2、scanf-读入字符" class="headerlink" title="2、scanf() 读入字符"></a>2、scanf() 读入字符</h2><p>相较于读入数字，读入字符就比较麻烦些。</p><h5 id="1-1-在一行中，读入字符"><a href="#1-1-在一行中，读入字符" class="headerlink" title="1.1 在一行中，读入字符"></a>1.1 在一行中，读入字符</h5><p>例如：<br>读入一下的数据，数据间用空格隔开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b c d</span><br></pre></td></tr></table></figure><p>因为现在读入的是字符，空格和换行符都属于字符，所以我们采用<br><strong>1.3</strong>的方法来读入数据<code>scanf(&quot;%c %c %c&quot;,&amp;a,&amp;b,&amp;c);</code>。<br><strong>或者</strong>用<code>scanf(&quot;%c%c%c%c%c&quot;,&amp;a,&amp;unused1,&amp;b,&amp;unused2,&amp;c);</code>来读取，中间定义了两个字符<code>unused1和unused2</code>来读取空格。</p><h5 id="1-2-在多行中，读入字符"><a href="#1-2-在多行中，读入字符" class="headerlink" title="1.2 在多行中，读入字符"></a>1.2 在多行中，读入字符</h5><p>这里和<strong>1.2在多行中，读入数字</strong>的主要的区别，就是要<strong>处理行末的换行符</strong>，下面介绍两种方法来处理这个，假设要输入以下的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a d</span><br><span class="line">c d</span><br></pre></td></tr></table></figure><p><strong>(1)</strong> 用<code>getchar()</code>来处理换行符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char a,b,c,d;</span><br><span class="line">scanf(&quot;%c %c&quot;,&amp;a,&amp;b);</span><br><span class="line">getchar();</span><br><span class="line">scanf(&quot;%c %c&quot;,&amp;c,&amp;d);</span><br><span class="line">getchar();</span><br></pre></td></tr></table></figure><p><strong>(2)</strong> 用<code>scanf()</code>自行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char a,b,c,d;</span><br><span class="line">scanf(&quot;%c %c\n&quot;,&amp;a,&amp;b);</span><br><span class="line">scanf(&quot;%c %c\n&quot;,&amp;c,&amp;d);</span><br></pre></td></tr></table></figure><p>但是第二种方法，<strong>近几天</strong>不知道为什么在我的电脑上要多输入一次数据才可以正确的运行，前几天还可以正常的读入数据，不过<strong>在PTA上提交却没有问题</strong>。</p><h2 id="3、scanf-读入字符串"><a href="#3、scanf-读入字符串" class="headerlink" title="3、scanf() 读入字符串"></a>3、scanf() 读入字符串</h2><p>读入字符串比较简单，其中要注意的是，读入的字符串中<strong>不能有空格</strong>。如果有空格，就<strong>在空格处停止</strong>。<br><strong>如果要读入空格</strong>一个可行的方法就是用<code>scanf(&quot;%[^\n]&quot;,s);</code>来处理，这个表达式的意思是<strong>遇到换行符才停止读入</strong>，其中<code>scanf()</code>中<code>[]</code>里面<code>^</code>后面就是你要<strong>停止读入的字符</strong>，如把<code>\n</code>换成<code>s</code>意思就是遇到<code>s</code>就停止读入。<br>同时在<code>^</code>的后面可以放很多的字符，例如<code>scanf(&quot;%[^sdf]&quot;,s);</code>，意思就是遇到里面的任一个字符都停止读入。</p><p><strong>初学者，如果有遗漏或错误，请见谅。同时欢迎与我沟通交流。</strong></p><p><strong>好了今天记录下这些，剩下的以后再说。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;最近在刷PTA数据结构时，发现自己对于scanf()的用法还不是很熟练，写下此篇做一记录。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1、scanf-读入数字&quot;&gt;&lt;a href=&quot;#1、scanf-读入数字&quot; class=&quot;headerlink&quot; title=&quot;1、scanf() 读入数字&quot;&gt;&lt;/a&gt;1、scanf() 读入数字&lt;/h2&gt;&lt;p&gt;如果是只用&lt;code&gt;sacnf()&lt;/code&gt;读入数字的话比较简单。&lt;br&gt;可以分为以下集中情况：&lt;/p&gt;
&lt;h6 id=&quot;1-1-在一行中，读入数字&quot;&gt;&lt;a href=&quot;#1-1-在一行中，读入数字&quot; class=&quot;headerlink&quot; title=&quot;1.1 在一行中，读入数字&quot;&gt;&lt;/a&gt;1.1 在一行中，读入数字&lt;/h6&gt;&lt;p&gt;假设读入三个：&lt;br&gt;用&lt;code&gt;scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;a,&amp;amp;b,&amp;amp;c);&lt;/code&gt;来处理就足够了。&lt;/p&gt;
&lt;h6 id=&quot;1-2-在多行中，读入数字&quot;&gt;&lt;a href=&quot;#1-2-在多行中，读入数字&quot; class=&quot;headerlink&quot; title=&quot;1.2 在多行中，读入数字&quot;&gt;&lt;/a&gt;1.2 在多行中，读入数字&lt;/h6&gt;&lt;p&gt;假设读入两行：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 2 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4 5 6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;因为读入的是数字，&lt;code&gt;scanf()&lt;/code&gt;可以自动忽略空格和换行符，所以不需要特别的处理，和上面一样就行。&lt;br&gt;&lt;code&gt;scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;a,&amp;amp;b,&amp;amp;c);&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="经验" scheme="https://haohuaijin.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="C语言" scheme="https://haohuaijin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
