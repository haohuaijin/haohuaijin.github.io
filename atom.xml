<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HHJ的个人网站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://haohuaijin.github.io/"/>
  <updated>2020-10-17T03:31:38.790Z</updated>
  <id>https://haohuaijin.github.io/</id>
  
  <author>
    <name>HuaiJin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实验3:进程运行轨迹的跟踪与统计</title>
    <link href="https://haohuaijin.github.io/2020/10/17/%E5%AE%9E%E9%AA%8C3:%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/"/>
    <id>https://haohuaijin.github.io/2020/10/17/%E5%AE%9E%E9%AA%8C3:%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BD%A8%E8%BF%B9%E7%9A%84%E8%B7%9F%E8%B8%AA%E4%B8%8E%E7%BB%9F%E8%AE%A1/</id>
    <published>2020-10-17T03:30:13.000Z</published>
    <updated>2020-10-17T03:31:38.790Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：<a href="https://www.lanqiao.cn/courses/115/learning/?id=570" target="_blank" rel="noopener">进程运行轨迹跟踪与统计</a></p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>进程从创建（Linux 下调用 fork()）到结束的整个过程就是进程的生命期，进程在其生命期中的运行轨迹实际上就表现为进程状态的多次切换，如进程创建以后会成为就绪态；当该进程被调度以后会切换到运行态；在运行的过程中如果启动了一个文件读写操作，操作系统会将该进程切换到阻塞态（等待态）从而让出 CPU；当文件读写完毕以后，操作系统会在将其切换成就绪态，等待进程调度算法来调度该进程执行……</p><p>本次实验包括如下内容：</p><ul><li>基于模板 <code>process.c</code> 编写多进程的样本程序，实现如下功能： + 所有子进程都并行运行，每个子进程的实际运行时间一般不超过 30 秒； + 父进程向标准输出打印所有q子进程的 id，并在所有子进程都退出后才退出；</li><li>在 <code>Linux0.11</code> 上实现进程运行轨迹的跟踪。 + 基本任务是在内核中维护一个日志文件 <code>/var/process.log</code>，把从操作系统启动到系统关机过程中所有进程的运行轨迹都记录在这一 log 文件中。</li><li>在修改过的 0.11 上运行样本程序，通过分析 log 文件，统计该程序建立的所有进程的等待时间、完成时间（周转时间）和运行时间，然后计算平均等待时间，平均完成时间和吞吐量。可以自己编写统计程序，也可以使用 python 脚本程序—— <code>stat_log.py</code>（在 <code>/home/teacher/</code> 目录下） ——进行统计。</li><li>修改 0.11 进程调度的时间片，然后再运行同样的样本程序，统计同样的时间数据，和原有的情况对比，体会不同时间片带来的差异。</li></ul><a id="more"></a><p><code>/var/process.log</code> 文件的格式必须为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid    X    time</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>pid 是进程的 ID；</li><li>X 可以是 N、J、R、W 和 E 中的任意一个，分别表示进程新建(N)、进入就绪态(J)、进入运行态(R)、进入阻塞态(W) 和退出(E)；l</li><li>time 表示 X 发生的时间。这个时间不是物理时间，而是系统的滴答时间(tick)；</li></ul><p>三个字段之间用制表符分隔。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">12    N    1056</span><br><span class="line">12    J    1057</span><br><span class="line">4    W    1057</span><br><span class="line">12    R    1057</span><br><span class="line">13    N    1058</span><br><span class="line">13    J    1059</span><br><span class="line">14    N    1059</span><br><span class="line">14    J    1060</span><br><span class="line">15    N    1060</span><br><span class="line">15    J    1061</span><br><span class="line">12    W    1061</span><br><span class="line">15    R    1061</span><br><span class="line">15    J    1076</span><br><span class="line">14    R    1076</span><br><span class="line">14    E    1076</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="修改代码列表-主目录linux-0-11"><a href="#修改代码列表-主目录linux-0-11" class="headerlink" title="修改代码列表(主目录linux-0.11)"></a>修改代码列表(主目录linux-0.11)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">linux-0.11/process.c</span><br><span class="line"></span><br><span class="line">linux-0.11/kernel/fork.c</span><br><span class="line">linux-0.11/kernel/sched.c</span><br><span class="line">linux-0.11/kernel/exit.c</span><br><span class="line">linux-0.11/kernel/printk.c //根据实验楼的提示修改</span><br><span class="line">linux-0.11/init/main.c     //根据实验楼的提示修改</span><br></pre></td></tr></table></figure><h2 id="1-编写process-c"><a href="#1-编写process-c" class="headerlink" title="1. 编写process.c"></a>1. 编写<code>process.c</code></h2><p>实验的要求是多进程并行，并且在子进程全部退出之后，父进程在才退出。代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// add head</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HZ100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpuio_bound</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> cpu_time, <span class="keyword">int</span> io_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_PROC 5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid[N_PROC];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NR_PROC; i++) &#123;</span><br><span class="line">        <span class="keyword">pid_t</span> cur_pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(cur_pid == <span class="number">0</span>) &#123; <span class="comment">//子进程调用fork后，返回0</span></span><br><span class="line">cpuio_bound(<span class="number">2</span>*(i+<span class="number">1</span>), <span class="number">0</span>, <span class="number">1</span>); <span class="comment">//子进程的运行设置为递增</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the pid is %d, the father pid is %d.\n"</span>, getpid(), getppid());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//退出子进程</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//父进程返回的是子进程的pid</span></span><br><span class="line">pid[i] = cur_pid;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the %d child pid is %d\n"</span>, i, pid[i]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NR_PROC; i++)&#123;</span><br><span class="line">wait(&amp;pid[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"the parent is finished.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpuio_bound</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> cpu_time, <span class="keyword">int</span> io_time)</span></span>&#123;</span><br><span class="line"><span class="comment">// teach code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环创建子进程，然后在父进程利用<code>wait()</code>来等待子进程结束，然后父进程才退出。测试如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc process.c</span><br><span class="line">$ ./a.out</span><br></pre></td></tr></table></figure><p>可以通过注释掉<code>wait()</code>部分的代码，看到父进程提前结束的情况。</p><p>运行结果如下：</p><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/process.c_with_wait.jpg" width="500"></center><p>可以看出进程并行计算，如何设置每个进程运行时间一样的话，你将看到输出中下面的五行的顺序是乱序的，这里我就不演示了。</p><p>注释掉<code>wait()</code>代码后的结果如下：</p><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/process.c_without_wait.jpg" width="500"></center><p>可以看出当我们注释掉<code>wait()</code>后，父进程提前退出了。子进程重新关联1号进程为父进程。</p><h2 id="2-写process-log文件"><a href="#2-写process-log文件" class="headerlink" title="2. 写process.log文件"></a>2. 写process.log文件</h2><p>一开始的时候，我看到实验楼那里老师说：<strong>“只有进程 0 和进程 1 的文件描述符肯定关联着 log 文件”</strong>，所以我就在每个地方要写入<code>process.log</code>时，都重新打开<code>process.log</code>文件，并且关闭。然而我发现根本没法在<code>sched.c</code>文件里面这样做，一直在报错说有问题。所以看一了下网上的参考答案，发现他们都没有重新打开😂😂，直接用老师给的函数直接写入<code>process.log</code>文件。瞬间有种被老师坑了的感觉。。。</p><h3 id="2-1-修改fork-c文件"><a href="#2-1-修改fork-c文件" class="headerlink" title="2.1 修改fork.c文件"></a>2.1 修改<code>fork.c</code>文件</h3><p>在<code>fork.c</code>中的<code>copy_process()</code>是复制创建进程的主要代码，在这里进程被创建和进入就绪态。</p><p>添加的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_process</span><span class="params">(<span class="keyword">int</span> nr,<span class="keyword">long</span> ebp,<span class="keyword">long</span> edi,<span class="keyword">long</span> esi,<span class="keyword">long</span> gs,<span class="keyword">long</span> none,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> ebx,<span class="keyword">long</span> ecx,<span class="keyword">long</span> edx,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> fs,<span class="keyword">long</span> es,<span class="keyword">long</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> eip,<span class="keyword">long</span> cs,<span class="keyword">long</span> eflags,<span class="keyword">long</span> esp,<span class="keyword">long</span> ss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">....</span><br><span class="line">p-&gt;state = TASK_RUNNING;<span class="comment">/* do this last, just in case */</span></span><br><span class="line"></span><br><span class="line">  fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, p-&gt;pid, <span class="string">'N'</span>, jiffies);</span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, p-&gt;pid, <span class="string">'J'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> last_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-修改sched-c文件"><a href="#2-2-修改sched-c文件" class="headerlink" title="2.2 修改sched.c文件"></a>2.2 修改<code>sched.c</code>文件</h3><p>在<code>sched.c</code>里面我们要修改如下的几个函数<code>schedule()</code>，<code>sys_puase()</code>，<code>sleep_on()</code>，<code>interruptible_sleep_on</code>，<code>wake_up()</code>。</p><h4 id="1-修改进程调度函数schedule-函数"><a href="#1-修改进程调度函数schedule-函数" class="headerlink" title="1. 修改进程调度函数schedule()函数"></a>1. 修改进程调度函数<code>schedule()</code>函数</h4><p>这里参考了<a href="https://github.com/Wangzhike/HIT-Linux-0.11/blob/master/3-processTrack/linux-0.11/kernel/sched.c" target="_blank" rel="noopener">github.com/Wangzhike/HIT-linux-0.11</a>，当时把next的意思理解错了，导致耽误了很久没做出来(其实是因为我没仔细看源码😂😂)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,next,c;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span></span><br><span class="line"><span class="comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line"><span class="keyword">if</span> (*p) &#123;</span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123;</span><br><span class="line">(*p)-&gt;signal |= (<span class="number">1</span>&lt;&lt;(SIGALRM<span class="number">-1</span>));</span><br><span class="line">(*p)-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;</span><br><span class="line">(*p)-&gt;state==TASK_INTERRUPTIBLE)&#123;</span><br><span class="line">(*p)-&gt;state=TASK_RUNNING;</span><br><span class="line"></span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, (*p)-&gt;pid, <span class="string">'J'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* this is the scheduler proper: */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">c = <span class="number">-1</span>;next = <span class="number">0</span>;i = NR_TASKS;p = &amp;task[NR_TASKS];</span><br><span class="line"><span class="keyword">while</span> (--i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!*--p) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">c = (*p)-&gt;counter, next = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line"><span class="keyword">if</span> (*p)</span><br><span class="line">(*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) +</span><br><span class="line">(*p)-&gt;priority;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span>(current-&gt;pid != task[next] -&gt;pid)&#123; <span class="comment">//这里应该是task[next]-&gt;pid</span></span><br><span class="line">        <span class="keyword">if</span>(current-&gt;state == TASK_RUNNING)</span><br><span class="line">            fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, current-&gt;pid, <span class="string">'J'</span>, jiffies);</span><br><span class="line">        fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, task[next]-&gt;pid, <span class="string">'R'</span>, jiffies);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">switch_to(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-修改sys-pause-函数"><a href="#2-修改sys-pause-函数" class="headerlink" title="2. 修改sys_pause()函数"></a>2. 修改<code>sys_pause()</code>函数</h4><p>因为系统无事可做的时候，进程 0 会不停地调用 <code>sys_pause()</code>，以激活调度算法。所以我们要判断是不是0进程调用<code>sys_pause()</code>，如果是0进程的话，我们不向process.log添加内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_pause</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(current-&gt;pid != <span class="number">0</span>)</span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, current-&gt;pid, <span class="string">'W'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">schedule();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-修改sleep-on-函数"><a href="#3-修改sleep-on-函数" class="headerlink" title="3. 修改sleep_on()函数"></a>3. 修改<code>sleep_on()</code>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_on</span><span class="params">(struct task_struct **p)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (current == &amp;(init_task.task)) panic(<span class="string">"task[0] trying to sleep"</span>);</span><br><span class="line">tmp = *p; *p = current;</span><br><span class="line">current-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line"></span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, current-&gt;pid, <span class="string">'W'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">schedule();</span><br><span class="line"><span class="keyword">if</span> (tmp)&#123;</span><br><span class="line">tmp-&gt;state=<span class="number">0</span>; <span class="comment">// 0对应的是TASK_RUNNING</span></span><br><span class="line"></span><br><span class="line">    fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, tmp-&gt;pid, <span class="string">'J'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-修改interruptible-sleep-on函数"><a href="#4-修改interruptible-sleep-on函数" class="headerlink" title="4. 修改interruptible_sleep_on函数"></a>4. 修改<code>interruptible_sleep_on</code>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptible_sleep_on</span><span class="params">(struct task_struct **p)</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (current == &amp;(init_task.task)) panic(<span class="string">"task[0] trying to sleep"</span>);</span><br><span class="line">tmp=*p; *p=current;</span><br><span class="line">repeat:current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line"></span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, current-&gt;pid, <span class="string">'W'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">schedule();</span><br><span class="line"><span class="keyword">if</span> (*p &amp;&amp; *p != current) &#123;</span><br><span class="line">(**p).state=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, (**p).pid, <span class="string">'J'</span>, jiffies);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> repeat;</span><br><span class="line">&#125;</span><br><span class="line">*p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (tmp)&#123;</span><br><span class="line">tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, tmp-&gt;pid, <span class="string">'J'</span>, jiffies);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-修改wake-up-函数"><a href="#5-修改wake-up-函数" class="headerlink" title="5. 修改wake_up()函数"></a>5. 修改<code>wake_up()</code>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up</span><span class="params">(struct task_struct **p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &amp;&amp; *p) &#123;</span><br><span class="line">(**p).state=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, (**p).pid, <span class="string">'J'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">*p=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-修改exit-c文件"><a href="#2-3-修改exit-c文件" class="headerlink" title="2.3 修改exit.c文件"></a>2.3 修改<code>exit.c</code>文件</h3><p>主要修改<code>do_exit()</code>和<code>sys_waitpid()</code>这两个函数。</p><h4 id="1-修改do-exit-函数"><a href="#1-修改do-exit-函数" class="headerlink" title="1. 修改do_exit()函数"></a>1. 修改<code>do_exit()</code>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_exit</span><span class="params">(<span class="keyword">long</span> code)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">current-&gt;state = TASK_ZOMBIE;</span><br><span class="line">current-&gt;exit_code = code;</span><br><span class="line"></span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, current-&gt;pid, <span class="string">'E'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">tell_father(current-&gt;father);</span><br><span class="line">schedule();</span><br><span class="line"><span class="keyword">return</span> (<span class="number">-1</span>);<span class="comment">/* just to suppress warnings */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-修改sys-waitpid-函数"><a href="#2-修改sys-waitpid-函数" class="headerlink" title="2. 修改sys_waitpid()函数"></a>2. 修改<code>sys_waitpid()</code>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">unsigned</span> <span class="keyword">long</span> * stat_addr, <span class="keyword">int</span> options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> flag, code;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">verify_area(stat_addr,<span class="number">4</span>);</span><br><span class="line">repeat:</span><br><span class="line">  </span><br><span class="line">....</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line"><span class="keyword">if</span> (options &amp; WNOHANG)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">current-&gt;state=TASK_INTERRUPTIBLE;</span><br><span class="line"></span><br><span class="line">fprintk(<span class="number">3</span>, <span class="string">"%ld\t%c\t%ld\n"</span>, current-&gt;pid, <span class="string">'W'</span>, jiffies);</span><br><span class="line"></span><br><span class="line">schedule();</span><br><span class="line"><span class="keyword">if</span> (!(current-&gt;signal &amp;= ~(<span class="number">1</span>&lt;&lt;(SIGCHLD<span class="number">-1</span>))))</span><br><span class="line"><span class="keyword">goto</span> repeat;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> -EINTR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -ECHILD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-统计process-log文件"><a href="#2-4-统计process-log文件" class="headerlink" title="2.4 统计process.log文件"></a>2.4 统计process.log文件</h3><p>下面是在我电脑上运行的结果</p><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/process.log.jpg" width="500"></center><h2 id="3-修改时间片"><a href="#3-修改时间片" class="headerlink" title="3. 修改时间片"></a>3. 修改时间片</h2><p>在目录<code>linux-0.11/include/linux/sched.h</code>中的<code>INIT_TASK</code>里面，可以修改0进程的时间片的大小，源代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里可以修改时间片</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_TASK \</span></span><br><span class="line"><span class="comment">/* state etc */</span>&#123; <span class="number">0</span>,<span class="number">15</span>,<span class="number">15</span>, \<span class="comment">//这里的0，15，15 分别对应着state、counter 和 priority;</span></span><br><span class="line"><span class="comment">/* signals */</span><span class="number">0</span>,&#123;&#123;&#125;,&#125;,<span class="number">0</span>, \</span><br><span class="line"><span class="comment">/* ec,brk... */</span><span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \</span><br><span class="line"><span class="comment">/* pid etc.. */</span><span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \</span><br><span class="line"><span class="comment">/* uid etc */</span><span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \</span><br><span class="line"><span class="comment">/* alarm */</span><span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>, \</span><br><span class="line"><span class="comment">/* math */</span><span class="number">0</span>, \</span><br></pre></td></tr></table></figure><p>可以通过给改这里的东西来修改时间片的大小。具体的比较我感觉不是很明显，在这里就不给出了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;课程链接：&lt;a href=&quot;https://www.lanqiao.cn/courses/115/learning/?id=570&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;进程运行轨迹跟踪与统计&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot; class=&quot;headerlink&quot; title=&quot;实验内容&quot;&gt;&lt;/a&gt;实验内容&lt;/h2&gt;&lt;p&gt;进程从创建（Linux 下调用 fork()）到结束的整个过程就是进程的生命期，进程在其生命期中的运行轨迹实际上就表现为进程状态的多次切换，如进程创建以后会成为就绪态；当该进程被调度以后会切换到运行态；在运行的过程中如果启动了一个文件读写操作，操作系统会将该进程切换到阻塞态（等待态）从而让出 CPU；当文件读写完毕以后，操作系统会在将其切换成就绪态，等待进程调度算法来调度该进程执行……&lt;/p&gt;
&lt;p&gt;本次实验包括如下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于模板 &lt;code&gt;process.c&lt;/code&gt; 编写多进程的样本程序，实现如下功能： + 所有子进程都并行运行，每个子进程的实际运行时间一般不超过 30 秒； + 父进程向标准输出打印所有q子进程的 id，并在所有子进程都退出后才退出；&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;Linux0.11&lt;/code&gt; 上实现进程运行轨迹的跟踪。 + 基本任务是在内核中维护一个日志文件 &lt;code&gt;/var/process.log&lt;/code&gt;，把从操作系统启动到系统关机过程中所有进程的运行轨迹都记录在这一 log 文件中。&lt;/li&gt;
&lt;li&gt;在修改过的 0.11 上运行样本程序，通过分析 log 文件，统计该程序建立的所有进程的等待时间、完成时间（周转时间）和运行时间，然后计算平均等待时间，平均完成时间和吞吐量。可以自己编写统计程序，也可以使用 python 脚本程序—— &lt;code&gt;stat_log.py&lt;/code&gt;（在 &lt;code&gt;/home/teacher/&lt;/code&gt; 目录下） ——进行统计。&lt;/li&gt;
&lt;li&gt;修改 0.11 进程调度的时间片，然后再运行同样的样本程序，统计同样的时间数据，和原有的情况对比，体会不同时间片带来的差异。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="https://haohuaijin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>实验1:操作系统的引导</title>
    <link href="https://haohuaijin.github.io/2020/10/06/%E5%AE%9E%E9%AA%8C1:%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC/"/>
    <id>https://haohuaijin.github.io/2020/10/06/%E5%AE%9E%E9%AA%8C1:%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC/</id>
    <published>2020-10-06T08:31:49.000Z</published>
    <updated>2020-10-06T08:43:04.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验的准备工作操作"><a href="#实验的准备工作操作" class="headerlink" title="实验的准备工作操作"></a>实验的准备工作操作</h2><ul><li>解压源码用<code>tar -zxvf hit-oslab-linux-20110823.tar.gz</code> 可以使用<code>-C</code>来指定解压路径，<code>tar -zxvf hit-oslab-linux-20110823.tar.gz -C [path]</code></li><li>编译linux-0.11的源码，在<code>linux-0.11</code>的文件夹下运行<code>make all</code>或者<code>make</code>。</li><li>在oslab文件目录下运行<code>./run</code>运行<code>bochs 中的linux-0.11</code>。</li><li>访问linux-0.11里面的文件，使用<code>sudo ./mount-hdc</code>来装载硬盘，然后在<code>hdc</code>中访问，卸载硬盘<code>sudo umount hdc</code>。</li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol><li>阅读《Linux 内核完全注释》的第 6 章，对计算机和 Linux 0.11 的引导过程进行初步的了解；</li><li>按照下面的要求改写 0.11 的引导程序 bootsect.s</li><li>有兴趣同学可以做做进入保护模式前的设置程序 setup.s。</li></ol><a id="more"></a><h3 id="改写-bootsect-s-主要完成如下功能："><a href="#改写-bootsect-s-主要完成如下功能：" class="headerlink" title="改写 bootsect.s 主要完成如下功能："></a>改写 bootsect.s 主要完成如下功能：</h3><ul><li>bootsect.s 能在屏幕上打印一段提示信息“XXX is booting…”，其中 XXX 是你给自己的操作系统起的名字，也可以显示一个特色 logo，以表示自己操作系统的与众不同。</li></ul><h3 id="改写-setup-s-主要完成如下功能："><a href="#改写-setup-s-主要完成如下功能：" class="headerlink" title="改写 setup.s 主要完成如下功能："></a>改写 setup.s 主要完成如下功能：</h3><ol><li>bootsect.s 能完成 setup.s 的载入，并跳转到 setup.s 开始地址执行。而 setup.s 向屏幕输出一行”Now we are in SETUP”。</li><li>setup.s 能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。</li><li>setup.s 不再加载 Linux 内核，保持上述信息显示在屏幕上即可。</li></ol><h2 id="bootsect-s的修改"><a href="#bootsect-s的修改" class="headerlink" title="bootsect.s的修改"></a>bootsect.s的修改</h2><p><code>bootsect.s</code>的功能是将自己从<code>0x7c00</code>处移动到了<code>0x90000</code>处。显示字符<code>loding system ...</code>，然后将磁盘上的<code>setup.s</code>和<code>system</code>模块加载到内存中来，最后跳转到<code>setup.s</code>所在的位置，执行<code>setup.s</code>。</p><p><strong>实验内容：</strong></p><ol><li><p>bootsect.s 能在屏幕上打印一段提示信息“XXX is booting…”；</p></li><li><p>bootsect.s 能完成 setup.s 的载入，并跳转到 setup.s 开始地址执行。</p></li></ol><h3 id="1-bootsect-s-打印字符"><a href="#1-bootsect-s-打印字符" class="headerlink" title="1. bootsect.s 打印字符"></a>1. bootsect.s 打印字符</h3><p>首先使用<strong>BIOS</strong><code>0x10</code>号中断的子功能<code>0x03</code>获得光标的位置，然后再利用<strong>BIOS</strong><code>0x10</code>号中断的子功能<code>0x13</code>打印字符到屏幕上。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">entry start</span><br><span class="line">start:</span><br><span class="line">    movah,#0x03! read cursor pos</span><br><span class="line">  xorbh,bh</span><br><span class="line">  int0x10</span><br><span class="line"></span><br><span class="line">    mov cx,#26</span><br><span class="line">    mov bl,#07</span><br><span class="line">    mov bp,#msg !寻址es:bp</span><br><span class="line">    mov ax,#0x7c0 !因为bootsect的代码放在0x7c00处</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10 </span><br><span class="line">msg:</span><br><span class="line">    .byte 13,10 !回车和换行</span><br><span class="line">    .ascii &quot;HaoOS is loading ...&quot;</span><br><span class="line">    .byte 13,10,13,10</span><br><span class="line"></span><br><span class="line">.org 510</span><br><span class="line">boot_flag:</span><br><span class="line">    .word 0xAA55</span><br></pre></td></tr></table></figure><p>在<strong>BIOS</strong>中断指令<code>int</code>前面的代码都是为中断设置一些参数。最后的三行是因为bootsect的大小必须为512字节，所以添加到后面使编译后的文件大小为512字节，最后两个字节为<code>0xAA55</code>。</p><h3 id="2-载入setup并跳转"><a href="#2-载入setup并跳转" class="headerlink" title="2. 载入setup并跳转"></a>2. 载入setup并跳转</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">entry start</span><br><span class="line">start:</span><br><span class="line">    movah,#0x03! read cursor pos</span><br><span class="line">  xorbh,bh</span><br><span class="line">  int0x10</span><br><span class="line"></span><br><span class="line">    mov cx,#26</span><br><span class="line">    mov bl,#07</span><br><span class="line">    mov bp,#msg !寻址es:bp</span><br><span class="line">    mov ax,#0x7c0 !因为bootsect的代码放在0x7c00处</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">load_setup:</span><br><span class="line">movdx,#0x0000! drive 0, head 0</span><br><span class="line">movcx,#0x0002! sector 2, track 0</span><br><span class="line">movbx,#0x0200! address = 512, in INITSEG</span><br><span class="line">movax,#0x0200+4    ! service 2, nr of sectors</span><br><span class="line">int0x13! read it</span><br><span class="line"></span><br><span class="line">  jmpi 0,#0x07e0      ! jump to setup 0x07e0 = 0x07c0 + 0x0200</span><br><span class="line">                        ! there is set cs to 0x07e0, in the setup the cs be used.</span><br><span class="line"></span><br><span class="line">msg:</span><br><span class="line">    .byte 13,10 !回车和换行</span><br><span class="line">    .ascii &quot;HaoOS is loading ...&quot;</span><br><span class="line">    .byte 13,10,13,10</span><br><span class="line"></span><br><span class="line">.org 510</span><br><span class="line">boot_flag:</span><br><span class="line">    .word 0xAA55</span><br></pre></td></tr></table></figure><p>在第一部分的代码中添加了load_step的部分，这一部分利用BIOS<code>0x13</code>中断读入<code>setup.s</code>然后利用<code>jmpi</code>跳转到<code>setup.s</code>模块开始的地方。</p><p><strong>注意</strong>：</p><p>由于在bootsect中我们并没有移动bootsect的位置，所以在跳转的时候的地址是<code>0x07c0 + 0x0200 = 0x07e0</code>，而不是和linux-0.11中一样跳转到<code>0x90200</code>处。</p><h2 id="setup的修改"><a href="#setup的修改" class="headerlink" title="setup的修改"></a>setup的修改</h2><p>setup的主要功能是使用BIOS中断读取系统参数，然后放到内存中的指定位置，同时将cpu从实模式转化到保护模式。</p><p><strong>实验内容</strong>：</p><ol><li>setup.s 向屏幕输出一行”Now we are in SETUP”。</li><li>setup.s 能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。</li><li>setup.s 不再加载 Linux 内核，保持上述信息显示在屏幕上即可。</li></ol><h3 id="1-setup向屏幕输出字符"><a href="#1-setup向屏幕输出字符" class="headerlink" title="1. setup向屏幕输出字符"></a>1. setup向屏幕输出字符</h3><p>这一部分代码和bootsect部分类似。有的部分需要修改，比如<code>es</code>寄存器的指向，还有打印的字符的长度。</p><h3 id="2-获取硬件参数并打印"><a href="#2-获取硬件参数并打印" class="headerlink" title="2. 获取硬件参数并打印"></a>2. 获取硬件参数并打印</h3><p>这里如何获取硬件参数，既可以参考linux-0.11的源码，也可以自己查看BIOS中断的手册。我在这里比较迷惑的是如何将获得的参数打印到屏幕上？看了老师的实现后，发现还是比较简单的，主要问题是自己对汇编语言还是不够熟悉。老师的代码如下(大体的思路是先读参数，然后获取光标，打印，获取光标，打印…..)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">INITSEG  = 0x9000</span><br><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">! Print &quot;NOW we are in SETUP&quot;</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#25</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg2</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov es,ax</span><br><span class="line">! init ss:sp</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,#0xFF00</span><br><span class="line"></span><br><span class="line">! Get Params</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov [0],dx</span><br><span class="line">    </span><br><span class="line">    mov ah,#0x88</span><br><span class="line">    int 0x15</span><br><span class="line">    mov [2],ax</span><br><span class="line">! 这里是如何把参数保存到数据段里面的</span><br><span class="line">    mov ax,#0x0000</span><br><span class="line">    mov ds,ax</span><br><span class="line">    lds si,[4*0x41]</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,#0x0004</span><br><span class="line">    mov cx,#0x10</span><br><span class="line">    rep</span><br><span class="line">    movsb</span><br><span class="line"></span><br><span class="line">! Be Ready to Print</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">! Cursor Position</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#18</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_cursor</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[0]</span><br><span class="line">    call    print_hex</span><br><span class="line">! Memory Size</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#14</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_memory</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[2]</span><br><span class="line">    call    print_hex</span><br><span class="line">! Add KB</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#2</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_kb</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">! Cyles</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#7</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_cyles</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[4]</span><br><span class="line">    call    print_hex</span><br><span class="line">! Heads</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#8</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_heads</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[6]</span><br><span class="line">    call    print_hex</span><br><span class="line">! Secotrs</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#10</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_sectors</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[12]</span><br><span class="line">    call    print_hex</span><br><span class="line"></span><br><span class="line">inf_loop:</span><br><span class="line">    jmp inf_loop</span><br><span class="line"></span><br><span class="line">print_hex:</span><br><span class="line">    mov    cx,#4</span><br><span class="line">print_digit:</span><br><span class="line">    rol    dx,#4</span><br><span class="line">    mov    ax,#0xe0f</span><br><span class="line">    and    al,dl</span><br><span class="line">    add    al,#0x30</span><br><span class="line">    cmp    al,#0x3a</span><br><span class="line">    jl     outp</span><br><span class="line">    add    al,#0x07</span><br><span class="line">outp:</span><br><span class="line">    int    0x10</span><br><span class="line">    loop   print_digit</span><br><span class="line">    ret</span><br><span class="line">print_nl:</span><br><span class="line">    mov    ax,#0xe0d     ! CR</span><br><span class="line">    int    0x10</span><br><span class="line">    mov    al,#0xa     ! LF</span><br><span class="line">    int    0x10</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">msg2:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;NOW we are in SETUP&quot;</span><br><span class="line">    .byte 13,10,13,10</span><br><span class="line">msg_cursor:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Cursor position:&quot;</span><br><span class="line">msg_memory:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Memory Size:&quot;</span><br><span class="line">msg_cyles:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Cyls:&quot;</span><br><span class="line">msg_heads:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Heads:&quot;</span><br><span class="line">msg_sectors:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Sectors:&quot;</span><br><span class="line">msg_kb:</span><br><span class="line">    .ascii &quot;KB&quot;</span><br><span class="line"></span><br><span class="line">.org 510</span><br><span class="line">boot_flag:</span><br><span class="line">    .word 0xAA55</span><br></pre></td></tr></table></figure><p>这里如何使用的bootsect还是上个实验的代码的话，需要把前面的<code>INITSEG</code>改成<code>0x07e0</code>。</p><p><strong>疑问：</strong></p><p>在上面代码的获取参数部分，不明白是如何把数据保存到特定位置的？如何循环的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,#0x0000</span><br><span class="line">mov ds,ax</span><br><span class="line">lds si,[4*0x41]</span><br><span class="line">mov ax,#INITSEG</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,#0x0004</span><br><span class="line">mov cx,#0x10</span><br><span class="line">rep</span><br><span class="line">movsb</span><br></pre></td></tr></table></figure><p>试着解释：在这里是从原地址到目的地址移动1字节的内容，这里设置<code>cs=16</code>，意思是移动16次，共16字节。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实验的准备工作操作&quot;&gt;&lt;a href=&quot;#实验的准备工作操作&quot; class=&quot;headerlink&quot; title=&quot;实验的准备工作操作&quot;&gt;&lt;/a&gt;实验的准备工作操作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;解压源码用&lt;code&gt;tar -zxvf hit-oslab-linux-20110823.tar.gz&lt;/code&gt; 可以使用&lt;code&gt;-C&lt;/code&gt;来指定解压路径，&lt;code&gt;tar -zxvf hit-oslab-linux-20110823.tar.gz -C [path]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;编译linux-0.11的源码，在&lt;code&gt;linux-0.11&lt;/code&gt;的文件夹下运行&lt;code&gt;make all&lt;/code&gt;或者&lt;code&gt;make&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在oslab文件目录下运行&lt;code&gt;./run&lt;/code&gt;运行&lt;code&gt;bochs 中的linux-0.11&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;访问linux-0.11里面的文件，使用&lt;code&gt;sudo ./mount-hdc&lt;/code&gt;来装载硬盘，然后在&lt;code&gt;hdc&lt;/code&gt;中访问，卸载硬盘&lt;code&gt;sudo umount hdc&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot; class=&quot;headerlink&quot; title=&quot;实验内容&quot;&gt;&lt;/a&gt;实验内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;阅读《Linux 内核完全注释》的第 6 章，对计算机和 Linux 0.11 的引导过程进行初步的了解；&lt;/li&gt;
&lt;li&gt;按照下面的要求改写 0.11 的引导程序 bootsect.s&lt;/li&gt;
&lt;li&gt;有兴趣同学可以做做进入保护模式前的设置程序 setup.s。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="https://haohuaijin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>实验2:系统调用</title>
    <link href="https://haohuaijin.github.io/2020/10/06/%E5%AE%9E%E9%AA%8C2:%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>https://haohuaijin.github.io/2020/10/06/%E5%AE%9E%E9%AA%8C2:%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</id>
    <published>2020-10-06T07:23:38.000Z</published>
    <updated>2020-10-06T07:33:17.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验2-系统调用"><a href="#实验2-系统调用" class="headerlink" title="实验2: 系统调用"></a>实验2: 系统调用</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>在 Linux 0.11 上添加两个系统调用，并编写两个简单的应用程序测试它们。</p><h3 id="1-iam"><a href="#1-iam" class="headerlink" title="1. iam()"></a>1. <code>iam()</code></h3><p>第一个系统调用是 iam()，其原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * name)</span></span>;</span><br></pre></td></tr></table></figure><p>完成的功能是将字符串参数 <code>name</code> 的内容拷贝到内核中保存下来。要求 <code>name</code> 的长度不能超过 23 个字符。返回值是拷贝的字符数。如果 <code>name</code> 的字符个数超过了 <code>23</code>，则返回 “-1”，并置 errno 为 EINVAL。</p><p>在 <code>kernal/who.c</code> 中实现此系统调用。</p><h3 id="2-whoami"><a href="#2-whoami" class="headerlink" title="2. whoami()"></a>2. <code>whoami()</code></h3><p>第二个系统调用是 whoami()，其原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">whoami</span><span class="params">(<span class="keyword">char</span>* name, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>它将内核中由 <code>iam()</code> 保存的名字拷贝到 name 指向的用户地址空间中，同时确保不会对 <code>name</code> 越界访存（<code>name</code> 的大小由 <code>size</code> 说明）。返回值是拷贝的字符数。如果 <code>size</code> 小于需要的空间，则返回“-1”，并置 errno 为 EINVAL。</p><p>也是在 <code>kernal/who.c</code> 中实现。</p><h3 id="3-测试程序"><a href="#3-测试程序" class="headerlink" title="3. 测试程序"></a>3. 测试程序</h3><p>运行添加过新系统调用的 Linux 0.11，在其环境下编写两个测试程序 iam.c 和 whoami.c。最终的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./iam lizhijun</span><br><span class="line">$ ./whoami</span><br><span class="line">lizhijun</span><br></pre></td></tr></table></figure><h2 id="系统调用简介"><a href="#系统调用简介" class="headerlink" title="系统调用简介"></a>系统调用简介</h2><p>系统调用和一般的函数调用在使用方式上没有区别，区别在于调用之后函数内部如何处理。</p><a id="more"></a><p>系统调用中使用<code>int 0x80</code>来切换到内核态，使用内核中的系统函数来完成系统调用，如下面的步骤：</p><ol><li>应用程序调用库函数（API）；</li><li>API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态；</li><li>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</li><li>系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数；</li><li>中断处理函数返回到 API 中；</li><li>API 将 EAX 返回给应用程序。</li></ol><p>下图是一个系统调用在内核里面的调用流程：</p><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/系统调用.png" width="600"></center><p>需要修改的文件(以linux-0.11为主文件夹)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">linux-0.11/include/linux/sys.h</span><br><span class="line">linux-0.11/kernel/system_call.s</span><br><span class="line">linux-0.11/kernel/Makefile</span><br><span class="line">在linux-0.11/kernel中添加文件</span><br><span class="line">who.c</span><br><span class="line"></span><br><span class="line">下面的需要在虚拟机中的linux系统中修改:</span><br><span class="line">在linux-0.11的文件目录下修改</span><br><span class="line">/usr/root/include/unistd.h</span><br><span class="line">~/iam.c</span><br><span class="line">~/whoami.c</span><br></pre></td></tr></table></figure><h2 id="修改sys-h"><a href="#修改sys-h" class="headerlink" title="修改sys.h"></a>修改<code>sys.h</code></h2><p>在<code>sys.h</code>中维护了一个<code>sys_call_table</code>是一个函数指针数组，通过系统调用号，然后在数组中找到相应的中断处理函数。我们要将自己编写的系统调用添加到里面，就如以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_iam</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_whoami</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">fn_ptr sys_call_table[] = &#123;......,sys_setregid,sys_iam,sys_whoami&#125;;</span><br></pre></td></tr></table></figure><h2 id="修改unistd-h"><a href="#修改unistd-h" class="headerlink" title="修改unistd.h"></a>修改<code>unistd.h</code></h2><p>在<code>unistd.h</code>中定义了系统调用的编号，和一些宏，如下面所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define __NR_setregid71</span><br><span class="line">//在这里添加我们自己的系统调用编号，使我们的系统调用可以在sys.h中找到</span><br><span class="line">#define __NR_iam72</span><br><span class="line">#define __NR_whoami73</span><br><span class="line"></span><br><span class="line">//这里定义了一个没有参数输入的系统调用宏。</span><br><span class="line">#define _syscall0(type,name) \</span><br><span class="line">type name(void) \</span><br><span class="line">&#123; \</span><br><span class="line">long __res; \</span><br><span class="line">__asm__ volatile (&quot;int $0x80&quot; \</span><br><span class="line">: &quot;=a&quot; (__res) \</span><br><span class="line">: &quot;0&quot; (__NR_##name)); \  //这里就是把系统调用编号，存入EAX中。</span><br><span class="line">if (__res &gt;= 0) \</span><br><span class="line">return (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line">return -1; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改system-call-s"><a href="#修改system-call-s" class="headerlink" title="修改system_call.s"></a>修改<code>system_call.s</code></h2><p>将其中第61行的<code>nr_system_calls = 72</code>里面的72改成74，因为这里的<code>nr_system_calls</code>指的是总共有多少个系统调用。</p><h2 id="修改Makefile"><a href="#修改Makefile" class="headerlink" title="修改Makefile"></a>修改<code>Makefile</code></h2><p>修改内容如下，在<code>OBJS</code>最后添加<code>who.o</code>，让内核中包含<code>who.c</code>里面的内容。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJS  = sched.o system_call.o traps.o asm.o fork.o \</span><br><span class="line">panic.o printk.o vsprintf.o sys.o exit.o \</span><br><span class="line">signal.o mktime.o who.o</span><br></pre></td></tr></table></figure><p>然后在末尾添加如下内容，对<code>who.c</code>编译，链接。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who.s who.o: who.c  ../<span class="keyword">include</span>/linux/kernel.h ../<span class="keyword">include</span>/unistd.h <span class="comment">#! add who.c</span></span><br></pre></td></tr></table></figure><h2 id="编写who-c"><a href="#编写who-c" class="headerlink" title="编写who.c"></a>编写<code>who.c</code></h2><p>在<code>who.c</code>中要实现<code>iam()</code>和<code>whami()</code>这两个函数，这里参考了[<a href="https://ehye.github.io/2020/04/01/hit-oslab2/][https://ehye.github.io/2020/04/01/hit-oslab2/]" target="_blank" rel="noopener">https://ehye.github.io/2020/04/01/hit-oslab2/][https://ehye.github.io/2020/04/01/hit-oslab2/]</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/segment.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> myname[<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_iam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">25</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123; <span class="comment">// get char from user input</span></span><br><span class="line">        str[i] = get_fs_byte(name + i);</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt;= <span class="number">25</span> &amp;&amp; str[i++] != <span class="string">'\0'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">24</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(myname, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_whoami</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>(myname);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt; length)&#123;</span><br><span class="line">        <span class="keyword">return</span> -(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// copy from kernel mode to user mode</span></span><br><span class="line">        put_fs_byte(myname[i], name + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上面的代码要注意的是，这里代码是位于内核态的。我们定义的数据都是在内核态中定义的。无法直接获取用户态的内容，所以这里用了两个函数<code>get_fs_byte</code>和<code>put_fs_byte</code>，第一个用来得到用户态的数据，第二个用来将数据存入用户态</strong>。</p><h2 id="编写iam-和whoami"><a href="#编写iam-和whoami" class="headerlink" title="编写iam()和whoami()"></a>编写<code>iam()</code>和<code>whoami()</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//iam()在用户空间的接口函数</span></span><br><span class="line"><span class="comment">// 这是定义在unistd.h里面的一个宏，展开后是一个包含int 0x80中断的代码。</span></span><br><span class="line">_syscall1(<span class="keyword">int</span>, iam, <span class="keyword">const</span> <span class="keyword">char</span>*, name);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    iam(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// whoami()在用户空间的接口函数</span></span><br><span class="line"><span class="comment">// 这是定义在unistd.h里面的一个宏，展开后是一个包含int 0x80中断的代码。</span></span><br><span class="line">_syscall2(<span class="keyword">int</span>, whoami,<span class="keyword">char</span>*,name,<span class="keyword">unsigned</span> <span class="keyword">int</span>,<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">    whoami(name, <span class="number">30</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里要注意的是，<strong><code>#define __LIBRARY__</code>一定要在<code>#include &lt;unistd.h&gt;</code>前面，要不然就会报错</strong>，具体是什么原因，我现在还不清楚。</p><h2 id="调试运行"><a href="#调试运行" class="headerlink" title="调试运行"></a>调试运行</h2><p>完成上述的修改，并且重新编译运行linux-0.11后，在linux-0.11里面输入下面的命令，验证结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o iam iam.c</span><br><span class="line">$ gcc -o whoami whoami.c</span><br><span class="line">$ ./iam hello,world</span><br><span class="line">$ ./whoami</span><br><span class="line">hello,world</span><br></pre></td></tr></table></figure><h2 id="提交验证"><a href="#提交验证" class="headerlink" title="提交验证"></a>提交验证</h2><p>使用老师提供的<code>testlab2.c</code>和<code>testlab2.sh</code>来验证我们的代码，过程如下，需要在linux-0.11里面运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o iam iam.c</span><br><span class="line">$ gcc -o whoami whoami.c</span><br><span class="line">$ gcc testlab2.c</span><br><span class="line">$ ./a.out</span><br><span class="line"></span><br><span class="line">$ ./testlab2.sh</span><br></pre></td></tr></table></figure><p>运行<code>a.out</code>和<code>testlab2.sh</code>后的结果如下：</p><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/testlab2.c.jpg" width="600"></center><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/testlab2.sh.jpg" width="600"></center>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实验2-系统调用&quot;&gt;&lt;a href=&quot;#实验2-系统调用&quot; class=&quot;headerlink&quot; title=&quot;实验2: 系统调用&quot;&gt;&lt;/a&gt;实验2: 系统调用&lt;/h1&gt;&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot; class=&quot;headerlink&quot; title=&quot;实验内容&quot;&gt;&lt;/a&gt;实验内容&lt;/h2&gt;&lt;p&gt;在 Linux 0.11 上添加两个系统调用，并编写两个简单的应用程序测试它们。&lt;/p&gt;
&lt;h3 id=&quot;1-iam&quot;&gt;&lt;a href=&quot;#1-iam&quot; class=&quot;headerlink&quot; title=&quot;1. iam()&quot;&gt;&lt;/a&gt;1. &lt;code&gt;iam()&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;第一个系统调用是 iam()，其原型为：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;iam&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * name)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;完成的功能是将字符串参数 &lt;code&gt;name&lt;/code&gt; 的内容拷贝到内核中保存下来。要求 &lt;code&gt;name&lt;/code&gt; 的长度不能超过 23 个字符。返回值是拷贝的字符数。如果 &lt;code&gt;name&lt;/code&gt; 的字符个数超过了 &lt;code&gt;23&lt;/code&gt;，则返回 “-1”，并置 errno 为 EINVAL。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;kernal/who.c&lt;/code&gt; 中实现此系统调用。&lt;/p&gt;
&lt;h3 id=&quot;2-whoami&quot;&gt;&lt;a href=&quot;#2-whoami&quot; class=&quot;headerlink&quot; title=&quot;2. whoami()&quot;&gt;&lt;/a&gt;2. &lt;code&gt;whoami()&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;第二个系统调用是 whoami()，其原型为：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;whoami&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* name, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;它将内核中由 &lt;code&gt;iam()&lt;/code&gt; 保存的名字拷贝到 name 指向的用户地址空间中，同时确保不会对 &lt;code&gt;name&lt;/code&gt; 越界访存（&lt;code&gt;name&lt;/code&gt; 的大小由 &lt;code&gt;size&lt;/code&gt; 说明）。返回值是拷贝的字符数。如果 &lt;code&gt;size&lt;/code&gt; 小于需要的空间，则返回“-1”，并置 errno 为 EINVAL。&lt;/p&gt;
&lt;p&gt;也是在 &lt;code&gt;kernal/who.c&lt;/code&gt; 中实现。&lt;/p&gt;
&lt;h3 id=&quot;3-测试程序&quot;&gt;&lt;a href=&quot;#3-测试程序&quot; class=&quot;headerlink&quot; title=&quot;3. 测试程序&quot;&gt;&lt;/a&gt;3. 测试程序&lt;/h3&gt;&lt;p&gt;运行添加过新系统调用的 Linux 0.11，在其环境下编写两个测试程序 iam.c 和 whoami.c。最终的运行结果是：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ./iam lizhijun&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ./whoami&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lizhijun&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;系统调用简介&quot;&gt;&lt;a href=&quot;#系统调用简介&quot; class=&quot;headerlink&quot; title=&quot;系统调用简介&quot;&gt;&lt;/a&gt;系统调用简介&lt;/h2&gt;&lt;p&gt;系统调用和一般的函数调用在使用方式上没有区别，区别在于调用之后函数内部如何处理。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="https://haohuaijin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>华为云ubuntu配置nginx踩坑记录</title>
    <link href="https://haohuaijin.github.io/2020/09/06/%E5%8D%8E%E4%B8%BA%E4%BA%91ubuntu%E9%85%8D%E7%BD%AEnginx%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://haohuaijin.github.io/2020/09/06/%E5%8D%8E%E4%B8%BA%E4%BA%91ubuntu%E9%85%8D%E7%BD%AEnginx%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2020-09-06T00:46:41.000Z</published>
    <updated>2020-09-06T01:29:11.830Z</updated>
    
    <content type="html"><![CDATA[<p>服务器：华为云<br>操作系统： ubuntu 18.04<br>今天在华为云上配置nginx发现怎么也配置不成功，<strong>不能在浏览器上访问，同时也ping不通，不过在云服务器上的nginx是成功运行的。</strong></p><p>最后终于找到了解决办法，更改华为云的安全组配置，配置80端口，同时将它设置下面的内容，如图</p><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/华为云.png" width="700"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;服务器：华为云&lt;br&gt;操作系统： ubuntu 18.04&lt;br&gt;今天在华为云上配置nginx发现怎么也配置不成功，&lt;strong&gt;不能在浏览器上访问，同时也ping不通，不过在云服务器上的nginx是成功运行的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后终于找到了解决办法，更
      
    
    </summary>
    
    
    
      <category term="踩坑" scheme="https://haohuaijin.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>macos vim 进入可视块模式</title>
    <link href="https://haohuaijin.github.io/2020/08/08/macos-vim-%E8%BF%9B%E5%85%A5%E5%8F%AF%E8%A7%86%E5%9D%97%E6%A8%A1%E5%BC%8F/"/>
    <id>https://haohuaijin.github.io/2020/08/08/macos-vim-%E8%BF%9B%E5%85%A5%E5%8F%AF%E8%A7%86%E5%9D%97%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-08-08T14:43:16.000Z</published>
    <updated>2020-08-08T14:55:03.515Z</updated>
    
    <content type="html"><![CDATA[<p>在windows的vim上进入vim的块模式是<code>&lt;ctrl&gt;-v</code>。于是我以为在mac上应该是<code>&lt;command&gt;-v</code> ，试了试发现<code>&lt;command&gt;-v</code>是粘贴。然后去google搜索发现没有具体讲这个的，在这里记录一下。</p><p><strong>在macos中使用<code>&lt;control&gt;-v</code>就可以进入vim的块模式(列选择)。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在windows的vim上进入vim的块模式是&lt;code&gt;&amp;lt;ctrl&amp;gt;-v&lt;/code&gt;。于是我以为在mac上应该是&lt;code&gt;&amp;lt;command&amp;gt;-v&lt;/code&gt; ，试了试发现&lt;code&gt;&amp;lt;command&amp;gt;-v&lt;/code&gt;是粘贴。然后
      
    
    </summary>
    
    
    
      <category term="vim" scheme="https://haohuaijin.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>matlab for mac 打开cftool卡死解决方案</title>
    <link href="https://haohuaijin.github.io/2020/08/01/matlab-for-mac-%E6%89%93%E5%BC%80cftool%E5%8D%A1%E6%AD%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://haohuaijin.github.io/2020/08/01/matlab-for-mac-%E6%89%93%E5%BC%80cftool%E5%8D%A1%E6%AD%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2020-08-01T00:53:57.000Z</published>
    <updated>2020-08-01T01:17:44.620Z</updated>
    
    <content type="html"><![CDATA[<p>在mac上安装完matlab后，想试一试cftool的打开速度，结果一打开cftool就卡死了，然后去网上找了许多的资料，多没有想到相关的信息。</p><p>最后在matlab中文论坛发现有人在用matlab仿真时死机，解决方案是<strong>magnet对matlab仅用</strong>。于是我就试了试，成功解决问题。</p><p>如果你也有类似的问题，不妨试一试把Magnet对matlab禁用。</p><p>原地址：<a href="https://www.ilovematlab.cn/thread-579451-1-1.html" target="_blank" rel="noopener">https://www.ilovematlab.cn/thread-579451-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在mac上安装完matlab后，想试一试cftool的打开速度，结果一打开cftool就卡死了，然后去网上找了许多的资料，多没有想到相关的信息。&lt;/p&gt;
&lt;p&gt;最后在matlab中文论坛发现有人在用matlab仿真时死机，解决方案是&lt;strong&gt;magnet对matlab
      
    
    </summary>
    
    
    
      <category term="bugs" scheme="https://haohuaijin.github.io/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>遗传算法学习笔记</title>
    <link href="https://haohuaijin.github.io/2020/07/30/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://haohuaijin.github.io/2020/07/30/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-30T01:45:58.000Z</published>
    <updated>2020-08-01T01:14:32.125Z</updated>
    
    <content type="html"><![CDATA[<p>遗传算法是一种启发式的优化算法，具有很大的灵活性。之所以较遗传算法，这要是因为算法的过程模拟了自然选择。遗传算法的应用领域非常的广，适用于复杂的问题，同时还具有很大的灵活性，可以自主设计很多算子。</p><p>下面介绍遗传算法的主要流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">初始化种群</span><br><span class="line">计算种群的适应度和累积概率</span><br><span class="line">while iter &lt; itermax:</span><br><span class="line">复制 //剔除适应度低的，将适应度好的复制一份</span><br><span class="line">交叉 //二进制数字位数交换</span><br><span class="line">变异 //二进制位数取否</span><br><span class="line">重新计算适应度和累积概率</span><br><span class="line">end</span><br><span class="line">解码输出结果</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h2><p>编码的主要方式有<strong>二进制码，实数码和格雷码</strong>。一般用二进制来编码。在这一阶段是将一个变量或多个变量，根据其约束的定义域以及我们要得到的自变量的精度，选择合适的二进制位数将问题编码。例如变量$x$的区间是$(L,U)$，要求的精度是小数点后四位，也就意味着每个变量应该被分成至少$(L,U)\times 10^4$个部分，对一个变量的二进制数串位数用以下公式计算：<br>$$<br>2^{m_j-1} &lt; (U-L)\times 10^4 \le 2^{m_j}-1<br>$$<br>如果是多个变量的话，可以将他们各自编码后，连在一起。</p><p>解码的话使用下面的公式：<br>$$<br>x = L + \left( \sum_{i=1}^{k}b_i2^{i-1}\right)\cfrac{U-L}{2^k-1}<br>$$</p><h2 id="2-评价个体的适应度"><a href="#2-评价个体的适应度" class="headerlink" title="2. 评价个体的适应度"></a>2. 评价个体的适应度</h2><p>这里的适应度函数对应于自然选择，我们需要根据自己的实际问题来设定适应度函数，适应度函数的目的是，将种群中好的和差的区分开来。例如在求函数最大值的时候，适应度函数就是函数本身。下面是步骤：</p><ol><li>计算染色体$U_k$的适应度值</li></ol><p>$$<br>eval(U_k) = f(x^k),\quad k = 1,2,···<br>$$</p><ol start="2"><li>计算种群的适应度总和</li></ol><p>$$<br>F = \sum_{k=1}^{n}eval(U_k)<br>$$</p><ol start="3"><li>计算每个染色体被复制的概率</li></ol><p>$$<br>P_k = \cfrac{eval(U_k)}{F}<br>$$</p><ol start="4"><li>计算每个染色体被复制的累积概率</li></ol><p>$$<br>Q_k = \sum_{j-1}^kP_k<br>$$</p><h2 id="3-新种群复制"><a href="#3-新种群复制" class="headerlink" title="3. 新种群复制"></a>3. 新种群复制</h2><p>可以有好几种方法，常见的是根据前面计算的累积概率$Q_k$，利用计算机随机生成<code>0-1</code>的随机数，看看随机数落到那个区间里面，取区间右边那个累积概率对应的$k$值，复制个体。</p><p>举个例子现在有四个个体他们的累积概率是<code>0.2</code>，<code>0.3</code>，<code>0.5</code>，<code>1.0</code>。假设现在生成了个随机数为<code>0.4</code>，他现在是落在了<code>0.3-0.5</code>的区间里，所以我们将右侧的<code>0.5</code>复制一遍。</p><h2 id="4-种群的交配和变异"><a href="#4-种群的交配和变异" class="headerlink" title="4. 种群的交配和变异"></a>4. 种群的交配和变异</h2><p>和染色体的交换类似，<strong>交配</strong>就是在两个二进制数中选取一位，然后将他们后面的所有为进行交换。</p><p><strong>变异</strong>是将二进制数，其中的一位取否。</p><h2 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h2><p>将上面的过程不断的重复，直到最大的迭代次数或者种群不在进化。</p><p>在遗传算法中，我认为比较重要的几个方面是，</p><ul><li><strong>适应度函数的确定</strong>，面对实际问题时我们要设计适应度函数往往与实验相结合(假死酵母菌)。同时在遗传算法不同的阶段使用不同的适应度函数，回去的不同的效果。</li><li><strong>各种算子的设计</strong>，在我们进行遗传算法的过程中，现在已经有的算子有复制，交叉，变异等等，算子应该满足的条件是<strong>稳定，可变</strong>。我们可以根据不同的问题设计不同的算子。</li></ul><h2 id="6-应用"><a href="#6-应用" class="headerlink" title="6. 应用"></a>6. 应用</h2><ul><li>假丝酵母菌求解最优的浓度。</li><li>我的想法是将遗传算法，用来求解神经网络的参数。</li><li>各种复杂的，非线性的优化问题。</li></ul><h2 id="7-代码"><a href="#7-代码" class="headerlink" title="7. 代码"></a>7. 代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%主程序：用遗传算法求解y=200*exp(-0.05*x).*sin(x)在[-2 2]区间上的最大值</span></span><br><span class="line">clc;</span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line"><span class="keyword">global</span> BitLength</span><br><span class="line"><span class="keyword">global</span> boundsbegin</span><br><span class="line"><span class="keyword">global</span> boundsend</span><br><span class="line">bounds=[<span class="number">-2</span> <span class="number">2</span>];<span class="comment">%一维自变量的取值范围</span></span><br><span class="line">precision=<span class="number">0.0001</span>; <span class="comment">%运算精度</span></span><br><span class="line">boundsbegin=bounds(:,<span class="number">1</span>);</span><br><span class="line">boundsend=bounds(:,<span class="number">2</span>);</span><br><span class="line"><span class="comment">%计算如果满足求解精度至少需要多长的染色体</span></span><br><span class="line">BitLength=<span class="built_in">ceil</span>(<span class="built_in">log2</span>((boundsend-boundsbegin)' ./ precision));</span><br><span class="line">popsize=<span class="number">50</span>; <span class="comment">%初始种群大小</span></span><br><span class="line">Generationnmax=<span class="number">12</span>;  <span class="comment">%最大代数</span></span><br><span class="line">pcrossover=<span class="number">0.90</span>; <span class="comment">%交配概率</span></span><br><span class="line">pmutation=<span class="number">0.09</span>; <span class="comment">%变异概率</span></span><br><span class="line"><span class="comment">%产生初始种群</span></span><br><span class="line">population=<span class="built_in">round</span>(<span class="built_in">rand</span>(popsize,BitLength));</span><br><span class="line"><span class="comment">%计算适应度,返回适应度Fitvalue和累积概率cumsump</span></span><br><span class="line">[Fitvalue,cumsump]=fitnessfun(population);  </span><br><span class="line">Generation=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> Generation&lt;Generationnmax+<span class="number">1</span></span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="number">2</span>:popsize </span><br><span class="line">      <span class="comment">%选择操作</span></span><br><span class="line">      seln=selection(population,cumsump);</span><br><span class="line">      <span class="comment">%交叉操作</span></span><br><span class="line">      scro=crossover(population,seln,pcrossover);</span><br><span class="line">      scnew(<span class="built_in">j</span>,:)=scro(<span class="number">1</span>,:);</span><br><span class="line">      scnew(<span class="built_in">j</span>+<span class="number">1</span>,:)=scro(<span class="number">2</span>,:);</span><br><span class="line">      <span class="comment">%变异操作</span></span><br><span class="line">      smnew(<span class="built_in">j</span>,:)=mutation(scnew(<span class="built_in">j</span>,:),pmutation);</span><br><span class="line">      smnew(<span class="built_in">j</span>+<span class="number">1</span>,:)=mutation(scnew(<span class="built_in">j</span>+<span class="number">1</span>,:),pmutation);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   population=smnew;  <span class="comment">%产生了新的种群</span></span><br><span class="line">   <span class="comment">%计算新种群的适应度   </span></span><br><span class="line">   [Fitvalue,cumsump]=fitnessfun(population);</span><br><span class="line">   <span class="comment">%记录当前代最好的适应度和平均适应度</span></span><br><span class="line">   [fmax,nmax]=<span class="built_in">max</span>(Fitvalue);</span><br><span class="line">   fmean=<span class="built_in">mean</span>(Fitvalue);</span><br><span class="line">   ymax(Generation)=fmax;</span><br><span class="line">   ymean(Generation)=fmean;</span><br><span class="line">   <span class="comment">%记录当前代的最佳染色体个体</span></span><br><span class="line">   x=transform2to10(population(nmax,:));</span><br><span class="line">   <span class="comment">%自变量取值范围是[-2 2],需要把经过遗传运算的最佳染色体整合到[-2 2]区间</span></span><br><span class="line">   xx=boundsbegin+x*(boundsend-boundsbegin)/(power((boundsend),BitLength)<span class="number">-1</span>);</span><br><span class="line">   xmax(Generation)=xx;</span><br><span class="line">   Generation=Generation+<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Generation=Generation<span class="number">-1</span>;</span><br><span class="line">Bestpopulation=xx</span><br><span class="line">Besttargetfunvalue=targetfun(xx)</span><br><span class="line"></span><br><span class="line"><span class="comment">%绘制经过遗传运算后的适应度曲线。一般地，如果进化过程中种群的平均适应度与最大适</span></span><br><span class="line"><span class="comment">%应度在曲线上有相互趋同的形态，表示算法收敛进行得很顺利，没有出现震荡；在这种前</span></span><br><span class="line"><span class="comment">%提下，最大适应度个体连续若干代都没有发生进化表明种群已经成熟。</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">hand1=<span class="built_in">plot</span>(<span class="number">1</span>:Generation,ymax);</span><br><span class="line">set(hand1,<span class="string">'linestyle'</span>,<span class="string">'-'</span>,<span class="string">'linewidth'</span>,<span class="number">1.8</span>,<span class="string">'marker'</span>,<span class="string">'*'</span>,<span class="string">'markersize'</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">hand2=<span class="built_in">plot</span>(<span class="number">1</span>:Generation,ymean);</span><br><span class="line">set(hand2,<span class="string">'color'</span>,<span class="string">'r'</span>,<span class="string">'linestyle'</span>,<span class="string">'-'</span>,<span class="string">'linewidth'</span>,<span class="number">1.8</span>,...</span><br><span class="line"><span class="string">'marker'</span>,<span class="string">'h'</span>,<span class="string">'markersize'</span>,<span class="number">6</span>)</span><br><span class="line">xlabel(<span class="string">'进化代数'</span>);ylabel(<span class="string">'最大/平均适应度'</span>);xlim([<span class="number">1</span> Generationnmax]);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'最大适应度'</span>,<span class="string">'平均适应度'</span>);</span><br><span class="line">box off;<span class="built_in">hold</span> off;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遗传算法是一种启发式的优化算法，具有很大的灵活性。之所以较遗传算法，这要是因为算法的过程模拟了自然选择。遗传算法的应用领域非常的广，适用于复杂的问题，同时还具有很大的灵活性，可以自主设计很多算子。&lt;/p&gt;
&lt;p&gt;下面介绍遗传算法的主要流程：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;初始化种群&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;计算种群的适应度和累积概率&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while iter &amp;lt; itermax:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	复制 //剔除适应度低的，将适应度好的复制一份&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	交叉 //二进制数字位数交换&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	变异 //二进制位数取否&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	重新计算适应度和累积概率&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解码输出结果&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="数学建模" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之运输层</title>
    <link href="https://haohuaijin.github.io/2020/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>https://haohuaijin.github.io/2020/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2020-07-07T03:23:49.000Z</published>
    <updated>2020-09-06T01:28:34.294Z</updated>
    
    <content type="html"><![CDATA[<p>这里主要讲的是在运输层几个比较重要的技术，即多路分解和复用，可靠数据传输原理和拥塞原理。</p><h2 id="1-多路复用-分解"><a href="#1-多路复用-分解" class="headerlink" title="1. 多路复用/分解"></a>1. 多路复用/分解</h2><p>先给出官方定义，将主机间交付扩展到进程间交付被称为<strong>运输层的多路复用和分解</strong>。<strong>多路分解</strong>就是在运输层接收到来自网络层数据后，根据运输层报文特殊字段的信息，将运输层报文段的数据交付到正确的套接字中。<strong>多路复用</strong>就是在运输层接受到<strong>套接字</strong>数据后，根据套接字的不同，生成<strong>运输层报文特殊字段</strong>(用于分解)，然后将报文发送到网络层。通俗来说，多路复用和分解可以让<strong>不同进程的报文</strong>来使用<strong>相同的运输层协议</strong>(TCP，UDP)运输报文。</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/多路复用分解.png" width="600"></center><p>如图，运输层通过多路复用和分解，实现数据的正确交付。</p><p>下面这句话引用自计算机网络自顶向下方法，可以加深我们的理解：</p><blockquote><p>尽管我们在因特网运输层协议的环境下引入了多路复用和多路分解，认识到下列事实是重要的：</p><p>他们与在某层(在运输层或别处)的单一协议何时被位于接下来的较高层的多个协议使用有关。</p></blockquote><h5 id="那么如何实现多路复用和分解呢？"><a href="#那么如何实现多路复用和分解呢？" class="headerlink" title="那么如何实现多路复用和分解呢？"></a>那么如何实现多路复用和分解呢？</h5><a id="more"></a><p>需要两个条件：</p><ol><li>每个套接字有唯一的<strong>标识符</strong>(也就是<strong>端口号</strong>)</li><li>也就是前面讲的，运输层报文的特殊字段(<strong>包含源端口号和目的端口号</strong>)</li></ol><p>根据运输层协议的不同，UDP和TCP的报文中的特殊字段不同。</p><p><strong>补充：</strong></p><ol><li><strong>套接字接口</strong>的作用，把来自进程的数据传输到运输层，并且把来自运输层的数据传送的特定的进程。</li><li>每一个套接字分配一个<strong>端口号</strong>用来作为套接字的标识符。</li><li>运输层报文的格式基本如下所示：</li></ol><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/运输层报文格式.png" width="350"></center><p>下面具体讲一下UDP和TCP的多路复用和分解。</p><h3 id="1-1-UDP的多路复用-分解"><a href="#1-1-UDP的多路复用-分解" class="headerlink" title="1.1 UDP的多路复用/分解"></a>1.1 UDP的多路复用/分解</h3><p>在UDP中一个套接字是由一个二元组全面标识的，二元组中包含了一个<strong>目的IP地址和目的端口号</strong>。</p><p>举个例子：假设现在有A，B，C三个主机，A和B同时通过2333端口号与C主机的3333端口号通信，这是A和B的目的端口号都是3333，所以他们<strong>通过相同的套接字进入相同的进程</strong>。这里的源端口号是用来从C向A，B发送报文时使用的。</p><h3 id="1-2-TCP的多路复用-分解"><a href="#1-2-TCP的多路复用-分解" class="headerlink" title="1.2 TCP的多路复用/分解"></a>1.2 TCP的多路复用/分解</h3><p>TCP中的一个套接字是有四元组标识的，即<strong>目的IP地址，目的端口号，源IP地址和源端口号</strong>。</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/TCP多路复用.png" width="700"></center><p>如图很好展示了TCP如何来识别套接字。</p><h2 id="2-可靠数据传输原理"><a href="#2-可靠数据传输原理" class="headerlink" title="2. 可靠数据传输原理"></a>2. 可靠数据传输原理</h2><p>首先要明确，我们真实的网络环境会发生<strong>比特差错</strong>和<strong>丢包的</strong>。</p><p>可靠数据传输主要包含以下几个技术，差错检验，肯定确认(ACK)，序号，定时器，回退N步，累计确认，选择确认等等。</p><p><strong>注意：</strong> 我这里讲的是，可靠数据传输用到的一些技术方法，并没有具体TCP或UDP报文。</p><p>下面分别介绍上面的技术:</p><h3 id="2-1-差错检验"><a href="#2-1-差错检验" class="headerlink" title="2.1 差错检验"></a>2.1 差错检验</h3><p>差错检验用来检测报文在传输的过程中有没有发生错误，具体的方法还没学到。</p><h3 id="2-2-肯定确认ACK-positive-Acknowledgment-和否定确认-NAK"><a href="#2-2-肯定确认ACK-positive-Acknowledgment-和否定确认-NAK" class="headerlink" title="2.2 肯定确认ACK(positive Acknowledgment)和否定确认(NAK)"></a>2.2 肯定确认ACK(positive Acknowledgment)和否定确认(NAK)</h3><p>简单地说，就是接受端每当收到一个<strong>正确报文</strong>，就发送一个<strong>ACK</strong>来告诉发送端他收到了。而如果报文在运输的过程中出现了错误(比如差错检验没通过)，这时接收端就会<strong>丢弃刚刚收到的报文</strong>，并且发送一个<strong>NAK</strong>来告诉发送端重新发送上一个报文。</p><p><strong>注意:</strong>  由于我们真实的网络环境是会发生<strong>比特差错的</strong>，所以ACK和NAK也会发生错误。举个例子，现在 接收端正确收到了报文A，并且发送了一个ACK，不过由于传输中发生了错误，<strong>ACK变成了NAK</strong>。这时接受端收到了错误的ACK，由于不确定，发送端会重新发送上一个报文，但是这时接受端<strong>已经正确接受到了报文</strong>，所以接受端再次接受的正确的报文A时，接受端就发生了冗余(他自己没办法判断是不是冗余)。解决这个问题这个问题的方法就是接下来要讲的序号。</p><h3 id="2-3-序号"><a href="#2-3-序号" class="headerlink" title="2.3 序号"></a>2.3 序号</h3><p>序号就是给每一个发送报文附上一个<strong>递增的序号</strong>，同时返回的ACK上也包含这个序号，表示此序号的确认。通过序号就可以完美的解决2.2出现的问题，<strong>根据序号的不同</strong>接受端就可以准确的判断报文是不是相同。</p><p>在TCP中，初始序号是由计算随机计生成，而返回的ACK的序号是<strong>报文的编号</strong>加上<strong>报文数据部分的字节数</strong>。分送端第二次发送的报文的编号，则是由上一次的ACK指定。</p><p>其实，我们现在可以只用ACK来确认，在接受端收到<strong>受损报文</strong>后，发送上一个报文ACK，当接收端再一次收到ACK时(<strong>冗余ACK，对一个报文的ACK接收端到多次ACK</strong>)，他就知到报文受损了，所以他重新发送报文。下面只使用ACK。</p><h3 id="2-4-定时器"><a href="#2-4-定时器" class="headerlink" title="2.4 定时器"></a>2.4 定时器</h3><p>定时器的设定是因为在真实的网络环境中，会出现<strong>丢包</strong>的情况。</p><p>举个例子，假设现在发送端向接受端发送了一个报文A，考虑一下两种情况：</p><ol><li>报文A，在发送的途中丢失了</li><li>接受端收到了报文了，但是返回的ACK丢失了</li></ol><p>以上的情况都会导致发送端收不到ACK，于是我们可以设定一个<strong>定时器</strong>和一个<strong>超时间隔</strong>，当发送方在指定的超时间隔内没有收到ACK后，发送端就<strong>重新发送报文A</strong>。</p><h3 id="2-5-流水线技术"><a href="#2-5-流水线技术" class="headerlink" title="2.5 流水线技术"></a>2.5 流水线技术</h3><p>到现在为止，我们讨论的运输都是发送一个数据，返回一个ACK，然后在发送一个数据，这样的方式叫做<strong>停等协议</strong>。但是如果数据运输的时间比较长的话，停等协议的信道利用率是非常低的。所以引入了<strong>流水线协议</strong>，即一次可以发送多个报文。如图a是停等协议，图b是流水线协议。</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/流水线1.png" width="350"></center><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/流水线2.png" width="350"></center><p>使用流水线协议会带来以下的影响(参考Top-Down，这里的逻辑我没怎么理清)：</p><ol><li><strong>必须增加序号的范围</strong>，因为每个输送中的的分组(不计算重传的)必须有一个唯一的序号，而且有多个在输送中的未确认报文。</li><li><strong>协议的发送方和接收方两端也许不得不缓存多个分组</strong>。发送方最低限应当能缓冲哪些已发送但未确认的分组，如下面们讨论的那样，接收方或许也需要缓存那些以正确接受的分组。</li><li>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失，损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是：<strong>回退N步</strong>(Go-Back-N，GBN)和<strong>选择重传</strong>(Selective Repeat，SR)。</li></ol><h3 id="2-6-回退N步"><a href="#2-6-回退N步" class="headerlink" title="2.6 回退N步"></a>2.6 回退N步</h3><p>流水线技术，可以使我们不用等待<strong>上一个发送报文ACK</strong>，就可以发送新的报文。但是我们不能无限制的发送新报文，所以规定了一个数字N(也叫窗口长度，把N个报文称为<strong>窗口</strong>)，作为最大的<strong>已发送还未确认报文</strong>的数目。如图</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/回退N步.png" width="800"></center><p><strong>发送端的功能：</strong></p><ol><li>接受上层的调用</li><li>发送数据时，<strong>已发送还未确认的报文</strong>最多不超过N。只有当现在的报文被确认后才能发送新的报文(在图上的表现就是，把窗口右移)。</li><li><strong>超时后</strong>，把现在窗口中所有的报文所有的<strong>已经发送还未确认的报文</strong>重新发送一遍。</li></ol><p><strong>接收端的功能：</strong></p><ol><li>接收到的报文序号正确时，发送一个ACK。</li><li>接收到的报文序号不正确时，不发送ACK。</li><li>采取<strong>累计确认</strong>的方法，即ACK是对他以及他之前所有报文的确认。</li></ol><p>如图下面的窗口的大小为4，当出现超时后，发送端重新发送所有的报文。</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/回退N步演示.png" width="500"></center><h3 id="2-7-选择重传"><a href="#2-7-选择重传" class="headerlink" title="2.7 选择重传"></a>2.7 选择重传</h3><p>GBN可以提高信道的利用率，但是它也会到来一些问题。当窗口的长度N比较大的时候，前面报文的丢失会导致后面所有报文的重传，这样显然效率不高。于是有了选择重传。</p><p>选择重传就是接受端将那些失序到达的报文，接受并且发送一个ACK。所以他采取的不是累计确认，而是一个ACK确认一个报文。在发送端只有接收到每一个发送报文的ACK，才确切的知道报文已经发送。下面描述发送端，和接收端的功能。</p><p><strong>发送端：</strong></p><ol><li>接受上层的调用</li><li>发送端维护一个大小N的窗口(<strong>从第一个发送未确认报文开始，大小为N</strong>)，第一个报文接受的ACK是窗口右移。</li><li>超时时，发送端重新发送窗口N中，那些<strong>发送但未确认的报文</strong>。</li></ol><p><strong>接收端：</strong></p><ol><li>只要有报文到达，就发送ACK。</li></ol><p>如图展示了选择重传协议的作用：</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/选择重传.png" width="600"></center><h2 id="3-拥塞控制原理"><a href="#3-拥塞控制原理" class="headerlink" title="3. 拥塞控制原理"></a>3. 拥塞控制原理</h2><p>拥塞控制主要有两种方法：</p><ol><li><strong>端到端的拥塞控制</strong>，在运输层实现，TCP的拥塞控制。</li><li><strong>网络辅助的拥塞控制</strong>，路由器向发送方提供关于网络的拥塞情况。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里主要讲的是在运输层几个比较重要的技术，即多路分解和复用，可靠数据传输原理和拥塞原理。&lt;/p&gt;
&lt;h2 id=&quot;1-多路复用-分解&quot;&gt;&lt;a href=&quot;#1-多路复用-分解&quot; class=&quot;headerlink&quot; title=&quot;1. 多路复用/分解&quot;&gt;&lt;/a&gt;1. 多路复用/分解&lt;/h2&gt;&lt;p&gt;先给出官方定义，将主机间交付扩展到进程间交付被称为&lt;strong&gt;运输层的多路复用和分解&lt;/strong&gt;。&lt;strong&gt;多路分解&lt;/strong&gt;就是在运输层接收到来自网络层数据后，根据运输层报文特殊字段的信息，将运输层报文段的数据交付到正确的套接字中。&lt;strong&gt;多路复用&lt;/strong&gt;就是在运输层接受到&lt;strong&gt;套接字&lt;/strong&gt;数据后，根据套接字的不同，生成&lt;strong&gt;运输层报文特殊字段&lt;/strong&gt;(用于分解)，然后将报文发送到网络层。通俗来说，多路复用和分解可以让&lt;strong&gt;不同进程的报文&lt;/strong&gt;来使用&lt;strong&gt;相同的运输层协议&lt;/strong&gt;(TCP，UDP)运输报文。&lt;/p&gt;
&lt;center class=&quot;third&quot;&gt;
    &lt;img src=&quot;https://gitee.com/Hao-132/blogimage/raw/master/img/多路复用分解.png&quot; width=&quot;600&quot;&gt;
&lt;/center&gt;

&lt;p&gt;如图，运输层通过多路复用和分解，实现数据的正确交付。&lt;/p&gt;
&lt;p&gt;下面这句话引用自计算机网络自顶向下方法，可以加深我们的理解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;尽管我们在因特网运输层协议的环境下引入了多路复用和多路分解，认识到下列事实是重要的：&lt;/p&gt;
&lt;p&gt;他们与在某层(在运输层或别处)的单一协议何时被位于接下来的较高层的多个协议使用有关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;那么如何实现多路复用和分解呢？&quot;&gt;&lt;a href=&quot;#那么如何实现多路复用和分解呢？&quot; class=&quot;headerlink&quot; title=&quot;那么如何实现多路复用和分解呢？&quot;&gt;&lt;/a&gt;那么如何实现多路复用和分解呢？&lt;/h5&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="https://haohuaijin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>7-11 Saving James Bond - Hard Version (30 分)</title>
    <link href="https://haohuaijin.github.io/2019/11/05/7-11%20Saving%20James%20Bond%20-%20Hard%20Version%20(30%20%E5%88%86)/"/>
    <id>https://haohuaijin.github.io/2019/11/05/7-11%20Saving%20James%20Bond%20-%20Hard%20Version%20(30%20%E5%88%86)/</id>
    <published>2019-11-05T09:40:31.000Z</published>
    <updated>2019-11-05T09:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>原题链接：<a href="https://pintia.cn/problem-sets/16/problems/673" target="_blank" rel="noopener">https://pintia.cn/problem-sets/16/problems/673</a><br>这道题本质是就是一道BFS，只不过要加上路径。<br>&emsp;开始做的时候比较顺利，但是总是有一个测试点没过去，找了半天还是找不到错误。于是google一下，发现是没仔细看题。<br>&emsp;题目中说，当有<strong>多条最短路径时，选择第一跳最短的</strong>。我竟然么看见(😭😭找了两个多小时)。处理第一条最短，比较简单的做法时我们在用BFS，一开始把鳄鱼入队时，就把顺序排好，这样出来的一定是最终的结果。</p><h6 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h6><p>在处理能不能在两个鳄鱼之间跳时，一是可以先计算好能不能跳，然后直接在BFS里用结果。二是在BFS的过程中，判断能不能跳。<br>其实我个人比较推荐第二种，没必要先计算好，现算现用就行。不过如果计算的结构要多次使用的话，保存下来了比较好。</p><a id="more"></a><h6 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INFO = <span class="number">1000000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> X,Y;</span><br><span class="line">    Node() &#123;&#125; <span class="comment">//用来不初始化定义Ver[101]</span></span><br><span class="line">    Node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y) : X(_x),Y(_y) &#123;&#125; <span class="comment">//用来提供X和Y的初始值</span></span><br><span class="line">&#125;Ver[MAX];</span><br><span class="line"><span class="keyword">int</span> Path[MAX]; <span class="comment">//记录路径</span></span><br><span class="line"><span class="keyword">int</span> N,D;</span><br><span class="line"><span class="keyword">bool</span> book[MAX]; <span class="comment">//记录是否访问</span></span><br><span class="line"><span class="keyword">int</span> last = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsVertexJump</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123; <span class="comment">//能不能从a到b</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">pow</span>(Ver[a].X-Ver[b].X,<span class="number">2</span>) + <span class="built_in">pow</span>(Ver[a].Y-Ver[b].Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsSave</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; <span class="comment">//a能不能到岸</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">pow</span>(Ver[a].X,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D,<span class="number">2</span>) || <span class="built_in">pow</span>(Ver[a].Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D,<span class="number">2</span>) || \</span><br><span class="line">        <span class="built_in">pow</span>(<span class="number">100</span>-Ver[a].X,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D,<span class="number">2</span>) || <span class="built_in">pow</span>(<span class="number">100</span>-Ver[a].Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsCenterJump</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; <span class="comment">//能不能从中心跳出</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pow</span>(Ver[a].X<span class="number">-50</span>,<span class="number">2</span>) + <span class="built_in">pow</span>(Ver[a].Y<span class="number">-50</span>,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D + <span class="number">7.5</span>,<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">pow</span>(Ver[a].X<span class="number">-50</span>,<span class="number">2</span>) + <span class="built_in">pow</span>(Ver[a].Y<span class="number">-50</span>,<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//排序的比较函数</span></span><br><span class="line">    <span class="keyword">return</span> IsCenterJump(x)&lt;IsCenterJump(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Save007</span><span class="params">()</span></span>&#123; <span class="comment">//无权图单源最短路</span></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> b[MAX]; <span class="comment">//用来把第一跳排序</span></span><br><span class="line">    <span class="built_in">fill</span>(Path, Path+N+<span class="number">1</span>, INFO);</span><br><span class="line">    <span class="built_in">fill</span>(book, book+N+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    Path[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    book[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(IsSave(<span class="number">0</span>))&#123;</span><br><span class="line">        last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123; <span class="comment">//对第一跳排序</span></span><br><span class="line">        b[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b+<span class="number">1</span>,b+N+<span class="number">1</span>,cmp); <span class="comment">//why 第二个是N + 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123; <span class="comment">//按靠近center的顺序，放入queue</span></span><br><span class="line">        <span class="keyword">if</span>(IsCenterJump(b[i]))&#123;</span><br><span class="line">            q.push(b[i]);</span><br><span class="line">            Path[b[i]] = <span class="number">0</span>;</span><br><span class="line">            book[b[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        temp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(IsSave(temp))&#123; <span class="comment">//能不能到岸</span></span><br><span class="line">            last = temp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!book[i] &amp;&amp; IsVertexJump(temp,i))&#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">                Path[i] = temp;</span><br><span class="line">                book[i] = <span class="literal">true</span>; <span class="comment">//在入队时就book</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> a[MAX]; <span class="comment">//记录最短路径</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Ver[<span class="number">0</span>] = Node(<span class="number">50</span>,<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;D);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        Ver[i] = Node(x+<span class="number">50</span>,y+<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Save007();</span><br><span class="line">    <span class="keyword">if</span>(last == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);<span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(last &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            a[count++] = last;</span><br><span class="line">            last = Path[last];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,count+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=count<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,Ver[a[i]].X<span class="number">-50</span>,Ver[a[i]].Y<span class="number">-50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原题链接：&lt;a href=&quot;https://pintia.cn/problem-sets/16/problems/673&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pintia.cn/problem-sets/16/problems/673&lt;/a&gt;&lt;br&gt;这道题本质是就是一道BFS，只不过要加上路径。&lt;br&gt;&amp;emsp;开始做的时候比较顺利，但是总是有一个测试点没过去，找了半天还是找不到错误。于是google一下，发现是没仔细看题。&lt;br&gt;&amp;emsp;题目中说，当有&lt;strong&gt;多条最短路径时，选择第一跳最短的&lt;/strong&gt;。我竟然么看见(😭😭找了两个多小时)。处理第一条最短，比较简单的做法时我们在用BFS，一开始把鳄鱼入队时，就把顺序排好，这样出来的一定是最终的结果。&lt;/p&gt;
&lt;h6 id=&quot;思路：&quot;&gt;&lt;a href=&quot;#思路：&quot; class=&quot;headerlink&quot; title=&quot;思路：&quot;&gt;&lt;/a&gt;思路：&lt;/h6&gt;&lt;p&gt;在处理能不能在两个鳄鱼之间跳时，一是可以先计算好能不能跳，然后直接在BFS里用结果。二是在BFS的过程中，判断能不能跳。&lt;br&gt;其实我个人比较推荐第二种，没必要先计算好，现算现用就行。不过如果计算的结构要多次使用的话，保存下来了比较好。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="BFS" scheme="https://haohuaijin.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>7-10 Saving James Bond - Easy Version (25分)</title>
    <link href="https://haohuaijin.github.io/2019/11/02/7-10-Saving%20James-Bond-Easy-Version-25%E5%88%86/"/>
    <id>https://haohuaijin.github.io/2019/11/02/7-10-Saving%20James-Bond-Easy-Version-25%E5%88%86/</id>
    <published>2019-11-02T07:59:34.000Z</published>
    <updated>2019-11-02T08:01:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个题主要是审好题目，做起来就简单了。<br>下面有两种方法：</p><h3 id="一、先将是不是有边，是否与岸有连接算出来"><a href="#一、先将是不是有边，是否与岸有连接算出来" class="headerlink" title="一、先将是不是有边，是否与岸有连接算出来"></a>一、先将是不是有边，是否与岸有连接算出来</h3><p><strong>步骤：</strong><br>1、读入数据，计算输入点是不是可以到岸。<br>2、对权值初始化，计算各点之间是不是有线。<br>3、一次DFS搜索，看看是不是能从中心到岸边。</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">101</span>]; <span class="comment">//是否访问</span></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Flee[<span class="number">101</span>]; <span class="comment">//是否可以逃跑</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INFO = <span class="number">100000</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> G[][<span class="number">101</span>],<span class="keyword">int</span> Nv)</span></span>&#123;</span><br><span class="line">    book[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(Flee[i] == <span class="number">1</span>) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= Nv;j++)&#123; <span class="comment">//注意一共Nv+1个点</span></span><br><span class="line">        <span class="keyword">if</span>(!book[j] &amp;&amp; G[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">            DFS(j,G,Nv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> Nv; <span class="comment">//顶点数</span></span><br><span class="line">    <span class="keyword">int</span> X[<span class="number">101</span>],Y[<span class="number">101</span>]; <span class="comment">//顶点坐标</span></span><br><span class="line">    <span class="keyword">int</span> Dist; <span class="comment">//跳的最远距离</span></span><br><span class="line">    <span class="keyword">int</span> G[<span class="number">101</span>][<span class="number">101</span>]; <span class="comment">//是否有边</span></span><br><span class="line">    X[<span class="number">0</span>] = Y[<span class="number">0</span>] = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;Nv,&amp;Dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= Nv;i++)&#123; <span class="comment">//读入X，Y并计算能不能从哪里逃出</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        X[i] = x + <span class="number">50</span>;</span><br><span class="line">        Y[i] = y + <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pow</span>(Y[i],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>) || <span class="built_in">pow</span>(X[i],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>)||\</span><br><span class="line">            <span class="built_in">pow</span>(<span class="number">100</span>-Y[i],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>) || <span class="built_in">pow</span>(<span class="number">100</span>-X[i],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>))</span><br><span class="line">            Flee[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= Nv;i++)&#123; <span class="comment">//初始化权值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= Nv;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) G[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> G[i][j] = INFO;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pow</span>(X[i]-X[j],<span class="number">2</span>) + <span class="built_in">pow</span>(Y[i]-Y[j],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>))&#123;</span><br><span class="line">                G[i][j] = <span class="number">1</span>;</span><br><span class="line">                G[j][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= Nv;j++)&#123; <span class="comment">//中间有一个直径15的陆地</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pow</span>(X[<span class="number">0</span>]-X[j],<span class="number">2</span>) + <span class="built_in">pow</span>(Y[<span class="number">0</span>]-Y[j],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist+<span class="number">7.5</span>,<span class="number">2</span>))&#123;</span><br><span class="line">            G[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            G[j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(<span class="number">0</span>,G,Nv);</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、在线处理，是不是有边，是否到岸"><a href="#二、在线处理，是不是有边，是否到岸" class="headerlink" title="二、在线处理，是不是有边，是否到岸"></a>二、在线处理，是不是有边，是否到岸</h3><p><strong>思路：</strong><br>主要的思路就是用<strong>DFS</strong>，由于在湖中心时有一个平台，所以要进行特殊处理。<br>对于图的结构的选择，可以用也可以不用。图只是一个抽象的结构来帮助我们解题，怎么简单怎么写，不用拘泥于使用什么结构(比如邻接表，邻接矩阵，或者不用图的结构)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> X,Y;</span><br><span class="line">    <span class="keyword">bool</span> book;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsSave</span><span class="params">(Graph V,<span class="keyword">int</span> Dist)</span></span>&#123; <span class="comment">//能否到岸</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">pow</span>(V.X,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>) || <span class="built_in">pow</span>(V.Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>) || \</span><br><span class="line">        <span class="built_in">pow</span>(<span class="number">100</span>-V.X,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>) || <span class="built_in">pow</span>(<span class="number">100</span>-V.Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsCanJump</span><span class="params">(Graph V1,Graph V2,<span class="keyword">int</span> Dist)</span></span>&#123; <span class="comment">//能否从V1跳到V2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(V1.X-V2.X,<span class="number">2</span>) + <span class="built_in">pow</span>(V1.Y-V2.Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> Nv,<span class="keyword">int</span> Dist,Graph G[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> answer = <span class="literal">false</span>;</span><br><span class="line">    G[index].book = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(IsSave(G[index],Dist))&#123;</span><br><span class="line">        answer = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= Nv; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!G[i].book &amp;&amp; IsCanJump(G[index],G[i],Dist))&#123;</span><br><span class="line">                answer = DFS(i,Nv,Dist,G);</span><br><span class="line">                <span class="keyword">if</span>(answer == <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsCenterJump</span><span class="params">(Graph V,<span class="keyword">int</span> Dist)</span></span>&#123; <span class="comment">//计算从中心跳出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(V.X<span class="number">-50</span>,<span class="number">2</span>) + <span class="built_in">pow</span>(V.Y<span class="number">-50</span>,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist + <span class="number">7.5</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Save007</span><span class="params">(<span class="keyword">int</span> Nv,<span class="keyword">int</span> Dist,Graph G[])</span></span>&#123; <span class="comment">// 对起点特殊处理</span></span><br><span class="line">    <span class="keyword">bool</span> answer = <span class="literal">false</span>;</span><br><span class="line">    G[<span class="number">0</span>].book = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Nv; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!G[i].book &amp;&amp; IsCenterJump(G[i],Dist))&#123;</span><br><span class="line">            answer = DFS(i,Nv,Dist,G);</span><br><span class="line">            <span class="keyword">if</span>(answer == <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Nv,Dist,x,y;</span><br><span class="line">    <span class="keyword">int</span> answer;</span><br><span class="line">    Graph G[<span class="number">101</span>]; <span class="comment">//发生了一次运行时错误,指针越界</span></span><br><span class="line">    G[<span class="number">0</span>].X = G[<span class="number">0</span>].Y = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;Nv,&amp;Dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Nv; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        G[i].X = x + <span class="number">50</span>;</span><br><span class="line">        G[i].Y = y + <span class="number">50</span>;</span><br><span class="line">        G[i].book = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    answer = Save007(Nv,Dist,G);</span><br><span class="line">    <span class="keyword">if</span>(answer) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个题主要是审好题目，做起来就简单了。&lt;br&gt;下面有两种方法：&lt;/p&gt;
&lt;h3 id=&quot;一、先将是不是有边，是否与岸有连接算出来&quot;&gt;&lt;a href=&quot;#一、先将是不是有边，是否与岸有连接算出来&quot; class=&quot;headerlink&quot; title=&quot;一、先将是不是有边，是否与岸有连接算出来&quot;&gt;&lt;/a&gt;一、先将是不是有边，是否与岸有连接算出来&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;br&gt;1、读入数据，计算输入点是不是可以到岸。&lt;br&gt;2、对权值初始化，计算各点之间是不是有线。&lt;br&gt;3、一次DFS搜索，看看是不是能从中心到岸边。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DFS" scheme="https://haohuaijin.github.io/tags/DFS/"/>
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>7-6 列出连通集 (25分)</title>
    <link href="https://haohuaijin.github.io/2019/10/26/7-6-%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86-25%E5%88%86/"/>
    <id>https://haohuaijin.github.io/2019/10/26/7-6-%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86-25%E5%88%86/</id>
    <published>2019-10-26T12:04:11.000Z</published>
    <updated>2019-10-26T12:05:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要考察了DFS，和BFS的基本操作。考察我们对图的构建，以及运用DFS和BFS对图进行遍历。<br>DFS是运用了递归的思想，<br>而BFS则可以通过队列来实现。<br>我在做题时遇到的困难，主要是在<strong>BFS的思路</strong>和<strong>队列</strong>的实现上。因为队列原来以为很熟，但现在一写很多细节都忘了。<br><strong>所以数据结构要经常写，要不然忘得很快。</strong><br>下面是代码，可能有点冗杂。</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">Graph</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;</span><br><span class="line">    <span class="keyword">int</span> Ne;</span><br><span class="line">    <span class="keyword">int</span> Vertex[<span class="number">11</span>];</span><br><span class="line">    <span class="keyword">int</span> Edge[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">QNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    QNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QNode rear,front;</span><br><span class="line">&#125;*Queue;</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">11</span>]; <span class="comment">//纪录访问的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v1,v2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;G-&gt;Nv,&amp;G-&gt;Ne);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Nv;i++) G-&gt;Vertex[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Nv;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G-&gt;Nv;j++)</span><br><span class="line">            G-&gt;Edge[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Ne;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;v1,&amp;v2);</span><br><span class="line">        G-&gt;Edge[v1][v2] = <span class="number">1</span>;</span><br><span class="line">        G-&gt;Edge[v2][v1] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QNode <span class="title">CreateQNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QNode q = (QNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    q-&gt;Data = <span class="number">-1</span>;</span><br><span class="line">    q-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Queue <span class="title">CreateQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Queue q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    q-&gt;rear = q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(Queue Q,<span class="keyword">int</span> X)</span></span>&#123;</span><br><span class="line">    QNode q = CreateQNode();</span><br><span class="line">    q-&gt;Data = X;</span><br><span class="line">    q-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front == <span class="literal">NULL</span>)</span><br><span class="line">        Q-&gt;rear = Q-&gt;front = q;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q-&gt;rear-&gt;Next = q; <span class="comment">//使q成为最后一个元素</span></span><br><span class="line">        Q-&gt;rear = q; <span class="comment">//更新rear</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteQ</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear == Q-&gt;front)&#123; <span class="comment">//分类讨论</span></span><br><span class="line">        x = Q-&gt;front-&gt;Data;</span><br><span class="line">        Q-&gt;rear = Q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        QNode q = Q-&gt;front;</span><br><span class="line">        x = q-&gt;Data;</span><br><span class="line">        Q-&gt;front = q-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(book[i] == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        book[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G-&gt;Nv;j++)</span><br><span class="line">            <span class="keyword">if</span>(G-&gt;Edge[i][j] == <span class="number">1</span>) <span class="comment">//加不加book[j] == 0</span></span><br><span class="line">                DFS(G,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Queue Q,Graph G,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X;</span><br><span class="line">    AddQ(Q,i);</span><br><span class="line">    book[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(Q-&gt;front != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        X = DeleteQ(Q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>,X);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G-&gt;Nv;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(book[j] == <span class="number">0</span> &amp;&amp; G-&gt;Edge[j][X] == <span class="number">1</span>)&#123;</span><br><span class="line">                AddQ(Q,j);</span><br><span class="line">                book[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Graph G;</span><br><span class="line">    G = (Graph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GNode));</span><br><span class="line">    CreateGraph(G);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Nv;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(book[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&#123;"</span>);</span><br><span class="line">            DFS(G,i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" &#125;\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Nv;i++) book[i] = <span class="number">0</span>;</span><br><span class="line">    Queue Q = CreateQueue();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Nv;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(book[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&#123;"</span>);</span><br><span class="line">            BFS(Q,G,i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" &#125;\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要考察了DFS，和BFS的基本操作。考察我们对图的构建，以及运用DFS和BFS对图进行遍历。&lt;br&gt;DFS是运用了递归的思想，&lt;br&gt;而BFS则可以通过队列来实现。&lt;br&gt;我在做题时遇到的困难，主要是在&lt;strong&gt;BFS的思路&lt;/strong&gt;和&lt;strong&gt;队列&lt;/strong&gt;的实现上。因为队列原来以为很熟，但现在一写很多细节都忘了。&lt;br&gt;&lt;strong&gt;所以数据结构要经常写，要不然忘得很快。&lt;/strong&gt;&lt;br&gt;下面是代码，可能有点冗杂。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="DFS" scheme="https://haohuaijin.github.io/tags/DFS/"/>
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="BFS" scheme="https://haohuaijin.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>7-2 Reversing Linked List (25分)</title>
    <link href="https://haohuaijin.github.io/2019/10/13/7-2-Reversing-Linked-List-25%E5%88%86/"/>
    <id>https://haohuaijin.github.io/2019/10/13/7-2-Reversing-Linked-List-25%E5%88%86/</id>
    <published>2019-10-13T01:40:46.000Z</published>
    <updated>2019-10-13T01:45:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题可能一开始看题目一头雾水，但是仔细思考就会发现并不太难。<br>下面是我的思路：<br><strong>1、</strong>用类似静态链表的方法，来表示List，即一个数组存Data，一个数组存Next<br><strong>2、</strong>循环遍历链表，用<code>a[]</code>记录下标。<br><strong>3、</strong>根据K来转置链表，修改Next，然后转置<code>a[]</code>(<strong>顺序很重要</strong>)。</p><a id="more"></a><p><strong>AC代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> <span class="comment">//类此静态链表</span></span><br><span class="line">    <span class="keyword">int</span> Address,Next,Data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reavers</span><span class="params">(<span class="keyword">int</span> *front,<span class="keyword">int</span> *rear,<span class="keyword">int</span> k)</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,a[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> *p = front;p != rear+<span class="number">1</span>;p++)&#123; <span class="comment">//先储存</span></span><br><span class="line">        a[i++] = *p;</span><br><span class="line">    &#125; </span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> *p = rear;p != front<span class="number">-1</span>;p--)&#123; </span><br><span class="line">        *p = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first,total,k,count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">    List *p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;first,&amp;total,&amp;k);</span><br><span class="line">    p = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node)*total);</span><br><span class="line">    a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*total); <span class="comment">//存索引</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;p[i].Address,&amp;p[i].Data,&amp;p[i].Next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">//将List恢复正常序列,用a[]记录索引。 复杂度n^2 应优化这里(结果去掉break)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first == p[i].Address)&#123;</span><br><span class="line">                a[count++] = i;</span><br><span class="line">                first = p[i].Next;</span><br><span class="line"><span class="comment">//                break; //原来找到1个就break,改进后一直往下找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(first == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用count代表有多少结点在链表上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(count/k);i++)&#123; <span class="comment">//逆转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            p[a[j+i*k]].Next = p[a[j+i*k<span class="number">-1</span>]].Address;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>) p[a[i*k<span class="number">-1</span>]].Next = p[a[k+i*k<span class="number">-1</span>]].Address; <span class="comment">//修改逆转序列的前一个元素的Next</span></span><br><span class="line">        <span class="comment">//注意前后的连接</span></span><br><span class="line">        <span class="keyword">if</span>(i == count/k - <span class="number">1</span> &amp;&amp; (count%k == <span class="number">0</span>)) p[a[i*k]].Next = <span class="number">-1</span>; <span class="comment">//修改逆转序列的最后元素的Next</span></span><br><span class="line">        <span class="keyword">else</span> p[a[i*k]].Next = p[a[i*k+k]].Address;</span><br><span class="line">        Reavers((a+k*i),(a+k*(i+<span class="number">1</span>)<span class="number">-1</span>),k); <span class="comment">//逆转索引a[]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == count - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%05d %d %d\n"</span>,p[a[i]].Address,p[a[i]].Data,p[a[i]].Next);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>,p[a[i]].Address,p[a[i]].Data,p[a[i]].Next);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题可能一开始看题目一头雾水，但是仔细思考就会发现并不太难。&lt;br&gt;下面是我的思路：&lt;br&gt;&lt;strong&gt;1、&lt;/strong&gt;用类似静态链表的方法，来表示List，即一个数组存Data，一个数组存Next&lt;br&gt;&lt;strong&gt;2、&lt;/strong&gt;循环遍历链表，用&lt;code&gt;a[]&lt;/code&gt;记录下标。&lt;br&gt;&lt;strong&gt;3、&lt;/strong&gt;根据K来转置链表，修改Next，然后转置&lt;code&gt;a[]&lt;/code&gt;(&lt;strong&gt;顺序很重要&lt;/strong&gt;)。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="https://haohuaijin.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>7-3 Pop Sequence (25分)</title>
    <link href="https://haohuaijin.github.io/2019/10/11/7-3-Pop-Sequence-25%E5%88%86/"/>
    <id>https://haohuaijin.github.io/2019/10/11/7-3-Pop-Sequence-25%E5%88%86/</id>
    <published>2019-10-11T08:28:44.000Z</published>
    <updated>2019-10-11T08:30:36.000Z</updated>
    
    <content type="html"><![CDATA[<p> <strong>1、</strong>刚开始受严蔚敏数据结构的启发，想用比较大小的方法来判断是不是出栈序列。但是发现最后一个测试点就是卡这个算法。<br> <strong>2、</strong>然后看了柳神的博客，自己根据理解重新写了算法，但是第二个测试点还是过不去，下面是我的想法。<br> 步骤：循环判断数组中的每一个数，初始化temp=1 ，用temp来判断当前数组的最大值。如果数组当前值<strong>小于temp</strong>，就出栈，若<strong>大于等于temp就入栈</strong>，直到temp等于最大值。如果超过栈的容量标记flag=0并且break。最后根据flag判断YES或NO。<br> <strong>3、</strong>但是上面的步骤不能通过第二个测试点。<br>于是参考了柳神的程序，得到了下面的程序：</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> <span class="comment">//栈的定义</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    Stack *Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Stack *<span class="title">CreateNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack *p;</span><br><span class="line">    p = (Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line">    p-&gt;Data = <span class="number">0</span>;</span><br><span class="line">    p-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack *p,<span class="keyword">int</span> item)</span></span>&#123;</span><br><span class="line">    Stack *ptr = CreateNode();</span><br><span class="line">    ptr-&gt;Data = item;</span><br><span class="line">    ptr-&gt;Next = p-&gt;Next;</span><br><span class="line">    p-&gt;Next = ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;Next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(Stack *p)</span></span>&#123;</span><br><span class="line">    Stack *ptr = p-&gt;Next;</span><br><span class="line">    <span class="keyword">int</span> temp = ptr-&gt;Data;</span><br><span class="line">    p-&gt;Next = ptr-&gt;Next;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">(Stack *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;Next-&gt;Data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> **<span class="title">ReadData</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span> <span class="comment">//读取数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> **arr;</span><br><span class="line">    arr = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*(k));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123; <span class="comment">//为每一行分配地址</span></span><br><span class="line">        arr[j] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">            arr[i][j] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,k;</span><br><span class="line">    <span class="keyword">int</span> **ptr;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;m,&amp;n,&amp;k);</span><br><span class="line">    ptr = ReadData(m,n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123; <span class="comment">//真正的模拟了栈</span></span><br><span class="line">        Stack *p = CreateNode();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//记录栈的容量</span></span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>; <span class="comment">//记录要检测数组下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            Push(p,j);count++;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; m) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span>(!IsEmpty(p) &amp;&amp; GetTop(p) == ptr[i][current])&#123;</span><br><span class="line">                Pop(p);count--;</span><br><span class="line">                current++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!IsEmpty) Pop(p);</span><br><span class="line">        <span class="keyword">if</span>(current == n) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123; <span class="comment">//为每一行分配地址</span></span><br><span class="line">        <span class="built_in">free</span>(*(ptr+j));</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;strong&gt;1、&lt;/strong&gt;刚开始受严蔚敏数据结构的启发，想用比较大小的方法来判断是不是出栈序列。但是发现最后一个测试点就是卡这个算法。&lt;br&gt; &lt;strong&gt;2、&lt;/strong&gt;然后看了柳神的博客，自己根据理解重新写了算法，但是第二个测试点还是过不去，下面是我的想法。&lt;br&gt; 步骤：循环判断数组中的每一个数，初始化temp=1 ，用temp来判断当前数组的最大值。如果数组当前值&lt;strong&gt;小于temp&lt;/strong&gt;，就出栈，若&lt;strong&gt;大于等于temp就入栈&lt;/strong&gt;，直到temp等于最大值。如果超过栈的容量标记flag=0并且break。最后根据flag判断YES或NO。&lt;br&gt; &lt;strong&gt;3、&lt;/strong&gt;但是上面的步骤不能通过第二个测试点。&lt;br&gt;于是参考了柳神的程序，得到了下面的程序：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="https://haohuaijin.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>7-20 表达式的转换(25分)</title>
    <link href="https://haohuaijin.github.io/2019/10/07/7-20%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%20(25%20%E5%88%86)/"/>
    <id>https://haohuaijin.github.io/2019/10/07/7-20%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%20(25%20%E5%88%86)/</id>
    <published>2019-10-07T00:47:22.000Z</published>
    <updated>2019-10-07T00:47:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="历时三个半小时终于完成。"><a href="#历时三个半小时终于完成。" class="headerlink" title="历时三个半小时终于完成。"></a>历时三个半小时终于完成。</h3><p>这道题的难点主要是在处理<strong>数字前的正负号</strong>上，同时还应该注意数字<strong>有小数点</strong>并且<strong>不是一位数字</strong>。<br>因为在做题之前同学给我说过这道题，也知道几个坑，所以做题的过程比较顺利。</p><hr><p><strong>我的步骤如下：</strong><br>1、先完成不考虑<strong>数字前的正负号</strong>的程序。<br>2、考虑<strong>数字前的正负号</strong>，完善程序。<br>通过上面的步骤，做题的过程比较的顺利，把难题变成了简单的的题目。<br>在第二步的时候比较烧脑，因为我的<strong>想法比较简单</strong>，就是把所有的可能全都列出来，所以<strong>要花很多的时间考虑，验证</strong>。</p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>1、考虑问题要全面，在数字前正负号时要尽量列出所有的可能。<br>2、开始做题时有一个大体的思路就行，不必考虑的很周到。<br>3、要善于<strong>猜测试点</strong>。。在考试时测试点不会告诉我们，而是需要自己取探索。</p><h4 id="坑："><a href="#坑：" class="headerlink" title="坑："></a>坑：</h4><p><strong>这个题的一个坑就是，会在有的正数前加正号，但输出的时候不用输出正号。</strong>我就一直没过这个测试点，直到搜到了测试数据。</p><hr><h5 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h5><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带有头结点 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> s;</span><br><span class="line">    Stack Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//操作</span></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">()</span></span>; <span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack p,<span class="keyword">char</span> str)</span></span>; <span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack p)</span></span>; <span class="comment">//判断是不是为空</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Pop</span><span class="params">(Stack p)</span></span>; <span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetTop</span><span class="params">(Stack p)</span></span>; <span class="comment">//得到栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">majoy</span><span class="params">(Stack p,<span class="keyword">char</span> *s)</span></span>; <span class="comment">//后缀表达式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack p = CreateStack();</span><br><span class="line">    <span class="keyword">char</span> S[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[^\n]"</span>,S);</span><br><span class="line">    majoy(p,S); <span class="comment">//得到后缀表达式</span></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后缀表达式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">majoy</span><span class="params">(Stack p,<span class="keyword">char</span> *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *ptr = S;</span><br><span class="line">    <span class="keyword">while</span>(*ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理数字</span></span><br><span class="line">        <span class="keyword">if</span>((*ptr &gt;= <span class="string">'0'</span> &amp;&amp; *ptr &lt;= <span class="string">'9'</span>) || *ptr == <span class="string">'.'</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//处理小数点</span></span><br><span class="line">            <span class="keyword">while</span>((*ptr &gt;= <span class="string">'1'</span> &amp;&amp; *ptr &lt;= <span class="string">'9'</span>) || *ptr == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c"</span>,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 可有可无，为了防止指针错误可以用这个</span></span><br><span class="line"><span class="comment">        //处理开始的-5 </span></span><br><span class="line"><span class="comment">        else if((*ptr == '-' || *ptr == '+') &amp;&amp; ptr == S)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">        ptr++;</span></span><br><span class="line"><span class="comment">        if(*(ptr-1) == '+') printf("");</span></span><br><span class="line"><span class="comment">            else printf("-");</span></span><br><span class="line"><span class="comment">            while((*ptr &gt;= '1' &amp;&amp; *ptr &lt;= '9') || *ptr == '.')&#123;</span></span><br><span class="line"><span class="comment">                printf("%c",*ptr);</span></span><br><span class="line"><span class="comment">                ptr++;</span></span><br><span class="line"><span class="comment">                flag = 1;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">        <span class="comment">//专门处理-5这种情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((*ptr == <span class="string">'-'</span> || *ptr == <span class="string">'+'</span>) &amp;&amp; (*(ptr<span class="number">-1</span>)&gt;<span class="string">'9'</span> || *(ptr<span class="number">-1</span>)&lt;<span class="string">'0'</span>) &amp;&amp; *(ptr<span class="number">-1</span>) != <span class="string">')'</span> &amp;&amp; (*(ptr+<span class="number">1</span>)&gt;=<span class="string">'1'</span> &amp;&amp; *(ptr+<span class="number">1</span>)&lt;=<span class="string">'9'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ptr++;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span>(*(ptr<span class="number">-1</span>) == <span class="string">'+'</span>) <span class="built_in">printf</span>(<span class="string">""</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">            <span class="keyword">while</span>((*ptr &gt;= <span class="string">'1'</span> &amp;&amp; *ptr &lt;= <span class="string">'9'</span>) || *ptr == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c"</span>,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理左括号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*ptr == <span class="string">'('</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Push(p,*ptr);</span><br><span class="line">            ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理右括号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*ptr == <span class="string">')'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将里面的全部抛出</span></span><br><span class="line">            <span class="keyword">while</span>(GetTop(p) != <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %c"</span>,Pop(p));</span><br><span class="line">            &#125;</span><br><span class="line">            Pop(p);</span><br><span class="line">            ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理加减号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*ptr == <span class="string">'-'</span> || *ptr == <span class="string">'+'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//处理空栈，或遇到左括号</span></span><br><span class="line">            <span class="keyword">if</span>(IsEmpty(p) || GetTop(p) == <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Push(p,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//全部抛出直到空栈或左括号</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!IsEmpty(p))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(GetTop(p) == <span class="string">'('</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %c"</span>,Pop(p));</span><br><span class="line">                &#125;</span><br><span class="line">                Push(p,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理乘除号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*ptr == <span class="string">'*'</span> || *ptr == <span class="string">'/'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//处理空栈，或遇到左括号</span></span><br><span class="line">            <span class="keyword">if</span>(IsEmpty(p) || GetTop(p) == <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Push(p,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遇到加减号同上</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(GetTop(p) == <span class="string">'-'</span> || GetTop(p) == <span class="string">'+'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Push(p,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理出栈的情况</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!IsEmpty(p) &amp;&amp; (GetTop(p) == <span class="string">'*'</span> || GetTop(p) == <span class="string">'/'</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(GetTop(p) == <span class="string">'('</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %c"</span>,Pop(p));</span><br><span class="line">                &#125;</span><br><span class="line">                Push(p,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后输出剩下运算符</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %c"</span>,Pop(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack q;</span><br><span class="line">    q = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    q-&gt;s = <span class="string">'\0'</span>;</span><br><span class="line">    q-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack p,<span class="keyword">char</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack ptr;</span><br><span class="line">    ptr = CreateStack();</span><br><span class="line">    ptr-&gt;s = str;</span><br><span class="line">    ptr-&gt;Next = p-&gt;Next; <span class="comment">//注意指向的位置</span></span><br><span class="line">    p-&gt;Next = ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Pop</span><span class="params">(Stack p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack ptr;</span><br><span class="line">    <span class="keyword">char</span> str;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(p))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈空\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = p-&gt;Next;</span><br><span class="line">    str = ptr-&gt;s;</span><br><span class="line">    p-&gt;Next = ptr-&gt;Next;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是不是为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p-&gt;Next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetTop</span><span class="params">(Stack p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(p)) <span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;Next-&gt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文献:<a href="https://blog.csdn.net/SiKongPop/article/details/77972879#comments" target="_blank" rel="noopener">https://blog.csdn.net/SiKongPop/article/details/77972879#comments</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;历时三个半小时终于完成。&quot;&gt;&lt;a href=&quot;#历时三个半小时终于完成。&quot; class=&quot;headerlink&quot; title=&quot;历时三个半小时终于完成。&quot;&gt;&lt;/a&gt;历时三个半小时终于完成。&lt;/h3&gt;&lt;p&gt;这道题的难点主要是在处理&lt;strong&gt;数字前的正负号&lt;/strong&gt;上，同时还应该注意数字&lt;strong&gt;有小数点&lt;/strong&gt;并且&lt;strong&gt;不是一位数字&lt;/strong&gt;。&lt;br&gt;因为在做题之前同学给我说过这道题，也知道几个坑，所以做题的过程比较顺利。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;我的步骤如下：&lt;/strong&gt;&lt;br&gt;1、先完成不考虑&lt;strong&gt;数字前的正负号&lt;/strong&gt;的程序。&lt;br&gt;2、考虑&lt;strong&gt;数字前的正负号&lt;/strong&gt;，完善程序。&lt;br&gt;通过上面的步骤，做题的过程比较的顺利，把难题变成了简单的的题目。&lt;br&gt;在第二步的时候比较烧脑，因为我的&lt;strong&gt;想法比较简单&lt;/strong&gt;，就是把所有的可能全都列出来，所以&lt;strong&gt;要花很多的时间考虑，验证&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;总结：&quot;&gt;&lt;a href=&quot;#总结：&quot; class=&quot;headerlink&quot; title=&quot;总结：&quot;&gt;&lt;/a&gt;总结：&lt;/h4&gt;&lt;p&gt;1、考虑问题要全面，在数字前正负号时要尽量列出所有的可能。&lt;br&gt;2、开始做题时有一个大体的思路就行，不必考虑的很周到。&lt;br&gt;3、要善于&lt;strong&gt;猜测试点&lt;/strong&gt;。。在考试时测试点不会告诉我们，而是需要自己取探索。&lt;/p&gt;
&lt;h4 id=&quot;坑：&quot;&gt;&lt;a href=&quot;#坑：&quot; class=&quot;headerlink&quot; title=&quot;坑：&quot;&gt;&lt;/a&gt;坑：&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;这个题的一个坑就是，会在有的正数前加正号，但输出的时候不用输出正号。&lt;/strong&gt;我就一直没过这个测试点，直到搜到了测试数据。&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&quot;AC代码&quot;&gt;&lt;a href=&quot;#AC代码&quot; class=&quot;headerlink&quot; title=&quot;AC代码&quot;&gt;&lt;/a&gt;AC代码&lt;/h5&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="PTA" scheme="https://haohuaijin.github.io/tags/PTA/"/>
    
  </entry>
  
  <entry>
    <title>7-4 是否同一棵二叉搜索树(25分).md</title>
    <link href="https://haohuaijin.github.io/2019/10/06/7-4-%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-25%E5%88%86-/"/>
    <id>https://haohuaijin.github.io/2019/10/06/7-4-%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-25%E5%88%86-/</id>
    <published>2019-10-06T04:25:03.000Z</published>
    <updated>2019-10-06T14:21:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>开始是卡在怎么<strong>读数据</strong>上(果然还是读数据可怕，好几次都是卡在这里😭😭)，中间有1、2天没有再碰这道题。然后今天想着不能再拖了，就硬着头皮解出来了。</p><h6 id="想法："><a href="#想法：" class="headerlink" title="想法："></a>想法：</h6><p>一开始是想着不用构建树，用数组处理的，但是左思右想没有思路。<br>然后我就构建了<strong>树</strong>的结构，用<strong>前序遍历的方法来比较树是不是相同</strong>。<br>所以整体上来看思路比较简单。</p><a id="more"></a><h6 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这道题的主要思路是：</span></span><br><span class="line"><span class="comment"> * 就是让比结点大的数的插入顺序相同，比结点小的数的插入顺序相同。</span></span><br><span class="line"><span class="comment"> * 但是感觉上面的比较麻烦，我好像写不出来😭😭</span></span><br><span class="line"><span class="comment"> * 所以我把树建立了起来，然后用遍历的方法比较是不是相同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Leaves</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Leaves</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    Tree left,right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> **<span class="title">ReadData</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> l)</span></span>; <span class="comment">//读取数据</span></span><br><span class="line"><span class="function">Tree <span class="title">CreateNode</span><span class="params">(<span class="keyword">int</span> item)</span></span>; <span class="comment">//创造节点</span></span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree q,<span class="keyword">int</span> item)</span></span>; <span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreTraverse</span><span class="params">(Tree q)</span></span>; <span class="comment">//前序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> vec1[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> vec2[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,l;</span><br><span class="line">    <span class="keyword">int</span> **arr;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Tree front,rear; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;l);</span><br><span class="line">        <span class="comment">//读取到arr数据</span></span><br><span class="line">        arr = ReadData(n,l); </span><br><span class="line">        <span class="comment">//每一次循环将vec1，vec2化为零</span></span><br><span class="line">        <span class="built_in">memset</span>(vec1, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">100</span>); <span class="comment">//memset函数,将数组元素全化为0</span></span><br><span class="line">        <span class="built_in">memset</span>(vec2, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">100</span>); <span class="comment">//memset函数,将数组元素全化为0</span></span><br><span class="line">        <span class="comment">//初始化好第一棵树</span></span><br><span class="line">        front = CreateNode(arr[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) Insert(front,arr[<span class="number">0</span>][i]); <span class="comment">//初始化第一棵树</span></span><br><span class="line">        <span class="comment">//前序遍历第一棵树，保存在vec1中</span></span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        PreTraverse(front);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) vec1[i] = vec2[i]; <span class="comment">//将前序遍历的结果都存放在vec2中。见PreTraverse函数</span></span><br><span class="line">        <span class="comment">//遍历剩余的树并比较</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//初始化树</span></span><br><span class="line">            m = <span class="number">0</span>;flag = <span class="number">1</span>;</span><br><span class="line">            rear = CreateNode(arr[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++) Insert(rear,arr[i][j]); </span><br><span class="line">            <span class="comment">//遍历树</span></span><br><span class="line">            PreTraverse(rear);</span><br><span class="line">            <span class="comment">//比较</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;m<span class="number">-1</span>;n++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vec1[n] != vec2[n]) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放每一行的地址</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l; ++i) <span class="built_in">free</span>(*(arr + i));</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> **<span class="title">ReadData</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> **arr;</span><br><span class="line">    arr = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*(l+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=l;j++)&#123; <span class="comment">//为每一行分配地址</span></span><br><span class="line">        arr[j] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=l;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">            arr[i][j] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">CreateNode</span><span class="params">(<span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree q;</span><br><span class="line">    q = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Leaves));</span><br><span class="line">    q-&gt;Data = item;</span><br><span class="line">    q-&gt;left = q-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree q,<span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!q)&#123;</span><br><span class="line">        q = CreateNode(<span class="number">0</span>);</span><br><span class="line">        q-&gt;Data = item;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(item &gt; q-&gt;Data)&#123;</span><br><span class="line">        q-&gt;right = Insert(q-&gt;right,item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(item &lt; q-&gt;Data)&#123;</span><br><span class="line">        q-&gt;left = Insert(q-&gt;left,item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreTraverse</span><span class="params">(Tree q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec2[m++] = q-&gt;Data;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;left) PreTraverse(q-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;right) PreTraverse(q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始是卡在怎么&lt;strong&gt;读数据&lt;/strong&gt;上(果然还是读数据可怕，好几次都是卡在这里😭😭)，中间有1、2天没有再碰这道题。然后今天想着不能再拖了，就硬着头皮解出来了。&lt;/p&gt;
&lt;h6 id=&quot;想法：&quot;&gt;&lt;a href=&quot;#想法：&quot; class=&quot;headerlink&quot; title=&quot;想法：&quot;&gt;&lt;/a&gt;想法：&lt;/h6&gt;&lt;p&gt;一开始是想着不用构建树，用数组处理的，但是左思右想没有思路。&lt;br&gt;然后我就构建了&lt;strong&gt;树&lt;/strong&gt;的结构，用&lt;strong&gt;前序遍历的方法来比较树是不是相同&lt;/strong&gt;。&lt;br&gt;所以整体上来看思路比较简单。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="PTA" scheme="https://haohuaijin.github.io/tags/PTA/"/>
    
      <category term="树" scheme="https://haohuaijin.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>scanf()的用法总结</title>
    <link href="https://haohuaijin.github.io/2019/10/03/scanf-%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://haohuaijin.github.io/2019/10/03/scanf-%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2019-10-03T12:42:26.000Z</published>
    <updated>2019-10-03T12:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>最近在刷PTA数据结构时，发现自己对于scanf()的用法还不是很熟练，写下此篇做一记录。</strong></p><hr><h2 id="1、scanf-读入数字"><a href="#1、scanf-读入数字" class="headerlink" title="1、scanf() 读入数字"></a>1、scanf() 读入数字</h2><p>如果是只用<code>sacnf()</code>读入数字的话比较简单。<br>可以分为以下集中情况：</p><h6 id="1-1-在一行中，读入数字"><a href="#1-1-在一行中，读入数字" class="headerlink" title="1.1 在一行中，读入数字"></a>1.1 在一行中，读入数字</h6><p>假设读入三个：<br>用<code>scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</code>来处理就足够了。</p><h6 id="1-2-在多行中，读入数字"><a href="#1-2-在多行中，读入数字" class="headerlink" title="1.2 在多行中，读入数字"></a>1.2 在多行中，读入数字</h6><p>假设读入两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br></pre></td></tr></table></figure><p>因为读入的是数字，<code>scanf()</code>可以自动忽略空格和换行符，所以不需要特别的处理，和上面一样就行。<br><code>scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</code></p><a id="more"></a><h6 id="1-3-读入数字时，有特殊的要求"><a href="#1-3-读入数字时，有特殊的要求" class="headerlink" title="1.3 读入数字时，有特殊的要求"></a>1.3 读入数字时，有特殊的要求</h6><p>例如:<br>要读入以下的数据，得到年月日。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-10-3</span><br></pre></td></tr></table></figure><p>因为里面有<code>-</code>字符所以你<strong>没有办法直接的把数据读进来</strong>，但幸运的是<code>scanf()</code>给了我们一种简单的方法来处理这种情况。<br><code>scanf(&quot;%d-%d-%d&quot;,&amp;a,&amp;b,&amp;c);</code>，这样你就可以得到年月日，也就是a，b，c。<br>这样做的原因是，<strong>在<code>scanf()</code>里面写了什么，在输入时就要原样的输入</strong>，即在<code>scanf()</code>里面写了<code>-</code>，输入的时候也要在那个位置加上<code>-</code>。</p><hr><h2 id="2、scanf-读入字符"><a href="#2、scanf-读入字符" class="headerlink" title="2、scanf() 读入字符"></a>2、scanf() 读入字符</h2><p>相较于读入数字，读入字符就比较麻烦些。</p><h5 id="1-1-在一行中，读入字符"><a href="#1-1-在一行中，读入字符" class="headerlink" title="1.1 在一行中，读入字符"></a>1.1 在一行中，读入字符</h5><p>例如：<br>读入一下的数据，数据间用空格隔开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b c d</span><br></pre></td></tr></table></figure><p>因为现在读入的是字符，空格和换行符都属于字符，所以我们采用<br><strong>1.3</strong>的方法来读入数据<code>scanf(&quot;%c %c %c&quot;,&amp;a,&amp;b,&amp;c);</code>。<br><strong>或者</strong>用<code>scanf(&quot;%c%c%c%c%c&quot;,&amp;a,&amp;unused1,&amp;b,&amp;unused2,&amp;c);</code>来读取，中间定义了两个字符<code>unused1和unused2</code>来读取空格。</p><h5 id="1-2-在多行中，读入字符"><a href="#1-2-在多行中，读入字符" class="headerlink" title="1.2 在多行中，读入字符"></a>1.2 在多行中，读入字符</h5><p>这里和<strong>1.2在多行中，读入数字</strong>的主要的区别，就是要<strong>处理行末的换行符</strong>，下面介绍两种方法来处理这个，假设要输入以下的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a d</span><br><span class="line">c d</span><br></pre></td></tr></table></figure><p><strong>(1)</strong> 用<code>getchar()</code>来处理换行符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char a,b,c,d;</span><br><span class="line">scanf(&quot;%c %c&quot;,&amp;a,&amp;b);</span><br><span class="line">getchar();</span><br><span class="line">scanf(&quot;%c %c&quot;,&amp;c,&amp;d);</span><br><span class="line">getchar();</span><br></pre></td></tr></table></figure><p><strong>(2)</strong> 用<code>scanf()</code>自行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char a,b,c,d;</span><br><span class="line">scanf(&quot;%c %c\n&quot;,&amp;a,&amp;b);</span><br><span class="line">scanf(&quot;%c %c\n&quot;,&amp;c,&amp;d);</span><br></pre></td></tr></table></figure><p>但是第二种方法，<strong>近几天</strong>不知道为什么在我的电脑上要多输入一次数据才可以正确的运行，前几天还可以正常的读入数据，不过<strong>在PTA上提交却没有问题</strong>。</p><h2 id="3、scanf-读入字符串"><a href="#3、scanf-读入字符串" class="headerlink" title="3、scanf() 读入字符串"></a>3、scanf() 读入字符串</h2><p>读入字符串比较简单，其中要注意的是，读入的字符串中<strong>不能有空格</strong>。如果有空格，就<strong>在空格处停止</strong>。<br><strong>如果要读入空格</strong>一个可行的方法就是用<code>scanf(&quot;%[^\n]&quot;,s);</code>来处理，这个表达式的意思是<strong>遇到换行符才停止读入</strong>，其中<code>scanf()</code>中<code>[]</code>里面<code>^</code>后面就是你要<strong>停止读入的字符</strong>，如把<code>\n</code>换成<code>s</code>意思就是遇到<code>s</code>就停止读入。<br>同时在<code>^</code>的后面可以放很多的字符，例如<code>scanf(&quot;%[^sdf]&quot;,s);</code>，意思就是遇到里面的任一个字符都停止读入。</p><p><strong>初学者，如果有遗漏或错误，请见谅。同时欢迎与我沟通交流。</strong></p><p><strong>好了今天记录下这些，剩下的以后再说。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;最近在刷PTA数据结构时，发现自己对于scanf()的用法还不是很熟练，写下此篇做一记录。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1、scanf-读入数字&quot;&gt;&lt;a href=&quot;#1、scanf-读入数字&quot; class=&quot;headerlink&quot; title=&quot;1、scanf() 读入数字&quot;&gt;&lt;/a&gt;1、scanf() 读入数字&lt;/h2&gt;&lt;p&gt;如果是只用&lt;code&gt;sacnf()&lt;/code&gt;读入数字的话比较简单。&lt;br&gt;可以分为以下集中情况：&lt;/p&gt;
&lt;h6 id=&quot;1-1-在一行中，读入数字&quot;&gt;&lt;a href=&quot;#1-1-在一行中，读入数字&quot; class=&quot;headerlink&quot; title=&quot;1.1 在一行中，读入数字&quot;&gt;&lt;/a&gt;1.1 在一行中，读入数字&lt;/h6&gt;&lt;p&gt;假设读入三个：&lt;br&gt;用&lt;code&gt;scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;a,&amp;amp;b,&amp;amp;c);&lt;/code&gt;来处理就足够了。&lt;/p&gt;
&lt;h6 id=&quot;1-2-在多行中，读入数字&quot;&gt;&lt;a href=&quot;#1-2-在多行中，读入数字&quot; class=&quot;headerlink&quot; title=&quot;1.2 在多行中，读入数字&quot;&gt;&lt;/a&gt;1.2 在多行中，读入数字&lt;/h6&gt;&lt;p&gt;假设读入两行：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 2 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4 5 6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;因为读入的是数字，&lt;code&gt;scanf()&lt;/code&gt;可以自动忽略空格和换行符，所以不需要特别的处理，和上面一样就行。&lt;br&gt;&lt;code&gt;scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;a,&amp;amp;b,&amp;amp;c);&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="经验" scheme="https://haohuaijin.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="C语言" scheme="https://haohuaijin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>7-4 List Leaves(25分)</title>
    <link href="https://haohuaijin.github.io/2019/10/03/7-4%20List%20Leaves%20(25%20%E5%88%86)/"/>
    <id>https://haohuaijin.github.io/2019/10/03/7-4%20List%20Leaves%20(25%20%E5%88%86)/</id>
    <published>2019-10-03T08:58:56.000Z</published>
    <updated>2019-10-03T08:58:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题在逻辑上并不难，难在我们可能树不是很熟悉上。<br>我用了<strong>静态链表</strong>的方法构造树，用<strong>循环队列</strong>来用数组实现队列。</p><p><strong>思路：</strong><br>1、将数据读进来用，找到<strong>根节点</strong>。<br>2、<strong>递归</strong>找到所有的<strong>叶子节点</strong>。<br>3、用<strong>队列实现层次遍历</strong>，来找到树各层的元素。<br>4、比较<strong>叶子节点</strong>和<strong>层次遍历的结果</strong>得到最终的结果。</p><h5 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h5><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Null -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//树的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> left,right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//队列的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">Queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data[MAX];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ReadData</span><span class="params">(Tree q)</span></span>; <span class="comment">//读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindLeaves</span><span class="params">(Tree q,<span class="keyword">int</span> root)</span></span>; <span class="comment">//找到叶子节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(Queue q,<span class="keyword">int</span> number)</span></span>; <span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteQ</span><span class="params">(Queue q)</span></span>; <span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Queue q)</span></span>; <span class="comment">//是不是为空</span></span><br><span class="line"><span class="function">Queue <span class="title">CreateQ</span><span class="params">()</span></span>; <span class="comment">//创建队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">middle</span><span class="params">(Tree q,Queue p,<span class="keyword">int</span> root)</span></span>; <span class="comment">//层次遍历</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> count_mid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    Tree T;</span><br><span class="line">    Queue q = CreateQ(); <span class="comment">//初始化队列</span></span><br><span class="line">    T = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node)*(<span class="number">100</span>)); <span class="comment">//此步不能放在函数里</span></span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">    root = ReadData(T); <span class="comment">//读入数据</span></span><br><span class="line">    FindLeaves(T,root); <span class="comment">//找到所有的叶子节点</span></span><br><span class="line">    middle(T,q,root); <span class="comment">//得到层次遍历的结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count_mid;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;count;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid[i] == num[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d"</span>,mid[i]);</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %d"</span>,mid[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">middle</span><span class="params">(Tree q,Queue p,<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    AddQ(p,root);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(p))</span><br><span class="line">    &#123;</span><br><span class="line">        temp = DeleteQ(p);</span><br><span class="line">        mid[count_mid++] = temp;</span><br><span class="line">        <span class="keyword">if</span>(q[temp].left != Null) AddQ(p,q[temp].left);</span><br><span class="line">        <span class="keyword">if</span>(q[temp].right != Null) AddQ(p,q[temp].right);</span><br><span class="line">    &#125;</span><br><span class="line">    mid[count_mid] = <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据,找到根节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ReadData</span><span class="params">(Tree q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> lt,rt; <span class="comment">//记录左右结点</span></span><br><span class="line">    <span class="keyword">int</span> root; <span class="comment">//根节点的下标</span></span><br><span class="line">    <span class="keyword">int</span> check[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//记录结点,找到根结点</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="comment">//读入的数据</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[i].index = i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c %c"</span>,&amp;lt,&amp;rt);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span>(lt != <span class="string">'-'</span>)&#123;</span><br><span class="line">            q[i].left = lt - <span class="string">'0'</span>;</span><br><span class="line">            check[q[i].left] = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> q[i].left = Null;</span><br><span class="line">        <span class="keyword">if</span>(rt != <span class="string">'-'</span>)&#123;</span><br><span class="line">            q[i].right = rt - <span class="string">'0'</span>;</span><br><span class="line">            check[q[i].right] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> q[i].right = Null;</span><br><span class="line">    &#125;</span><br><span class="line">    q[n].index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(check[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            root = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到叶子节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindLeaves</span><span class="params">(Tree q,<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q[root].left == Null &amp;&amp; q[root].right == Null)&#123;</span><br><span class="line">        num[count++] = root;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q[root].left != Null)&#123;</span><br><span class="line">        FindLeaves(q,q[root].left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q[root].right != Null)&#123;</span><br><span class="line">        FindLeaves(q,q[root].right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(Queue q,<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((q-&gt;rear+<span class="number">1</span>)%MAX == q-&gt;front)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队满\n"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    q-&gt;Data[(++q-&gt;rear)%MAX] = number;</span><br><span class="line">    q-&gt;rear = (q-&gt;rear)%MAX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteQ</span><span class="params">(Queue q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;front == q-&gt;rear)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队空\n"</span>); <span class="keyword">return</span> Null;</span><br><span class="line">    &#125;</span><br><span class="line">    number = q-&gt;Data[(++q-&gt;front)%MAX];</span><br><span class="line">    q-&gt;front = (q-&gt;front)%MAX;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建队列</span></span><br><span class="line"><span class="function">Queue <span class="title">CreateQ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line">    q-&gt;front = <span class="number">0</span>;</span><br><span class="line">    q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是不是为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Queue q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (q-&gt;front == q-&gt;rear);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题在逻辑上并不难，难在我们可能树不是很熟悉上。&lt;br&gt;我用了&lt;strong&gt;静态链表&lt;/strong&gt;的方法构造树，用&lt;strong&gt;循环队列&lt;/strong&gt;来用数组实现队列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;br&gt;1、将数据读进来用，找到&lt;strong&gt;根节点&lt;/strong&gt;。&lt;br&gt;2、&lt;strong&gt;递归&lt;/strong&gt;找到所有的&lt;strong&gt;叶子节点&lt;/strong&gt;。&lt;br&gt;3、用&lt;strong&gt;队列实现层次遍历&lt;/strong&gt;，来找到树各层的元素。&lt;br&gt;4、比较&lt;strong&gt;叶子节点&lt;/strong&gt;和&lt;strong&gt;层次遍历的结果&lt;/strong&gt;得到最终的结果。&lt;/p&gt;
&lt;h5 id=&quot;AC代码&quot;&gt;&lt;a href=&quot;#AC代码&quot; class=&quot;headerlink&quot; title=&quot;AC代码:&quot;&gt;&lt;/a&gt;AC代码:&lt;/h5&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="PTA" scheme="https://haohuaijin.github.io/tags/PTA/"/>
    
  </entry>
  
</feed>
