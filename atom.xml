<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HHJ的个人网站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://haohuaijin.github.io/"/>
  <updated>2020-10-06T08:33:31.167Z</updated>
  <id>https://haohuaijin.github.io/</id>
  
  <author>
    <name>HuaiJin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实验1:操作系统的引导</title>
    <link href="https://haohuaijin.github.io/2020/10/06/%E5%AE%9E%E9%AA%8C1:%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC/"/>
    <id>https://haohuaijin.github.io/2020/10/06/%E5%AE%9E%E9%AA%8C1:%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%95%E5%AF%BC/</id>
    <published>2020-10-06T08:31:49.000Z</published>
    <updated>2020-10-06T08:33:31.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验的准备工作操作"><a href="#实验的准备工作操作" class="headerlink" title="实验的准备工作操作"></a>实验的准备工作操作</h2><ul><li>解压源码用<code>tar -zxvf hit-oslab-linux-20110823.tar.gz</code> 可以使用<code>-C</code>来指定解压路径，<code>tar -zxvf hit-oslab-linux-20110823.tar.gz -C [path]</code></li><li>编译linux-0.11的源码，在<code>linux-0.11</code>的文件夹下运行<code>make all</code>或者<code>make</code>。</li><li>在oslab文件目录下运行<code>./run</code>运行<code>bochs 中的linux-0.11</code>。</li><li>访问linux-0.11里面的文件，使用<code>sudo ./mount-hdc</code>来装载硬盘，然后在<code>hdc</code>中访问，卸载硬盘<code>sudo umount hdc</code>。</li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol><li>阅读《Linux 内核完全注释》的第 6 章，对计算机和 Linux 0.11 的引导过程进行初步的了解；</li><li>按照下面的要求改写 0.11 的引导程序 bootsect.s</li><li>有兴趣同学可以做做进入保护模式前的设置程序 setup.s。<a id="more"></a><h3 id="改写-bootsect-s-主要完成如下功能："><a href="#改写-bootsect-s-主要完成如下功能：" class="headerlink" title="改写 bootsect.s 主要完成如下功能："></a>改写 bootsect.s 主要完成如下功能：</h3></li></ol><ul><li>bootsect.s 能在屏幕上打印一段提示信息“XXX is booting…”，其中 XXX 是你给自己的操作系统起的名字，也可以显示一个特色 logo，以表示自己操作系统的与众不同。</li></ul><h3 id="改写-setup-s-主要完成如下功能："><a href="#改写-setup-s-主要完成如下功能：" class="headerlink" title="改写 setup.s 主要完成如下功能："></a>改写 setup.s 主要完成如下功能：</h3><ol><li>bootsect.s 能完成 setup.s 的载入，并跳转到 setup.s 开始地址执行。而 setup.s 向屏幕输出一行”Now we are in SETUP”。</li><li>setup.s 能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。</li><li>setup.s 不再加载 Linux 内核，保持上述信息显示在屏幕上即可。</li></ol><h2 id="bootsect-s的修改"><a href="#bootsect-s的修改" class="headerlink" title="bootsect.s的修改"></a>bootsect.s的修改</h2><p><code>bootsect.s</code>的功能是将自己从<code>0x7c00</code>处移动到了<code>0x90000</code>处。显示字符<code>loding system ...</code>，然后将磁盘上的<code>setup.s</code>和<code>system</code>模块加载到内存中来，最后跳转到<code>setup.s</code>所在的位置，执行<code>setup.s</code>。</p><p><strong>实验内容：</strong></p><ol><li><p>bootsect.s 能在屏幕上打印一段提示信息“XXX is booting…”；</p></li><li><p>bootsect.s 能完成 setup.s 的载入，并跳转到 setup.s 开始地址执行。</p></li></ol><h3 id="1-bootsect-s-打印字符"><a href="#1-bootsect-s-打印字符" class="headerlink" title="1. bootsect.s 打印字符"></a>1. bootsect.s 打印字符</h3><p>首先使用<strong>BIOS</strong><code>0x10</code>号中断的子功能<code>0x03</code>获得光标的位置，然后再利用<strong>BIOS</strong><code>0x10</code>号中断的子功能<code>0x13</code>打印字符到屏幕上。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">entry start</span><br><span class="line">start:</span><br><span class="line">    movah,#0x03! read cursor pos</span><br><span class="line">  xorbh,bh</span><br><span class="line">  int0x10</span><br><span class="line"></span><br><span class="line">    mov cx,#26</span><br><span class="line">    mov bl,#07</span><br><span class="line">    mov bp,#msg !寻址es:bp</span><br><span class="line">    mov ax,#0x7c0 !因为bootsect的代码放在0x7c00处</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10 </span><br><span class="line">msg:</span><br><span class="line">    .byte 13,10 !回车和换行</span><br><span class="line">    .ascii &quot;HaoOS is loading ...&quot;</span><br><span class="line">    .byte 13,10,13,10</span><br><span class="line"></span><br><span class="line">.org 510</span><br><span class="line">boot_flag:</span><br><span class="line">    .word 0xAA55</span><br></pre></td></tr></table></figure><p>在<strong>BIOS</strong>中断指令<code>int</code>前面的代码都是为中断设置一些参数。最后的三行是因为bootsect的大小必须为512字节，所以添加到后面使编译后的文件大小为512字节，最后两个字节为<code>0xAA55</code>。</p><h3 id="2-载入setup并跳转"><a href="#2-载入setup并跳转" class="headerlink" title="2. 载入setup并跳转"></a>2. 载入setup并跳转</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">entry start</span><br><span class="line">start:</span><br><span class="line">    movah,#0x03! read cursor pos</span><br><span class="line">  xorbh,bh</span><br><span class="line">  int0x10</span><br><span class="line"></span><br><span class="line">    mov cx,#26</span><br><span class="line">    mov bl,#07</span><br><span class="line">    mov bp,#msg !寻址es:bp</span><br><span class="line">    mov ax,#0x7c0 !因为bootsect的代码放在0x7c00处</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">load_setup:</span><br><span class="line">movdx,#0x0000! drive 0, head 0</span><br><span class="line">movcx,#0x0002! sector 2, track 0</span><br><span class="line">movbx,#0x0200! address = 512, in INITSEG</span><br><span class="line">movax,#0x0200+4    ! service 2, nr of sectors</span><br><span class="line">int0x13! read it</span><br><span class="line"></span><br><span class="line">  jmpi 0,#0x07e0      ! jump to setup 0x07e0 = 0x07c0 + 0x0200</span><br><span class="line">                        ! there is set cs to 0x07e0, in the setup the cs be used.</span><br><span class="line"></span><br><span class="line">msg:</span><br><span class="line">    .byte 13,10 !回车和换行</span><br><span class="line">    .ascii &quot;HaoOS is loading ...&quot;</span><br><span class="line">    .byte 13,10,13,10</span><br><span class="line"></span><br><span class="line">.org 510</span><br><span class="line">boot_flag:</span><br><span class="line">    .word 0xAA55</span><br></pre></td></tr></table></figure><p>在第一部分的代码中添加了load_step的部分，这一部分利用BIOS<code>0x13</code>中断读入<code>setup.s</code>然后利用<code>jmpi</code>跳转到<code>setup.s</code>模块开始的地方。</p><p><strong>注意</strong>：</p><p>由于在bootsect中我们并没有移动bootsect的位置，所以在跳转的时候的地址是<code>0x07c0 + 0x0200 = 0x07e0</code>，而不是和linux-0.11中一样跳转到<code>0x90200</code>处。</p><h2 id="setup的修改"><a href="#setup的修改" class="headerlink" title="setup的修改"></a>setup的修改</h2><p>setup的主要功能是使用BIOS中断读取系统参数，然后放到内存中的指定位置，同时将cpu从实模式转化到保护模式。</p><p><strong>实验内容</strong>：</p><ol><li>setup.s 向屏幕输出一行”Now we are in SETUP”。</li><li>setup.s 能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。</li><li>setup.s 不再加载 Linux 内核，保持上述信息显示在屏幕上即可。</li></ol><h3 id="1-setup向屏幕输出字符"><a href="#1-setup向屏幕输出字符" class="headerlink" title="1. setup向屏幕输出字符"></a>1. setup向屏幕输出字符</h3><p>这一部分代码和bootsect部分类似。有的部分需要修改，比如<code>es</code>寄存器的指向，还有打印的字符的长度。</p><h3 id="2-获取硬件参数并打印"><a href="#2-获取硬件参数并打印" class="headerlink" title="2. 获取硬件参数并打印"></a>2. 获取硬件参数并打印</h3><p>这里如何获取硬件参数，既可以参考linux-0.11的源码，也可以自己查看BIOS中断的手册。我在这里比较迷惑的是如何将获得的参数打印到屏幕上？看了老师的实现后，发现还是比较简单的，主要问题是自己对汇编语言还是不够熟悉。老师的代码如下(大体的思路是先读参数，然后获取光标，打印，获取光标，打印…..)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">INITSEG  = 0x9000</span><br><span class="line">entry _start</span><br><span class="line">_start:</span><br><span class="line">! Print &quot;NOW we are in SETUP&quot;</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#25</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg2</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov es,ax</span><br><span class="line">! init ss:sp</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,#0xFF00</span><br><span class="line"></span><br><span class="line">! Get Params</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov [0],dx</span><br><span class="line">    </span><br><span class="line">    mov ah,#0x88</span><br><span class="line">    int 0x15</span><br><span class="line">    mov [2],ax</span><br><span class="line">! 这里是如何把参数保存到数据段里面的</span><br><span class="line">    mov ax,#0x0000</span><br><span class="line">    mov ds,ax</span><br><span class="line">    lds si,[4*0x41]</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,#0x0004</span><br><span class="line">    mov cx,#0x10</span><br><span class="line">    rep</span><br><span class="line">    movsb</span><br><span class="line"></span><br><span class="line">! Be Ready to Print</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">! Cursor Position</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#18</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_cursor</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[0]</span><br><span class="line">    call    print_hex</span><br><span class="line">! Memory Size</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#14</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_memory</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[2]</span><br><span class="line">    call    print_hex</span><br><span class="line">! Add KB</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#2</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_kb</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">! Cyles</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#7</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_cyles</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[4]</span><br><span class="line">    call    print_hex</span><br><span class="line">! Heads</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#8</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_heads</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[6]</span><br><span class="line">    call    print_hex</span><br><span class="line">! Secotrs</span><br><span class="line">    mov ah,#0x03</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10</span><br><span class="line">    mov cx,#10</span><br><span class="line">    mov bx,#0x0007</span><br><span class="line">    mov bp,#msg_sectors</span><br><span class="line">    mov ax,#0x1301</span><br><span class="line">    int 0x10</span><br><span class="line">    mov dx,[12]</span><br><span class="line">    call    print_hex</span><br><span class="line"></span><br><span class="line">inf_loop:</span><br><span class="line">    jmp inf_loop</span><br><span class="line"></span><br><span class="line">print_hex:</span><br><span class="line">    mov    cx,#4</span><br><span class="line">print_digit:</span><br><span class="line">    rol    dx,#4</span><br><span class="line">    mov    ax,#0xe0f</span><br><span class="line">    and    al,dl</span><br><span class="line">    add    al,#0x30</span><br><span class="line">    cmp    al,#0x3a</span><br><span class="line">    jl     outp</span><br><span class="line">    add    al,#0x07</span><br><span class="line">outp:</span><br><span class="line">    int    0x10</span><br><span class="line">    loop   print_digit</span><br><span class="line">    ret</span><br><span class="line">print_nl:</span><br><span class="line">    mov    ax,#0xe0d     ! CR</span><br><span class="line">    int    0x10</span><br><span class="line">    mov    al,#0xa     ! LF</span><br><span class="line">    int    0x10</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">msg2:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;NOW we are in SETUP&quot;</span><br><span class="line">    .byte 13,10,13,10</span><br><span class="line">msg_cursor:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Cursor position:&quot;</span><br><span class="line">msg_memory:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Memory Size:&quot;</span><br><span class="line">msg_cyles:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Cyls:&quot;</span><br><span class="line">msg_heads:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Heads:&quot;</span><br><span class="line">msg_sectors:</span><br><span class="line">    .byte 13,10</span><br><span class="line">    .ascii &quot;Sectors:&quot;</span><br><span class="line">msg_kb:</span><br><span class="line">    .ascii &quot;KB&quot;</span><br><span class="line"></span><br><span class="line">.org 510</span><br><span class="line">boot_flag:</span><br><span class="line">    .word 0xAA55</span><br></pre></td></tr></table></figure><p>这里如何使用的bootsect还是上个实验的代码的话，需要把前面的<code>INITSEG</code>改成<code>0x07e0</code>。</p><p><strong>疑问：</strong></p><p>在上面代码的获取参数部分，不明白是如何把数据保存到特定位置的？如何循环的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,#0x0000</span><br><span class="line">mov ds,ax</span><br><span class="line">lds si,[4*0x41]</span><br><span class="line">mov ax,#INITSEG</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,#0x0004</span><br><span class="line">mov cx,#0x10</span><br><span class="line">rep</span><br><span class="line">movsb</span><br></pre></td></tr></table></figure><p>试着解释：在这里是从原地址到目的地址移动1字节的内容，这里设置<code>cs=16</code>，意思是移动16次，共16字节。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实验的准备工作操作&quot;&gt;&lt;a href=&quot;#实验的准备工作操作&quot; class=&quot;headerlink&quot; title=&quot;实验的准备工作操作&quot;&gt;&lt;/a&gt;实验的准备工作操作&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;解压源码用&lt;code&gt;tar -zxvf hit-oslab-linux-20110823.tar.gz&lt;/code&gt; 可以使用&lt;code&gt;-C&lt;/code&gt;来指定解压路径，&lt;code&gt;tar -zxvf hit-oslab-linux-20110823.tar.gz -C [path]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;编译linux-0.11的源码，在&lt;code&gt;linux-0.11&lt;/code&gt;的文件夹下运行&lt;code&gt;make all&lt;/code&gt;或者&lt;code&gt;make&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在oslab文件目录下运行&lt;code&gt;./run&lt;/code&gt;运行&lt;code&gt;bochs 中的linux-0.11&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;访问linux-0.11里面的文件，使用&lt;code&gt;sudo ./mount-hdc&lt;/code&gt;来装载硬盘，然后在&lt;code&gt;hdc&lt;/code&gt;中访问，卸载硬盘&lt;code&gt;sudo umount hdc&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot; class=&quot;headerlink&quot; title=&quot;实验内容&quot;&gt;&lt;/a&gt;实验内容&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;阅读《Linux 内核完全注释》的第 6 章，对计算机和 Linux 0.11 的引导过程进行初步的了解；&lt;/li&gt;
&lt;li&gt;按照下面的要求改写 0.11 的引导程序 bootsect.s&lt;/li&gt;
&lt;li&gt;有兴趣同学可以做做进入保护模式前的设置程序 setup.s。
    
    </summary>
    
    
    
      <category term="操作系统" scheme="https://haohuaijin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>实验2:系统调用</title>
    <link href="https://haohuaijin.github.io/2020/10/06/%E5%AE%9E%E9%AA%8C2:%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>https://haohuaijin.github.io/2020/10/06/%E5%AE%9E%E9%AA%8C2:%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</id>
    <published>2020-10-06T07:23:38.000Z</published>
    <updated>2020-10-06T07:33:17.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验2-系统调用"><a href="#实验2-系统调用" class="headerlink" title="实验2: 系统调用"></a>实验2: 系统调用</h1><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>在 Linux 0.11 上添加两个系统调用，并编写两个简单的应用程序测试它们。</p><h3 id="1-iam"><a href="#1-iam" class="headerlink" title="1. iam()"></a>1. <code>iam()</code></h3><p>第一个系统调用是 iam()，其原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">iam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * name)</span></span>;</span><br></pre></td></tr></table></figure><p>完成的功能是将字符串参数 <code>name</code> 的内容拷贝到内核中保存下来。要求 <code>name</code> 的长度不能超过 23 个字符。返回值是拷贝的字符数。如果 <code>name</code> 的字符个数超过了 <code>23</code>，则返回 “-1”，并置 errno 为 EINVAL。</p><p>在 <code>kernal/who.c</code> 中实现此系统调用。</p><h3 id="2-whoami"><a href="#2-whoami" class="headerlink" title="2. whoami()"></a>2. <code>whoami()</code></h3><p>第二个系统调用是 whoami()，其原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">whoami</span><span class="params">(<span class="keyword">char</span>* name, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>它将内核中由 <code>iam()</code> 保存的名字拷贝到 name 指向的用户地址空间中，同时确保不会对 <code>name</code> 越界访存（<code>name</code> 的大小由 <code>size</code> 说明）。返回值是拷贝的字符数。如果 <code>size</code> 小于需要的空间，则返回“-1”，并置 errno 为 EINVAL。</p><p>也是在 <code>kernal/who.c</code> 中实现。</p><h3 id="3-测试程序"><a href="#3-测试程序" class="headerlink" title="3. 测试程序"></a>3. 测试程序</h3><p>运行添加过新系统调用的 Linux 0.11，在其环境下编写两个测试程序 iam.c 和 whoami.c。最终的运行结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./iam lizhijun</span><br><span class="line">$ ./whoami</span><br><span class="line">lizhijun</span><br></pre></td></tr></table></figure><h2 id="系统调用简介"><a href="#系统调用简介" class="headerlink" title="系统调用简介"></a>系统调用简介</h2><p>系统调用和一般的函数调用在使用方式上没有区别，区别在于调用之后函数内部如何处理。</p><a id="more"></a><p>系统调用中使用<code>int 0x80</code>来切换到内核态，使用内核中的系统函数来完成系统调用，如下面的步骤：</p><ol><li>应用程序调用库函数（API）；</li><li>API 将系统调用号存入 EAX，然后通过中断调用使系统进入内核态；</li><li>内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）；</li><li>系统调用完成相应功能，将返回值存入 EAX，返回到中断处理函数；</li><li>中断处理函数返回到 API 中；</li><li>API 将 EAX 返回给应用程序。</li></ol><p>下图是一个系统调用在内核里面的调用流程：</p><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/系统调用.png" width="600"></center><p>需要修改的文件(以linux-0.11为主文件夹)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">linux-0.11/include/linux/sys.h</span><br><span class="line">linux-0.11/kernel/system_call.s</span><br><span class="line">linux-0.11/kernel/Makefile</span><br><span class="line">在linux-0.11/kernel中添加文件</span><br><span class="line">who.c</span><br><span class="line"></span><br><span class="line">下面的需要在虚拟机中的linux系统中修改:</span><br><span class="line">在linux-0.11的文件目录下修改</span><br><span class="line">/usr/root/include/unistd.h</span><br><span class="line">~/iam.c</span><br><span class="line">~/whoami.c</span><br></pre></td></tr></table></figure><h2 id="修改sys-h"><a href="#修改sys-h" class="headerlink" title="修改sys.h"></a>修改<code>sys.h</code></h2><p>在<code>sys.h</code>中维护了一个<code>sys_call_table</code>是一个函数指针数组，通过系统调用号，然后在数组中找到相应的中断处理函数。我们要将自己编写的系统调用添加到里面，就如以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_iam</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_whoami</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">fn_ptr sys_call_table[] = &#123;......,sys_setregid,sys_iam,sys_whoami&#125;;</span><br></pre></td></tr></table></figure><h2 id="修改unistd-h"><a href="#修改unistd-h" class="headerlink" title="修改unistd.h"></a>修改<code>unistd.h</code></h2><p>在<code>unistd.h</code>中定义了系统调用的编号，和一些宏，如下面所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define __NR_setregid71</span><br><span class="line">//在这里添加我们自己的系统调用编号，使我们的系统调用可以在sys.h中找到</span><br><span class="line">#define __NR_iam72</span><br><span class="line">#define __NR_whoami73</span><br><span class="line"></span><br><span class="line">//这里定义了一个没有参数输入的系统调用宏。</span><br><span class="line">#define _syscall0(type,name) \</span><br><span class="line">type name(void) \</span><br><span class="line">&#123; \</span><br><span class="line">long __res; \</span><br><span class="line">__asm__ volatile (&quot;int $0x80&quot; \</span><br><span class="line">: &quot;=a&quot; (__res) \</span><br><span class="line">: &quot;0&quot; (__NR_##name)); \  //这里就是把系统调用编号，存入EAX中。</span><br><span class="line">if (__res &gt;= 0) \</span><br><span class="line">return (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line">return -1; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改system-call-s"><a href="#修改system-call-s" class="headerlink" title="修改system_call.s"></a>修改<code>system_call.s</code></h2><p>将其中第61行的<code>nr_system_calls = 72</code>里面的72改成74，因为这里的<code>nr_system_calls</code>指的是总共有多少个系统调用。</p><h2 id="修改Makefile"><a href="#修改Makefile" class="headerlink" title="修改Makefile"></a>修改<code>Makefile</code></h2><p>修改内容如下，在<code>OBJS</code>最后添加<code>who.o</code>，让内核中包含<code>who.c</code>里面的内容。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJS  = sched.o system_call.o traps.o asm.o fork.o \</span><br><span class="line">panic.o printk.o vsprintf.o sys.o exit.o \</span><br><span class="line">signal.o mktime.o who.o</span><br></pre></td></tr></table></figure><p>然后在末尾添加如下内容，对<code>who.c</code>编译，链接。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who.s who.o: who.c  ../<span class="keyword">include</span>/linux/kernel.h ../<span class="keyword">include</span>/unistd.h <span class="comment">#! add who.c</span></span><br></pre></td></tr></table></figure><h2 id="编写who-c"><a href="#编写who-c" class="headerlink" title="编写who.c"></a>编写<code>who.c</code></h2><p>在<code>who.c</code>中要实现<code>iam()</code>和<code>whami()</code>这两个函数，这里参考了[<a href="https://ehye.github.io/2020/04/01/hit-oslab2/][https://ehye.github.io/2020/04/01/hit-oslab2/]" target="_blank" rel="noopener">https://ehye.github.io/2020/04/01/hit-oslab2/][https://ehye.github.io/2020/04/01/hit-oslab2/]</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/segment.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> myname[<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_iam</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">25</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123; <span class="comment">// get char from user input</span></span><br><span class="line">        str[i] = get_fs_byte(name + i);</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt;= <span class="number">25</span> &amp;&amp; str[i++] != <span class="string">'\0'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">24</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(myname, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_whoami</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>(myname);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt; length)&#123;</span><br><span class="line">        <span class="keyword">return</span> -(EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// copy from kernel mode to user mode</span></span><br><span class="line">        put_fs_byte(myname[i], name + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上面的代码要注意的是，这里代码是位于内核态的。我们定义的数据都是在内核态中定义的。无法直接获取用户态的内容，所以这里用了两个函数<code>get_fs_byte</code>和<code>put_fs_byte</code>，第一个用来得到用户态的数据，第二个用来将数据存入用户态</strong>。</p><h2 id="编写iam-和whoami"><a href="#编写iam-和whoami" class="headerlink" title="编写iam()和whoami()"></a>编写<code>iam()</code>和<code>whoami()</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//iam()在用户空间的接口函数</span></span><br><span class="line"><span class="comment">// 这是定义在unistd.h里面的一个宏，展开后是一个包含int 0x80中断的代码。</span></span><br><span class="line">_syscall1(<span class="keyword">int</span>, iam, <span class="keyword">const</span> <span class="keyword">char</span>*, name);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    iam(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIBRARY__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// whoami()在用户空间的接口函数</span></span><br><span class="line"><span class="comment">// 这是定义在unistd.h里面的一个宏，展开后是一个包含int 0x80中断的代码。</span></span><br><span class="line">_syscall2(<span class="keyword">int</span>, whoami,<span class="keyword">char</span>*,name,<span class="keyword">unsigned</span> <span class="keyword">int</span>,<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">    whoami(name, <span class="number">30</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里要注意的是，<strong><code>#define __LIBRARY__</code>一定要在<code>#include &lt;unistd.h&gt;</code>前面，要不然就会报错</strong>，具体是什么原因，我现在还不清楚。</p><h2 id="调试运行"><a href="#调试运行" class="headerlink" title="调试运行"></a>调试运行</h2><p>完成上述的修改，并且重新编译运行linux-0.11后，在linux-0.11里面输入下面的命令，验证结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o iam iam.c</span><br><span class="line">$ gcc -o whoami whoami.c</span><br><span class="line">$ ./iam hello,world</span><br><span class="line">$ ./whoami</span><br><span class="line">hello,world</span><br></pre></td></tr></table></figure><h2 id="提交验证"><a href="#提交验证" class="headerlink" title="提交验证"></a>提交验证</h2><p>使用老师提供的<code>testlab2.c</code>和<code>testlab2.sh</code>来验证我们的代码，过程如下，需要在linux-0.11里面运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o iam iam.c</span><br><span class="line">$ gcc -o whoami whoami.c</span><br><span class="line">$ gcc testlab2.c</span><br><span class="line">$ ./a.out</span><br><span class="line"></span><br><span class="line">$ ./testlab2.sh</span><br></pre></td></tr></table></figure><p>运行<code>a.out</code>和<code>testlab2.sh</code>后的结果如下：</p><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/testlab2.c.jpg" width="600"></center><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/testlab2.sh.jpg" width="600"></center>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;实验2-系统调用&quot;&gt;&lt;a href=&quot;#实验2-系统调用&quot; class=&quot;headerlink&quot; title=&quot;实验2: 系统调用&quot;&gt;&lt;/a&gt;实验2: 系统调用&lt;/h1&gt;&lt;h2 id=&quot;实验内容&quot;&gt;&lt;a href=&quot;#实验内容&quot; class=&quot;headerlink&quot; title=&quot;实验内容&quot;&gt;&lt;/a&gt;实验内容&lt;/h2&gt;&lt;p&gt;在 Linux 0.11 上添加两个系统调用，并编写两个简单的应用程序测试它们。&lt;/p&gt;
&lt;h3 id=&quot;1-iam&quot;&gt;&lt;a href=&quot;#1-iam&quot; class=&quot;headerlink&quot; title=&quot;1. iam()&quot;&gt;&lt;/a&gt;1. &lt;code&gt;iam()&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;第一个系统调用是 iam()，其原型为：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;iam&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * name)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;完成的功能是将字符串参数 &lt;code&gt;name&lt;/code&gt; 的内容拷贝到内核中保存下来。要求 &lt;code&gt;name&lt;/code&gt; 的长度不能超过 23 个字符。返回值是拷贝的字符数。如果 &lt;code&gt;name&lt;/code&gt; 的字符个数超过了 &lt;code&gt;23&lt;/code&gt;，则返回 “-1”，并置 errno 为 EINVAL。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;kernal/who.c&lt;/code&gt; 中实现此系统调用。&lt;/p&gt;
&lt;h3 id=&quot;2-whoami&quot;&gt;&lt;a href=&quot;#2-whoami&quot; class=&quot;headerlink&quot; title=&quot;2. whoami()&quot;&gt;&lt;/a&gt;2. &lt;code&gt;whoami()&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;第二个系统调用是 whoami()，其原型为：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;whoami&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* name, &lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;size&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;它将内核中由 &lt;code&gt;iam()&lt;/code&gt; 保存的名字拷贝到 name 指向的用户地址空间中，同时确保不会对 &lt;code&gt;name&lt;/code&gt; 越界访存（&lt;code&gt;name&lt;/code&gt; 的大小由 &lt;code&gt;size&lt;/code&gt; 说明）。返回值是拷贝的字符数。如果 &lt;code&gt;size&lt;/code&gt; 小于需要的空间，则返回“-1”，并置 errno 为 EINVAL。&lt;/p&gt;
&lt;p&gt;也是在 &lt;code&gt;kernal/who.c&lt;/code&gt; 中实现。&lt;/p&gt;
&lt;h3 id=&quot;3-测试程序&quot;&gt;&lt;a href=&quot;#3-测试程序&quot; class=&quot;headerlink&quot; title=&quot;3. 测试程序&quot;&gt;&lt;/a&gt;3. 测试程序&lt;/h3&gt;&lt;p&gt;运行添加过新系统调用的 Linux 0.11，在其环境下编写两个测试程序 iam.c 和 whoami.c。最终的运行结果是：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ ./iam lizhijun&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ ./whoami&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lizhijun&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;系统调用简介&quot;&gt;&lt;a href=&quot;#系统调用简介&quot; class=&quot;headerlink&quot; title=&quot;系统调用简介&quot;&gt;&lt;/a&gt;系统调用简介&lt;/h2&gt;&lt;p&gt;系统调用和一般的函数调用在使用方式上没有区别，区别在于调用之后函数内部如何处理。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="https://haohuaijin.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>华为云ubuntu配置nginx踩坑记录</title>
    <link href="https://haohuaijin.github.io/2020/09/06/%E5%8D%8E%E4%B8%BA%E4%BA%91ubuntu%E9%85%8D%E7%BD%AEnginx%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://haohuaijin.github.io/2020/09/06/%E5%8D%8E%E4%B8%BA%E4%BA%91ubuntu%E9%85%8D%E7%BD%AEnginx%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2020-09-06T00:46:41.000Z</published>
    <updated>2020-09-06T01:29:11.830Z</updated>
    
    <content type="html"><![CDATA[<p>服务器：华为云<br>操作系统： ubuntu 18.04<br>今天在华为云上配置nginx发现怎么也配置不成功，<strong>不能在浏览器上访问，同时也ping不通，不过在云服务器上的nginx是成功运行的。</strong></p><p>最后终于找到了解决办法，更改华为云的安全组配置，配置80端口，同时将它设置下面的内容，如图</p><center class="third">    <img src="https://gitee.com/Hao-132/figure/raw/master/img/华为云.png" width="700"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;服务器：华为云&lt;br&gt;操作系统： ubuntu 18.04&lt;br&gt;今天在华为云上配置nginx发现怎么也配置不成功，&lt;strong&gt;不能在浏览器上访问，同时也ping不通，不过在云服务器上的nginx是成功运行的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后终于找到了解决办法，更
      
    
    </summary>
    
    
    
      <category term="踩坑" scheme="https://haohuaijin.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>macos vim 进入可视块模式</title>
    <link href="https://haohuaijin.github.io/2020/08/08/macos-vim-%E8%BF%9B%E5%85%A5%E5%8F%AF%E8%A7%86%E5%9D%97%E6%A8%A1%E5%BC%8F/"/>
    <id>https://haohuaijin.github.io/2020/08/08/macos-vim-%E8%BF%9B%E5%85%A5%E5%8F%AF%E8%A7%86%E5%9D%97%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-08-08T14:43:16.000Z</published>
    <updated>2020-08-08T14:55:03.515Z</updated>
    
    <content type="html"><![CDATA[<p>在windows的vim上进入vim的块模式是<code>&lt;ctrl&gt;-v</code>。于是我以为在mac上应该是<code>&lt;command&gt;-v</code> ，试了试发现<code>&lt;command&gt;-v</code>是粘贴。然后去google搜索发现没有具体讲这个的，在这里记录一下。</p><p><strong>在macos中使用<code>&lt;control&gt;-v</code>就可以进入vim的块模式(列选择)。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在windows的vim上进入vim的块模式是&lt;code&gt;&amp;lt;ctrl&amp;gt;-v&lt;/code&gt;。于是我以为在mac上应该是&lt;code&gt;&amp;lt;command&amp;gt;-v&lt;/code&gt; ，试了试发现&lt;code&gt;&amp;lt;command&amp;gt;-v&lt;/code&gt;是粘贴。然后
      
    
    </summary>
    
    
    
      <category term="vim" scheme="https://haohuaijin.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>matlab for mac 打开cftool卡死解决方案</title>
    <link href="https://haohuaijin.github.io/2020/08/01/matlab-for-mac-%E6%89%93%E5%BC%80cftool%E5%8D%A1%E6%AD%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://haohuaijin.github.io/2020/08/01/matlab-for-mac-%E6%89%93%E5%BC%80cftool%E5%8D%A1%E6%AD%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2020-08-01T00:53:57.000Z</published>
    <updated>2020-08-01T01:17:44.620Z</updated>
    
    <content type="html"><![CDATA[<p>在mac上安装完matlab后，想试一试cftool的打开速度，结果一打开cftool就卡死了，然后去网上找了许多的资料，多没有想到相关的信息。</p><p>最后在matlab中文论坛发现有人在用matlab仿真时死机，解决方案是<strong>magnet对matlab仅用</strong>。于是我就试了试，成功解决问题。</p><p>如果你也有类似的问题，不妨试一试把Magnet对matlab禁用。</p><p>原地址：<a href="https://www.ilovematlab.cn/thread-579451-1-1.html" target="_blank" rel="noopener">https://www.ilovematlab.cn/thread-579451-1-1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在mac上安装完matlab后，想试一试cftool的打开速度，结果一打开cftool就卡死了，然后去网上找了许多的资料，多没有想到相关的信息。&lt;/p&gt;
&lt;p&gt;最后在matlab中文论坛发现有人在用matlab仿真时死机，解决方案是&lt;strong&gt;magnet对matlab
      
    
    </summary>
    
    
    
      <category term="bugs" scheme="https://haohuaijin.github.io/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>遗传算法学习笔记</title>
    <link href="https://haohuaijin.github.io/2020/07/30/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://haohuaijin.github.io/2020/07/30/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-30T01:45:58.000Z</published>
    <updated>2020-08-01T01:14:32.125Z</updated>
    
    <content type="html"><![CDATA[<p>遗传算法是一种启发式的优化算法，具有很大的灵活性。之所以较遗传算法，这要是因为算法的过程模拟了自然选择。遗传算法的应用领域非常的广，适用于复杂的问题，同时还具有很大的灵活性，可以自主设计很多算子。</p><p>下面介绍遗传算法的主要流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">初始化种群</span><br><span class="line">计算种群的适应度和累积概率</span><br><span class="line">while iter &lt; itermax:</span><br><span class="line">复制 //剔除适应度低的，将适应度好的复制一份</span><br><span class="line">交叉 //二进制数字位数交换</span><br><span class="line">变异 //二进制位数取否</span><br><span class="line">重新计算适应度和累积概率</span><br><span class="line">end</span><br><span class="line">解码输出结果</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h2><p>编码的主要方式有<strong>二进制码，实数码和格雷码</strong>。一般用二进制来编码。在这一阶段是将一个变量或多个变量，根据其约束的定义域以及我们要得到的自变量的精度，选择合适的二进制位数将问题编码。例如变量$x$的区间是$(L,U)$，要求的精度是小数点后四位，也就意味着每个变量应该被分成至少$(L,U)\times 10^4$个部分，对一个变量的二进制数串位数用以下公式计算：<br>$$<br>2^{m_j-1} &lt; (U-L)\times 10^4 \le 2^{m_j}-1<br>$$<br>如果是多个变量的话，可以将他们各自编码后，连在一起。</p><p>解码的话使用下面的公式：<br>$$<br>x = L + \left( \sum_{i=1}^{k}b_i2^{i-1}\right)\cfrac{U-L}{2^k-1}<br>$$</p><h2 id="2-评价个体的适应度"><a href="#2-评价个体的适应度" class="headerlink" title="2. 评价个体的适应度"></a>2. 评价个体的适应度</h2><p>这里的适应度函数对应于自然选择，我们需要根据自己的实际问题来设定适应度函数，适应度函数的目的是，将种群中好的和差的区分开来。例如在求函数最大值的时候，适应度函数就是函数本身。下面是步骤：</p><ol><li>计算染色体$U_k$的适应度值</li></ol><p>$$<br>eval(U_k) = f(x^k),\quad k = 1,2,···<br>$$</p><ol start="2"><li>计算种群的适应度总和</li></ol><p>$$<br>F = \sum_{k=1}^{n}eval(U_k)<br>$$</p><ol start="3"><li>计算每个染色体被复制的概率</li></ol><p>$$<br>P_k = \cfrac{eval(U_k)}{F}<br>$$</p><ol start="4"><li>计算每个染色体被复制的累积概率</li></ol><p>$$<br>Q_k = \sum_{j-1}^kP_k<br>$$</p><h2 id="3-新种群复制"><a href="#3-新种群复制" class="headerlink" title="3. 新种群复制"></a>3. 新种群复制</h2><p>可以有好几种方法，常见的是根据前面计算的累积概率$Q_k$，利用计算机随机生成<code>0-1</code>的随机数，看看随机数落到那个区间里面，取区间右边那个累积概率对应的$k$值，复制个体。</p><p>举个例子现在有四个个体他们的累积概率是<code>0.2</code>，<code>0.3</code>，<code>0.5</code>，<code>1.0</code>。假设现在生成了个随机数为<code>0.4</code>，他现在是落在了<code>0.3-0.5</code>的区间里，所以我们将右侧的<code>0.5</code>复制一遍。</p><h2 id="4-种群的交配和变异"><a href="#4-种群的交配和变异" class="headerlink" title="4. 种群的交配和变异"></a>4. 种群的交配和变异</h2><p>和染色体的交换类似，<strong>交配</strong>就是在两个二进制数中选取一位，然后将他们后面的所有为进行交换。</p><p><strong>变异</strong>是将二进制数，其中的一位取否。</p><h2 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h2><p>将上面的过程不断的重复，直到最大的迭代次数或者种群不在进化。</p><p>在遗传算法中，我认为比较重要的几个方面是，</p><ul><li><strong>适应度函数的确定</strong>，面对实际问题时我们要设计适应度函数往往与实验相结合(假死酵母菌)。同时在遗传算法不同的阶段使用不同的适应度函数，回去的不同的效果。</li><li><strong>各种算子的设计</strong>，在我们进行遗传算法的过程中，现在已经有的算子有复制，交叉，变异等等，算子应该满足的条件是<strong>稳定，可变</strong>。我们可以根据不同的问题设计不同的算子。</li></ul><h2 id="6-应用"><a href="#6-应用" class="headerlink" title="6. 应用"></a>6. 应用</h2><ul><li>假丝酵母菌求解最优的浓度。</li><li>我的想法是将遗传算法，用来求解神经网络的参数。</li><li>各种复杂的，非线性的优化问题。</li></ul><h2 id="7-代码"><a href="#7-代码" class="headerlink" title="7. 代码"></a>7. 代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%主程序：用遗传算法求解y=200*exp(-0.05*x).*sin(x)在[-2 2]区间上的最大值</span></span><br><span class="line">clc;</span><br><span class="line">clear all;</span><br><span class="line">close all;</span><br><span class="line"><span class="keyword">global</span> BitLength</span><br><span class="line"><span class="keyword">global</span> boundsbegin</span><br><span class="line"><span class="keyword">global</span> boundsend</span><br><span class="line">bounds=[<span class="number">-2</span> <span class="number">2</span>];<span class="comment">%一维自变量的取值范围</span></span><br><span class="line">precision=<span class="number">0.0001</span>; <span class="comment">%运算精度</span></span><br><span class="line">boundsbegin=bounds(:,<span class="number">1</span>);</span><br><span class="line">boundsend=bounds(:,<span class="number">2</span>);</span><br><span class="line"><span class="comment">%计算如果满足求解精度至少需要多长的染色体</span></span><br><span class="line">BitLength=<span class="built_in">ceil</span>(<span class="built_in">log2</span>((boundsend-boundsbegin)' ./ precision));</span><br><span class="line">popsize=<span class="number">50</span>; <span class="comment">%初始种群大小</span></span><br><span class="line">Generationnmax=<span class="number">12</span>;  <span class="comment">%最大代数</span></span><br><span class="line">pcrossover=<span class="number">0.90</span>; <span class="comment">%交配概率</span></span><br><span class="line">pmutation=<span class="number">0.09</span>; <span class="comment">%变异概率</span></span><br><span class="line"><span class="comment">%产生初始种群</span></span><br><span class="line">population=<span class="built_in">round</span>(<span class="built_in">rand</span>(popsize,BitLength));</span><br><span class="line"><span class="comment">%计算适应度,返回适应度Fitvalue和累积概率cumsump</span></span><br><span class="line">[Fitvalue,cumsump]=fitnessfun(population);  </span><br><span class="line">Generation=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> Generation&lt;Generationnmax+<span class="number">1</span></span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="number">2</span>:popsize </span><br><span class="line">      <span class="comment">%选择操作</span></span><br><span class="line">      seln=selection(population,cumsump);</span><br><span class="line">      <span class="comment">%交叉操作</span></span><br><span class="line">      scro=crossover(population,seln,pcrossover);</span><br><span class="line">      scnew(<span class="built_in">j</span>,:)=scro(<span class="number">1</span>,:);</span><br><span class="line">      scnew(<span class="built_in">j</span>+<span class="number">1</span>,:)=scro(<span class="number">2</span>,:);</span><br><span class="line">      <span class="comment">%变异操作</span></span><br><span class="line">      smnew(<span class="built_in">j</span>,:)=mutation(scnew(<span class="built_in">j</span>,:),pmutation);</span><br><span class="line">      smnew(<span class="built_in">j</span>+<span class="number">1</span>,:)=mutation(scnew(<span class="built_in">j</span>+<span class="number">1</span>,:),pmutation);</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   population=smnew;  <span class="comment">%产生了新的种群</span></span><br><span class="line">   <span class="comment">%计算新种群的适应度   </span></span><br><span class="line">   [Fitvalue,cumsump]=fitnessfun(population);</span><br><span class="line">   <span class="comment">%记录当前代最好的适应度和平均适应度</span></span><br><span class="line">   [fmax,nmax]=<span class="built_in">max</span>(Fitvalue);</span><br><span class="line">   fmean=<span class="built_in">mean</span>(Fitvalue);</span><br><span class="line">   ymax(Generation)=fmax;</span><br><span class="line">   ymean(Generation)=fmean;</span><br><span class="line">   <span class="comment">%记录当前代的最佳染色体个体</span></span><br><span class="line">   x=transform2to10(population(nmax,:));</span><br><span class="line">   <span class="comment">%自变量取值范围是[-2 2],需要把经过遗传运算的最佳染色体整合到[-2 2]区间</span></span><br><span class="line">   xx=boundsbegin+x*(boundsend-boundsbegin)/(power((boundsend),BitLength)<span class="number">-1</span>);</span><br><span class="line">   xmax(Generation)=xx;</span><br><span class="line">   Generation=Generation+<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Generation=Generation<span class="number">-1</span>;</span><br><span class="line">Bestpopulation=xx</span><br><span class="line">Besttargetfunvalue=targetfun(xx)</span><br><span class="line"></span><br><span class="line"><span class="comment">%绘制经过遗传运算后的适应度曲线。一般地，如果进化过程中种群的平均适应度与最大适</span></span><br><span class="line"><span class="comment">%应度在曲线上有相互趋同的形态，表示算法收敛进行得很顺利，没有出现震荡；在这种前</span></span><br><span class="line"><span class="comment">%提下，最大适应度个体连续若干代都没有发生进化表明种群已经成熟。</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">hand1=<span class="built_in">plot</span>(<span class="number">1</span>:Generation,ymax);</span><br><span class="line">set(hand1,<span class="string">'linestyle'</span>,<span class="string">'-'</span>,<span class="string">'linewidth'</span>,<span class="number">1.8</span>,<span class="string">'marker'</span>,<span class="string">'*'</span>,<span class="string">'markersize'</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">hand2=<span class="built_in">plot</span>(<span class="number">1</span>:Generation,ymean);</span><br><span class="line">set(hand2,<span class="string">'color'</span>,<span class="string">'r'</span>,<span class="string">'linestyle'</span>,<span class="string">'-'</span>,<span class="string">'linewidth'</span>,<span class="number">1.8</span>,...</span><br><span class="line"><span class="string">'marker'</span>,<span class="string">'h'</span>,<span class="string">'markersize'</span>,<span class="number">6</span>)</span><br><span class="line">xlabel(<span class="string">'进化代数'</span>);ylabel(<span class="string">'最大/平均适应度'</span>);xlim([<span class="number">1</span> Generationnmax]);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">'最大适应度'</span>,<span class="string">'平均适应度'</span>);</span><br><span class="line">box off;<span class="built_in">hold</span> off;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遗传算法是一种启发式的优化算法，具有很大的灵活性。之所以较遗传算法，这要是因为算法的过程模拟了自然选择。遗传算法的应用领域非常的广，适用于复杂的问题，同时还具有很大的灵活性，可以自主设计很多算子。&lt;/p&gt;
&lt;p&gt;下面介绍遗传算法的主要流程：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;初始化种群&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;计算种群的适应度和累积概率&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while iter &amp;lt; itermax:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	复制 //剔除适应度低的，将适应度好的复制一份&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	交叉 //二进制数字位数交换&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	变异 //二进制位数取否&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	重新计算适应度和累积概率&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解码输出结果&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="数学建模" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之运输层</title>
    <link href="https://haohuaijin.github.io/2020/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>https://haohuaijin.github.io/2020/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2020-07-07T03:23:49.000Z</published>
    <updated>2020-09-06T01:28:34.294Z</updated>
    
    <content type="html"><![CDATA[<p>这里主要讲的是在运输层几个比较重要的技术，即多路分解和复用，可靠数据传输原理和拥塞原理。</p><h2 id="1-多路复用-分解"><a href="#1-多路复用-分解" class="headerlink" title="1. 多路复用/分解"></a>1. 多路复用/分解</h2><p>先给出官方定义，将主机间交付扩展到进程间交付被称为<strong>运输层的多路复用和分解</strong>。<strong>多路分解</strong>就是在运输层接收到来自网络层数据后，根据运输层报文特殊字段的信息，将运输层报文段的数据交付到正确的套接字中。<strong>多路复用</strong>就是在运输层接受到<strong>套接字</strong>数据后，根据套接字的不同，生成<strong>运输层报文特殊字段</strong>(用于分解)，然后将报文发送到网络层。通俗来说，多路复用和分解可以让<strong>不同进程的报文</strong>来使用<strong>相同的运输层协议</strong>(TCP，UDP)运输报文。</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/多路复用分解.png" width="600"></center><p>如图，运输层通过多路复用和分解，实现数据的正确交付。</p><p>下面这句话引用自计算机网络自顶向下方法，可以加深我们的理解：</p><blockquote><p>尽管我们在因特网运输层协议的环境下引入了多路复用和多路分解，认识到下列事实是重要的：</p><p>他们与在某层(在运输层或别处)的单一协议何时被位于接下来的较高层的多个协议使用有关。</p></blockquote><h5 id="那么如何实现多路复用和分解呢？"><a href="#那么如何实现多路复用和分解呢？" class="headerlink" title="那么如何实现多路复用和分解呢？"></a>那么如何实现多路复用和分解呢？</h5><a id="more"></a><p>需要两个条件：</p><ol><li>每个套接字有唯一的<strong>标识符</strong>(也就是<strong>端口号</strong>)</li><li>也就是前面讲的，运输层报文的特殊字段(<strong>包含源端口号和目的端口号</strong>)</li></ol><p>根据运输层协议的不同，UDP和TCP的报文中的特殊字段不同。</p><p><strong>补充：</strong></p><ol><li><strong>套接字接口</strong>的作用，把来自进程的数据传输到运输层，并且把来自运输层的数据传送的特定的进程。</li><li>每一个套接字分配一个<strong>端口号</strong>用来作为套接字的标识符。</li><li>运输层报文的格式基本如下所示：</li></ol><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/运输层报文格式.png" width="350"></center><p>下面具体讲一下UDP和TCP的多路复用和分解。</p><h3 id="1-1-UDP的多路复用-分解"><a href="#1-1-UDP的多路复用-分解" class="headerlink" title="1.1 UDP的多路复用/分解"></a>1.1 UDP的多路复用/分解</h3><p>在UDP中一个套接字是由一个二元组全面标识的，二元组中包含了一个<strong>目的IP地址和目的端口号</strong>。</p><p>举个例子：假设现在有A，B，C三个主机，A和B同时通过2333端口号与C主机的3333端口号通信，这是A和B的目的端口号都是3333，所以他们<strong>通过相同的套接字进入相同的进程</strong>。这里的源端口号是用来从C向A，B发送报文时使用的。</p><h3 id="1-2-TCP的多路复用-分解"><a href="#1-2-TCP的多路复用-分解" class="headerlink" title="1.2 TCP的多路复用/分解"></a>1.2 TCP的多路复用/分解</h3><p>TCP中的一个套接字是有四元组标识的，即<strong>目的IP地址，目的端口号，源IP地址和源端口号</strong>。</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/TCP多路复用.png" width="700"></center><p>如图很好展示了TCP如何来识别套接字。</p><h2 id="2-可靠数据传输原理"><a href="#2-可靠数据传输原理" class="headerlink" title="2. 可靠数据传输原理"></a>2. 可靠数据传输原理</h2><p>首先要明确，我们真实的网络环境会发生<strong>比特差错</strong>和<strong>丢包的</strong>。</p><p>可靠数据传输主要包含以下几个技术，差错检验，肯定确认(ACK)，序号，定时器，回退N步，累计确认，选择确认等等。</p><p><strong>注意：</strong> 我这里讲的是，可靠数据传输用到的一些技术方法，并没有具体TCP或UDP报文。</p><p>下面分别介绍上面的技术:</p><h3 id="2-1-差错检验"><a href="#2-1-差错检验" class="headerlink" title="2.1 差错检验"></a>2.1 差错检验</h3><p>差错检验用来检测报文在传输的过程中有没有发生错误，具体的方法还没学到。</p><h3 id="2-2-肯定确认ACK-positive-Acknowledgment-和否定确认-NAK"><a href="#2-2-肯定确认ACK-positive-Acknowledgment-和否定确认-NAK" class="headerlink" title="2.2 肯定确认ACK(positive Acknowledgment)和否定确认(NAK)"></a>2.2 肯定确认ACK(positive Acknowledgment)和否定确认(NAK)</h3><p>简单地说，就是接受端每当收到一个<strong>正确报文</strong>，就发送一个<strong>ACK</strong>来告诉发送端他收到了。而如果报文在运输的过程中出现了错误(比如差错检验没通过)，这时接收端就会<strong>丢弃刚刚收到的报文</strong>，并且发送一个<strong>NAK</strong>来告诉发送端重新发送上一个报文。</p><p><strong>注意:</strong>  由于我们真实的网络环境是会发生<strong>比特差错的</strong>，所以ACK和NAK也会发生错误。举个例子，现在 接收端正确收到了报文A，并且发送了一个ACK，不过由于传输中发生了错误，<strong>ACK变成了NAK</strong>。这时接受端收到了错误的ACK，由于不确定，发送端会重新发送上一个报文，但是这时接受端<strong>已经正确接受到了报文</strong>，所以接受端再次接受的正确的报文A时，接受端就发生了冗余(他自己没办法判断是不是冗余)。解决这个问题这个问题的方法就是接下来要讲的序号。</p><h3 id="2-3-序号"><a href="#2-3-序号" class="headerlink" title="2.3 序号"></a>2.3 序号</h3><p>序号就是给每一个发送报文附上一个<strong>递增的序号</strong>，同时返回的ACK上也包含这个序号，表示此序号的确认。通过序号就可以完美的解决2.2出现的问题，<strong>根据序号的不同</strong>接受端就可以准确的判断报文是不是相同。</p><p>在TCP中，初始序号是由计算随机计生成，而返回的ACK的序号是<strong>报文的编号</strong>加上<strong>报文数据部分的字节数</strong>。分送端第二次发送的报文的编号，则是由上一次的ACK指定。</p><p>其实，我们现在可以只用ACK来确认，在接受端收到<strong>受损报文</strong>后，发送上一个报文ACK，当接收端再一次收到ACK时(<strong>冗余ACK，对一个报文的ACK接收端到多次ACK</strong>)，他就知到报文受损了，所以他重新发送报文。下面只使用ACK。</p><h3 id="2-4-定时器"><a href="#2-4-定时器" class="headerlink" title="2.4 定时器"></a>2.4 定时器</h3><p>定时器的设定是因为在真实的网络环境中，会出现<strong>丢包</strong>的情况。</p><p>举个例子，假设现在发送端向接受端发送了一个报文A，考虑一下两种情况：</p><ol><li>报文A，在发送的途中丢失了</li><li>接受端收到了报文了，但是返回的ACK丢失了</li></ol><p>以上的情况都会导致发送端收不到ACK，于是我们可以设定一个<strong>定时器</strong>和一个<strong>超时间隔</strong>，当发送方在指定的超时间隔内没有收到ACK后，发送端就<strong>重新发送报文A</strong>。</p><h3 id="2-5-流水线技术"><a href="#2-5-流水线技术" class="headerlink" title="2.5 流水线技术"></a>2.5 流水线技术</h3><p>到现在为止，我们讨论的运输都是发送一个数据，返回一个ACK，然后在发送一个数据，这样的方式叫做<strong>停等协议</strong>。但是如果数据运输的时间比较长的话，停等协议的信道利用率是非常低的。所以引入了<strong>流水线协议</strong>，即一次可以发送多个报文。如图a是停等协议，图b是流水线协议。</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/流水线1.png" width="350"></center><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/流水线2.png" width="350"></center><p>使用流水线协议会带来以下的影响(参考Top-Down，这里的逻辑我没怎么理清)：</p><ol><li><strong>必须增加序号的范围</strong>，因为每个输送中的的分组(不计算重传的)必须有一个唯一的序号，而且有多个在输送中的未确认报文。</li><li><strong>协议的发送方和接收方两端也许不得不缓存多个分组</strong>。发送方最低限应当能缓冲哪些已发送但未确认的分组，如下面们讨论的那样，接收方或许也需要缓存那些以正确接受的分组。</li><li>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失，损坏及延时过大的分组。解决流水线的差错恢复有两种基本方法是：<strong>回退N步</strong>(Go-Back-N，GBN)和<strong>选择重传</strong>(Selective Repeat，SR)。</li></ol><h3 id="2-6-回退N步"><a href="#2-6-回退N步" class="headerlink" title="2.6 回退N步"></a>2.6 回退N步</h3><p>流水线技术，可以使我们不用等待<strong>上一个发送报文ACK</strong>，就可以发送新的报文。但是我们不能无限制的发送新报文，所以规定了一个数字N(也叫窗口长度，把N个报文称为<strong>窗口</strong>)，作为最大的<strong>已发送还未确认报文</strong>的数目。如图</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/回退N步.png" width="800"></center><p><strong>发送端的功能：</strong></p><ol><li>接受上层的调用</li><li>发送数据时，<strong>已发送还未确认的报文</strong>最多不超过N。只有当现在的报文被确认后才能发送新的报文(在图上的表现就是，把窗口右移)。</li><li><strong>超时后</strong>，把现在窗口中所有的报文所有的<strong>已经发送还未确认的报文</strong>重新发送一遍。</li></ol><p><strong>接收端的功能：</strong></p><ol><li>接收到的报文序号正确时，发送一个ACK。</li><li>接收到的报文序号不正确时，不发送ACK。</li><li>采取<strong>累计确认</strong>的方法，即ACK是对他以及他之前所有报文的确认。</li></ol><p>如图下面的窗口的大小为4，当出现超时后，发送端重新发送所有的报文。</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/回退N步演示.png" width="500"></center><h3 id="2-7-选择重传"><a href="#2-7-选择重传" class="headerlink" title="2.7 选择重传"></a>2.7 选择重传</h3><p>GBN可以提高信道的利用率，但是它也会到来一些问题。当窗口的长度N比较大的时候，前面报文的丢失会导致后面所有报文的重传，这样显然效率不高。于是有了选择重传。</p><p>选择重传就是接受端将那些失序到达的报文，接受并且发送一个ACK。所以他采取的不是累计确认，而是一个ACK确认一个报文。在发送端只有接收到每一个发送报文的ACK，才确切的知道报文已经发送。下面描述发送端，和接收端的功能。</p><p><strong>发送端：</strong></p><ol><li>接受上层的调用</li><li>发送端维护一个大小N的窗口(<strong>从第一个发送未确认报文开始，大小为N</strong>)，第一个报文接受的ACK是窗口右移。</li><li>超时时，发送端重新发送窗口N中，那些<strong>发送但未确认的报文</strong>。</li></ol><p><strong>接收端：</strong></p><ol><li>只要有报文到达，就发送ACK。</li></ol><p>如图展示了选择重传协议的作用：</p><center class="third">    <img src="https://gitee.com/Hao-132/blogimage/raw/master/img/选择重传.png" width="600"></center><h2 id="3-拥塞控制原理"><a href="#3-拥塞控制原理" class="headerlink" title="3. 拥塞控制原理"></a>3. 拥塞控制原理</h2><p>拥塞控制主要有两种方法：</p><ol><li><strong>端到端的拥塞控制</strong>，在运输层实现，TCP的拥塞控制。</li><li><strong>网络辅助的拥塞控制</strong>，路由器向发送方提供关于网络的拥塞情况。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里主要讲的是在运输层几个比较重要的技术，即多路分解和复用，可靠数据传输原理和拥塞原理。&lt;/p&gt;
&lt;h2 id=&quot;1-多路复用-分解&quot;&gt;&lt;a href=&quot;#1-多路复用-分解&quot; class=&quot;headerlink&quot; title=&quot;1. 多路复用/分解&quot;&gt;&lt;/a&gt;1. 多路复用/分解&lt;/h2&gt;&lt;p&gt;先给出官方定义，将主机间交付扩展到进程间交付被称为&lt;strong&gt;运输层的多路复用和分解&lt;/strong&gt;。&lt;strong&gt;多路分解&lt;/strong&gt;就是在运输层接收到来自网络层数据后，根据运输层报文特殊字段的信息，将运输层报文段的数据交付到正确的套接字中。&lt;strong&gt;多路复用&lt;/strong&gt;就是在运输层接受到&lt;strong&gt;套接字&lt;/strong&gt;数据后，根据套接字的不同，生成&lt;strong&gt;运输层报文特殊字段&lt;/strong&gt;(用于分解)，然后将报文发送到网络层。通俗来说，多路复用和分解可以让&lt;strong&gt;不同进程的报文&lt;/strong&gt;来使用&lt;strong&gt;相同的运输层协议&lt;/strong&gt;(TCP，UDP)运输报文。&lt;/p&gt;
&lt;center class=&quot;third&quot;&gt;
    &lt;img src=&quot;https://gitee.com/Hao-132/blogimage/raw/master/img/多路复用分解.png&quot; width=&quot;600&quot;&gt;
&lt;/center&gt;

&lt;p&gt;如图，运输层通过多路复用和分解，实现数据的正确交付。&lt;/p&gt;
&lt;p&gt;下面这句话引用自计算机网络自顶向下方法，可以加深我们的理解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;尽管我们在因特网运输层协议的环境下引入了多路复用和多路分解，认识到下列事实是重要的：&lt;/p&gt;
&lt;p&gt;他们与在某层(在运输层或别处)的单一协议何时被位于接下来的较高层的多个协议使用有关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;那么如何实现多路复用和分解呢？&quot;&gt;&lt;a href=&quot;#那么如何实现多路复用和分解呢？&quot; class=&quot;headerlink&quot; title=&quot;那么如何实现多路复用和分解呢？&quot;&gt;&lt;/a&gt;那么如何实现多路复用和分解呢？&lt;/h5&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="https://haohuaijin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>7-11 Saving James Bond - Hard Version (30 分)</title>
    <link href="https://haohuaijin.github.io/2019/11/05/7-11%20Saving%20James%20Bond%20-%20Hard%20Version%20(30%20%E5%88%86)/"/>
    <id>https://haohuaijin.github.io/2019/11/05/7-11%20Saving%20James%20Bond%20-%20Hard%20Version%20(30%20%E5%88%86)/</id>
    <published>2019-11-05T09:40:31.000Z</published>
    <updated>2019-11-05T09:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>原题链接：<a href="https://pintia.cn/problem-sets/16/problems/673" target="_blank" rel="noopener">https://pintia.cn/problem-sets/16/problems/673</a><br>这道题本质是就是一道BFS，只不过要加上路径。<br>&emsp;开始做的时候比较顺利，但是总是有一个测试点没过去，找了半天还是找不到错误。于是google一下，发现是没仔细看题。<br>&emsp;题目中说，当有<strong>多条最短路径时，选择第一跳最短的</strong>。我竟然么看见(😭😭找了两个多小时)。处理第一条最短，比较简单的做法时我们在用BFS，一开始把鳄鱼入队时，就把顺序排好，这样出来的一定是最终的结果。</p><h6 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h6><p>在处理能不能在两个鳄鱼之间跳时，一是可以先计算好能不能跳，然后直接在BFS里用结果。二是在BFS的过程中，判断能不能跳。<br>其实我个人比较推荐第二种，没必要先计算好，现算现用就行。不过如果计算的结构要多次使用的话，保存下来了比较好。</p><a id="more"></a><h6 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INFO = <span class="number">1000000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> X,Y;</span><br><span class="line">    Node() &#123;&#125; <span class="comment">//用来不初始化定义Ver[101]</span></span><br><span class="line">    Node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y) : X(_x),Y(_y) &#123;&#125; <span class="comment">//用来提供X和Y的初始值</span></span><br><span class="line">&#125;Ver[MAX];</span><br><span class="line"><span class="keyword">int</span> Path[MAX]; <span class="comment">//记录路径</span></span><br><span class="line"><span class="keyword">int</span> N,D;</span><br><span class="line"><span class="keyword">bool</span> book[MAX]; <span class="comment">//记录是否访问</span></span><br><span class="line"><span class="keyword">int</span> last = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsVertexJump</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123; <span class="comment">//能不能从a到b</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">pow</span>(Ver[a].X-Ver[b].X,<span class="number">2</span>) + <span class="built_in">pow</span>(Ver[a].Y-Ver[b].Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsSave</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; <span class="comment">//a能不能到岸</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">pow</span>(Ver[a].X,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D,<span class="number">2</span>) || <span class="built_in">pow</span>(Ver[a].Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D,<span class="number">2</span>) || \</span><br><span class="line">        <span class="built_in">pow</span>(<span class="number">100</span>-Ver[a].X,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D,<span class="number">2</span>) || <span class="built_in">pow</span>(<span class="number">100</span>-Ver[a].Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsCenterJump</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123; <span class="comment">//能不能从中心跳出</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pow</span>(Ver[a].X<span class="number">-50</span>,<span class="number">2</span>) + <span class="built_in">pow</span>(Ver[a].Y<span class="number">-50</span>,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(D + <span class="number">7.5</span>,<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">pow</span>(Ver[a].X<span class="number">-50</span>,<span class="number">2</span>) + <span class="built_in">pow</span>(Ver[a].Y<span class="number">-50</span>,<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123; <span class="comment">//排序的比较函数</span></span><br><span class="line">    <span class="keyword">return</span> IsCenterJump(x)&lt;IsCenterJump(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Save007</span><span class="params">()</span></span>&#123; <span class="comment">//无权图单源最短路</span></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> b[MAX]; <span class="comment">//用来把第一跳排序</span></span><br><span class="line">    <span class="built_in">fill</span>(Path, Path+N+<span class="number">1</span>, INFO);</span><br><span class="line">    <span class="built_in">fill</span>(book, book+N+<span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    Path[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    book[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(IsSave(<span class="number">0</span>))&#123;</span><br><span class="line">        last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123; <span class="comment">//对第一跳排序</span></span><br><span class="line">        b[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b+<span class="number">1</span>,b+N+<span class="number">1</span>,cmp); <span class="comment">//why 第二个是N + 1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123; <span class="comment">//按靠近center的顺序，放入queue</span></span><br><span class="line">        <span class="keyword">if</span>(IsCenterJump(b[i]))&#123;</span><br><span class="line">            q.push(b[i]);</span><br><span class="line">            Path[b[i]] = <span class="number">0</span>;</span><br><span class="line">            book[b[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        temp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(IsSave(temp))&#123; <span class="comment">//能不能到岸</span></span><br><span class="line">            last = temp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!book[i] &amp;&amp; IsVertexJump(temp,i))&#123;</span><br><span class="line">                q.push(i);</span><br><span class="line">                Path[i] = temp;</span><br><span class="line">                book[i] = <span class="literal">true</span>; <span class="comment">//在入队时就book</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> a[MAX]; <span class="comment">//记录最短路径</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Ver[<span class="number">0</span>] = Node(<span class="number">50</span>,<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;D);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        Ver[i] = Node(x+<span class="number">50</span>,y+<span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Save007();</span><br><span class="line">    <span class="keyword">if</span>(last == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);<span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(last &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            a[count++] = last;</span><br><span class="line">            last = Path[last];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,count+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=count<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,Ver[a[i]].X<span class="number">-50</span>,Ver[a[i]].Y<span class="number">-50</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原题链接：&lt;a href=&quot;https://pintia.cn/problem-sets/16/problems/673&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pintia.cn/problem-sets/16/problems/673&lt;/a&gt;&lt;br&gt;这道题本质是就是一道BFS，只不过要加上路径。&lt;br&gt;&amp;emsp;开始做的时候比较顺利，但是总是有一个测试点没过去，找了半天还是找不到错误。于是google一下，发现是没仔细看题。&lt;br&gt;&amp;emsp;题目中说，当有&lt;strong&gt;多条最短路径时，选择第一跳最短的&lt;/strong&gt;。我竟然么看见(😭😭找了两个多小时)。处理第一条最短，比较简单的做法时我们在用BFS，一开始把鳄鱼入队时，就把顺序排好，这样出来的一定是最终的结果。&lt;/p&gt;
&lt;h6 id=&quot;思路：&quot;&gt;&lt;a href=&quot;#思路：&quot; class=&quot;headerlink&quot; title=&quot;思路：&quot;&gt;&lt;/a&gt;思路：&lt;/h6&gt;&lt;p&gt;在处理能不能在两个鳄鱼之间跳时，一是可以先计算好能不能跳，然后直接在BFS里用结果。二是在BFS的过程中，判断能不能跳。&lt;br&gt;其实我个人比较推荐第二种，没必要先计算好，现算现用就行。不过如果计算的结构要多次使用的话，保存下来了比较好。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="BFS" scheme="https://haohuaijin.github.io/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>7-10 Saving James Bond - Easy Version (25分)</title>
    <link href="https://haohuaijin.github.io/2019/11/02/7-10-Saving%20James-Bond-Easy-Version-25%E5%88%86/"/>
    <id>https://haohuaijin.github.io/2019/11/02/7-10-Saving%20James-Bond-Easy-Version-25%E5%88%86/</id>
    <published>2019-11-02T07:59:34.000Z</published>
    <updated>2019-11-02T08:01:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个题主要是审好题目，做起来就简单了。<br>下面有两种方法：</p><h3 id="一、先将是不是有边，是否与岸有连接算出来"><a href="#一、先将是不是有边，是否与岸有连接算出来" class="headerlink" title="一、先将是不是有边，是否与岸有连接算出来"></a>一、先将是不是有边，是否与岸有连接算出来</h3><p><strong>步骤：</strong><br>1、读入数据，计算输入点是不是可以到岸。<br>2、对权值初始化，计算各点之间是不是有线。<br>3、一次DFS搜索，看看是不是能从中心到岸边。</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">101</span>]; <span class="comment">//是否访问</span></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Flee[<span class="number">101</span>]; <span class="comment">//是否可以逃跑</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INFO = <span class="number">100000</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> G[][<span class="number">101</span>],<span class="keyword">int</span> Nv)</span></span>&#123;</span><br><span class="line">    book[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(Flee[i] == <span class="number">1</span>) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= Nv;j++)&#123; <span class="comment">//注意一共Nv+1个点</span></span><br><span class="line">        <span class="keyword">if</span>(!book[j] &amp;&amp; G[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">            DFS(j,G,Nv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> Nv; <span class="comment">//顶点数</span></span><br><span class="line">    <span class="keyword">int</span> X[<span class="number">101</span>],Y[<span class="number">101</span>]; <span class="comment">//顶点坐标</span></span><br><span class="line">    <span class="keyword">int</span> Dist; <span class="comment">//跳的最远距离</span></span><br><span class="line">    <span class="keyword">int</span> G[<span class="number">101</span>][<span class="number">101</span>]; <span class="comment">//是否有边</span></span><br><span class="line">    X[<span class="number">0</span>] = Y[<span class="number">0</span>] = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;Nv,&amp;Dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= Nv;i++)&#123; <span class="comment">//读入X，Y并计算能不能从哪里逃出</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        X[i] = x + <span class="number">50</span>;</span><br><span class="line">        Y[i] = y + <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pow</span>(Y[i],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>) || <span class="built_in">pow</span>(X[i],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>)||\</span><br><span class="line">            <span class="built_in">pow</span>(<span class="number">100</span>-Y[i],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>) || <span class="built_in">pow</span>(<span class="number">100</span>-X[i],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>))</span><br><span class="line">            Flee[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= Nv;i++)&#123; <span class="comment">//初始化权值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= Nv;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) G[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> G[i][j] = INFO;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pow</span>(X[i]-X[j],<span class="number">2</span>) + <span class="built_in">pow</span>(Y[i]-Y[j],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>))&#123;</span><br><span class="line">                G[i][j] = <span class="number">1</span>;</span><br><span class="line">                G[j][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= Nv;j++)&#123; <span class="comment">//中间有一个直径15的陆地</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pow</span>(X[<span class="number">0</span>]-X[j],<span class="number">2</span>) + <span class="built_in">pow</span>(Y[<span class="number">0</span>]-Y[j],<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist+<span class="number">7.5</span>,<span class="number">2</span>))&#123;</span><br><span class="line">            G[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            G[j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(<span class="number">0</span>,G,Nv);</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、在线处理，是不是有边，是否到岸"><a href="#二、在线处理，是不是有边，是否到岸" class="headerlink" title="二、在线处理，是不是有边，是否到岸"></a>二、在线处理，是不是有边，是否到岸</h3><p><strong>思路：</strong><br>主要的思路就是用<strong>DFS</strong>，由于在湖中心时有一个平台，所以要进行特殊处理。<br>对于图的结构的选择，可以用也可以不用。图只是一个抽象的结构来帮助我们解题，怎么简单怎么写，不用拘泥于使用什么结构(比如邻接表，邻接矩阵，或者不用图的结构)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> X,Y;</span><br><span class="line">    <span class="keyword">bool</span> book;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsSave</span><span class="params">(Graph V,<span class="keyword">int</span> Dist)</span></span>&#123; <span class="comment">//能否到岸</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">pow</span>(V.X,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>) || <span class="built_in">pow</span>(V.Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>) || \</span><br><span class="line">        <span class="built_in">pow</span>(<span class="number">100</span>-V.X,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>) || <span class="built_in">pow</span>(<span class="number">100</span>-V.Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsCanJump</span><span class="params">(Graph V1,Graph V2,<span class="keyword">int</span> Dist)</span></span>&#123; <span class="comment">//能否从V1跳到V2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(V1.X-V2.X,<span class="number">2</span>) + <span class="built_in">pow</span>(V1.Y-V2.Y,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> Nv,<span class="keyword">int</span> Dist,Graph G[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> answer = <span class="literal">false</span>;</span><br><span class="line">    G[index].book = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(IsSave(G[index],Dist))&#123;</span><br><span class="line">        answer = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= Nv; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!G[i].book &amp;&amp; IsCanJump(G[index],G[i],Dist))&#123;</span><br><span class="line">                answer = DFS(i,Nv,Dist,G);</span><br><span class="line">                <span class="keyword">if</span>(answer == <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsCenterJump</span><span class="params">(Graph V,<span class="keyword">int</span> Dist)</span></span>&#123; <span class="comment">//计算从中心跳出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(V.X<span class="number">-50</span>,<span class="number">2</span>) + <span class="built_in">pow</span>(V.Y<span class="number">-50</span>,<span class="number">2</span>) &lt;= <span class="built_in">pow</span>(Dist + <span class="number">7.5</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Save007</span><span class="params">(<span class="keyword">int</span> Nv,<span class="keyword">int</span> Dist,Graph G[])</span></span>&#123; <span class="comment">// 对起点特殊处理</span></span><br><span class="line">    <span class="keyword">bool</span> answer = <span class="literal">false</span>;</span><br><span class="line">    G[<span class="number">0</span>].book = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Nv; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!G[i].book &amp;&amp; IsCenterJump(G[i],Dist))&#123;</span><br><span class="line">            answer = DFS(i,Nv,Dist,G);</span><br><span class="line">            <span class="keyword">if</span>(answer == <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Nv,Dist,x,y;</span><br><span class="line">    <span class="keyword">int</span> answer;</span><br><span class="line">    Graph G[<span class="number">101</span>]; <span class="comment">//发生了一次运行时错误,指针越界</span></span><br><span class="line">    G[<span class="number">0</span>].X = G[<span class="number">0</span>].Y = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;Nv,&amp;Dist);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Nv; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        G[i].X = x + <span class="number">50</span>;</span><br><span class="line">        G[i].Y = y + <span class="number">50</span>;</span><br><span class="line">        G[i].book = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    answer = Save007(Nv,Dist,G);</span><br><span class="line">    <span class="keyword">if</span>(answer) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个题主要是审好题目，做起来就简单了。&lt;br&gt;下面有两种方法：&lt;/p&gt;
&lt;h3 id=&quot;一、先将是不是有边，是否与岸有连接算出来&quot;&gt;&lt;a href=&quot;#一、先将是不是有边，是否与岸有连接算出来&quot; class=&quot;headerlink&quot; title=&quot;一、先将是不是有边，是否与岸有连接算出来&quot;&gt;&lt;/a&gt;一、先将是不是有边，是否与岸有连接算出来&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;br&gt;1、读入数据，计算输入点是不是可以到岸。&lt;br&gt;2、对权值初始化，计算各点之间是不是有线。&lt;br&gt;3、一次DFS搜索，看看是不是能从中心到岸边。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="DFS" scheme="https://haohuaijin.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>7-6 列出连通集 (25分)</title>
    <link href="https://haohuaijin.github.io/2019/10/26/7-6-%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86-25%E5%88%86/"/>
    <id>https://haohuaijin.github.io/2019/10/26/7-6-%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86-25%E5%88%86/</id>
    <published>2019-10-26T12:04:11.000Z</published>
    <updated>2019-10-26T12:05:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要考察了DFS，和BFS的基本操作。考察我们对图的构建，以及运用DFS和BFS对图进行遍历。<br>DFS是运用了递归的思想，<br>而BFS则可以通过队列来实现。<br>我在做题时遇到的困难，主要是在<strong>BFS的思路</strong>和<strong>队列</strong>的实现上。因为队列原来以为很熟，但现在一写很多细节都忘了。<br><strong>所以数据结构要经常写，要不然忘得很快。</strong><br>下面是代码，可能有点冗杂。</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">Graph</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;</span><br><span class="line">    <span class="keyword">int</span> Ne;</span><br><span class="line">    <span class="keyword">int</span> Vertex[<span class="number">11</span>];</span><br><span class="line">    <span class="keyword">int</span> Edge[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">QNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    QNode Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QNode rear,front;</span><br><span class="line">&#125;*Queue;</span><br><span class="line"><span class="keyword">int</span> book[<span class="number">11</span>]; <span class="comment">//纪录访问的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v1,v2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;G-&gt;Nv,&amp;G-&gt;Ne);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Nv;i++) G-&gt;Vertex[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Nv;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G-&gt;Nv;j++)</span><br><span class="line">            G-&gt;Edge[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Ne;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;v1,&amp;v2);</span><br><span class="line">        G-&gt;Edge[v1][v2] = <span class="number">1</span>;</span><br><span class="line">        G-&gt;Edge[v2][v1] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">QNode <span class="title">CreateQNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    QNode q = (QNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    q-&gt;Data = <span class="number">-1</span>;</span><br><span class="line">    q-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Queue <span class="title">CreateQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Queue q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    q-&gt;rear = q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(Queue Q,<span class="keyword">int</span> X)</span></span>&#123;</span><br><span class="line">    QNode q = CreateQNode();</span><br><span class="line">    q-&gt;Data = X;</span><br><span class="line">    q-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front == <span class="literal">NULL</span>)</span><br><span class="line">        Q-&gt;rear = Q-&gt;front = q;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q-&gt;rear-&gt;Next = q; <span class="comment">//使q成为最后一个元素</span></span><br><span class="line">        Q-&gt;rear = q; <span class="comment">//更新rear</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteQ</span><span class="params">(Queue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear == Q-&gt;front)&#123; <span class="comment">//分类讨论</span></span><br><span class="line">        x = Q-&gt;front-&gt;Data;</span><br><span class="line">        Q-&gt;rear = Q-&gt;front = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        QNode q = Q-&gt;front;</span><br><span class="line">        x = q-&gt;Data;</span><br><span class="line">        Q-&gt;front = q-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(book[i] == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        book[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G-&gt;Nv;j++)</span><br><span class="line">            <span class="keyword">if</span>(G-&gt;Edge[i][j] == <span class="number">1</span>) <span class="comment">//加不加book[j] == 0</span></span><br><span class="line">                DFS(G,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Queue Q,Graph G,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X;</span><br><span class="line">    AddQ(Q,i);</span><br><span class="line">    book[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(Q-&gt;front != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        X = DeleteQ(Q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>,X);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G-&gt;Nv;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(book[j] == <span class="number">0</span> &amp;&amp; G-&gt;Edge[j][X] == <span class="number">1</span>)&#123;</span><br><span class="line">                AddQ(Q,j);</span><br><span class="line">                book[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Graph G;</span><br><span class="line">    G = (Graph)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GNode));</span><br><span class="line">    CreateGraph(G);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Nv;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(book[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&#123;"</span>);</span><br><span class="line">            DFS(G,i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" &#125;\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Nv;i++) book[i] = <span class="number">0</span>;</span><br><span class="line">    Queue Q = CreateQueue();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G-&gt;Nv;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(book[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"&#123;"</span>);</span><br><span class="line">            BFS(Q,G,i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" &#125;\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要考察了DFS，和BFS的基本操作。考察我们对图的构建，以及运用DFS和BFS对图进行遍历。&lt;br&gt;DFS是运用了递归的思想，&lt;br&gt;而BFS则可以通过队列来实现。&lt;br&gt;我在做题时遇到的困难，主要是在&lt;strong&gt;BFS的思路&lt;/strong&gt;和&lt;strong&gt;队列&lt;/strong&gt;的实现上。因为队列原来以为很熟，但现在一写很多细节都忘了。&lt;br&gt;&lt;strong&gt;所以数据结构要经常写，要不然忘得很快。&lt;/strong&gt;&lt;br&gt;下面是代码，可能有点冗杂。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="BFS" scheme="https://haohuaijin.github.io/tags/BFS/"/>
    
      <category term="DFS" scheme="https://haohuaijin.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>7-2 Reversing Linked List (25分)</title>
    <link href="https://haohuaijin.github.io/2019/10/13/7-2-Reversing-Linked-List-25%E5%88%86/"/>
    <id>https://haohuaijin.github.io/2019/10/13/7-2-Reversing-Linked-List-25%E5%88%86/</id>
    <published>2019-10-13T01:40:46.000Z</published>
    <updated>2019-10-13T01:45:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题可能一开始看题目一头雾水，但是仔细思考就会发现并不太难。<br>下面是我的思路：<br><strong>1、</strong>用类似静态链表的方法，来表示List，即一个数组存Data，一个数组存Next<br><strong>2、</strong>循环遍历链表，用<code>a[]</code>记录下标。<br><strong>3、</strong>根据K来转置链表，修改Next，然后转置<code>a[]</code>(<strong>顺序很重要</strong>)。</p><a id="more"></a><p><strong>AC代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> <span class="comment">//类此静态链表</span></span><br><span class="line">    <span class="keyword">int</span> Address,Next,Data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reavers</span><span class="params">(<span class="keyword">int</span> *front,<span class="keyword">int</span> *rear,<span class="keyword">int</span> k)</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,a[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> *p = front;p != rear+<span class="number">1</span>;p++)&#123; <span class="comment">//先储存</span></span><br><span class="line">        a[i++] = *p;</span><br><span class="line">    &#125; </span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> *p = rear;p != front<span class="number">-1</span>;p--)&#123; </span><br><span class="line">        *p = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first,total,k,count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *a;</span><br><span class="line">    List *p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;first,&amp;total,&amp;k);</span><br><span class="line">    p = (List*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node)*total);</span><br><span class="line">    a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*total); <span class="comment">//存索引</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;p[i].Address,&amp;p[i].Data,&amp;p[i].Next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123; <span class="comment">//将List恢复正常序列,用a[]记录索引。 复杂度n^2 应优化这里(结果去掉break)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first == p[i].Address)&#123;</span><br><span class="line">                a[count++] = i;</span><br><span class="line">                first = p[i].Next;</span><br><span class="line"><span class="comment">//                break; //原来找到1个就break,改进后一直往下找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(first == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用count代表有多少结点在链表上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(count/k);i++)&#123; <span class="comment">//逆转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=k<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            p[a[j+i*k]].Next = p[a[j+i*k<span class="number">-1</span>]].Address;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>) p[a[i*k<span class="number">-1</span>]].Next = p[a[k+i*k<span class="number">-1</span>]].Address; <span class="comment">//修改逆转序列的前一个元素的Next</span></span><br><span class="line">        <span class="comment">//注意前后的连接</span></span><br><span class="line">        <span class="keyword">if</span>(i == count/k - <span class="number">1</span> &amp;&amp; (count%k == <span class="number">0</span>)) p[a[i*k]].Next = <span class="number">-1</span>; <span class="comment">//修改逆转序列的最后元素的Next</span></span><br><span class="line">        <span class="keyword">else</span> p[a[i*k]].Next = p[a[i*k+k]].Address;</span><br><span class="line">        Reavers((a+k*i),(a+k*(i+<span class="number">1</span>)<span class="number">-1</span>),k); <span class="comment">//逆转索引a[]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == count - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%05d %d %d\n"</span>,p[a[i]].Address,p[a[i]].Data,p[a[i]].Next);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>,p[a[i]].Address,p[a[i]].Data,p[a[i]].Next);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题可能一开始看题目一头雾水，但是仔细思考就会发现并不太难。&lt;br&gt;下面是我的思路：&lt;br&gt;&lt;strong&gt;1、&lt;/strong&gt;用类似静态链表的方法，来表示List，即一个数组存Data，一个数组存Next&lt;br&gt;&lt;strong&gt;2、&lt;/strong&gt;循环遍历链表，用&lt;code&gt;a[]&lt;/code&gt;记录下标。&lt;br&gt;&lt;strong&gt;3、&lt;/strong&gt;根据K来转置链表，修改Next，然后转置&lt;code&gt;a[]&lt;/code&gt;(&lt;strong&gt;顺序很重要&lt;/strong&gt;)。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="https://haohuaijin.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>7-3 Pop Sequence (25分)</title>
    <link href="https://haohuaijin.github.io/2019/10/11/7-3-Pop-Sequence-25%E5%88%86/"/>
    <id>https://haohuaijin.github.io/2019/10/11/7-3-Pop-Sequence-25%E5%88%86/</id>
    <published>2019-10-11T08:28:44.000Z</published>
    <updated>2019-10-11T08:30:36.000Z</updated>
    
    <content type="html"><![CDATA[<p> <strong>1、</strong>刚开始受严蔚敏数据结构的启发，想用比较大小的方法来判断是不是出栈序列。但是发现最后一个测试点就是卡这个算法。<br> <strong>2、</strong>然后看了柳神的博客，自己根据理解重新写了算法，但是第二个测试点还是过不去，下面是我的想法。<br> 步骤：循环判断数组中的每一个数，初始化temp=1 ，用temp来判断当前数组的最大值。如果数组当前值<strong>小于temp</strong>，就出栈，若<strong>大于等于temp就入栈</strong>，直到temp等于最大值。如果超过栈的容量标记flag=0并且break。最后根据flag判断YES或NO。<br> <strong>3、</strong>但是上面的步骤不能通过第二个测试点。<br>于是参考了柳神的程序，得到了下面的程序：</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span> <span class="comment">//栈的定义</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    Stack *Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Stack *<span class="title">CreateNode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stack *p;</span><br><span class="line">    p = (Stack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line">    p-&gt;Data = <span class="number">0</span>;</span><br><span class="line">    p-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack *p,<span class="keyword">int</span> item)</span></span>&#123;</span><br><span class="line">    Stack *ptr = CreateNode();</span><br><span class="line">    ptr-&gt;Data = item;</span><br><span class="line">    ptr-&gt;Next = p-&gt;Next;</span><br><span class="line">    p-&gt;Next = ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;Next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(Stack *p)</span></span>&#123;</span><br><span class="line">    Stack *ptr = p-&gt;Next;</span><br><span class="line">    <span class="keyword">int</span> temp = ptr-&gt;Data;</span><br><span class="line">    p-&gt;Next = ptr-&gt;Next;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">(Stack *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;Next-&gt;Data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> **<span class="title">ReadData</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span> <span class="comment">//读取数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> **arr;</span><br><span class="line">    arr = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*(k));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123; <span class="comment">//为每一行分配地址</span></span><br><span class="line">        arr[j] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">            arr[i][j] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,k;</span><br><span class="line">    <span class="keyword">int</span> **ptr;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;m,&amp;n,&amp;k);</span><br><span class="line">    ptr = ReadData(m,n,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123; <span class="comment">//真正的模拟了栈</span></span><br><span class="line">        Stack *p = CreateNode();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//记录栈的容量</span></span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>; <span class="comment">//记录要检测数组下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            Push(p,j);count++;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; m) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span>(!IsEmpty(p) &amp;&amp; GetTop(p) == ptr[i][current])&#123;</span><br><span class="line">                Pop(p);count--;</span><br><span class="line">                current++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!IsEmpty) Pop(p);</span><br><span class="line">        <span class="keyword">if</span>(current == n) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123; <span class="comment">//为每一行分配地址</span></span><br><span class="line">        <span class="built_in">free</span>(*(ptr+j));</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;strong&gt;1、&lt;/strong&gt;刚开始受严蔚敏数据结构的启发，想用比较大小的方法来判断是不是出栈序列。但是发现最后一个测试点就是卡这个算法。&lt;br&gt; &lt;strong&gt;2、&lt;/strong&gt;然后看了柳神的博客，自己根据理解重新写了算法，但是第二个测试点还是过不去，下面是我的想法。&lt;br&gt; 步骤：循环判断数组中的每一个数，初始化temp=1 ，用temp来判断当前数组的最大值。如果数组当前值&lt;strong&gt;小于temp&lt;/strong&gt;，就出栈，若&lt;strong&gt;大于等于temp就入栈&lt;/strong&gt;，直到temp等于最大值。如果超过栈的容量标记flag=0并且break。最后根据flag判断YES或NO。&lt;br&gt; &lt;strong&gt;3、&lt;/strong&gt;但是上面的步骤不能通过第二个测试点。&lt;br&gt;于是参考了柳神的程序，得到了下面的程序：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="队列" scheme="https://haohuaijin.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>7-20 表达式的转换(25分)</title>
    <link href="https://haohuaijin.github.io/2019/10/07/7-20%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%20(25%20%E5%88%86)/"/>
    <id>https://haohuaijin.github.io/2019/10/07/7-20%20%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%20(25%20%E5%88%86)/</id>
    <published>2019-10-07T00:47:22.000Z</published>
    <updated>2019-10-07T00:47:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="历时三个半小时终于完成。"><a href="#历时三个半小时终于完成。" class="headerlink" title="历时三个半小时终于完成。"></a>历时三个半小时终于完成。</h3><p>这道题的难点主要是在处理<strong>数字前的正负号</strong>上，同时还应该注意数字<strong>有小数点</strong>并且<strong>不是一位数字</strong>。<br>因为在做题之前同学给我说过这道题，也知道几个坑，所以做题的过程比较顺利。</p><hr><p><strong>我的步骤如下：</strong><br>1、先完成不考虑<strong>数字前的正负号</strong>的程序。<br>2、考虑<strong>数字前的正负号</strong>，完善程序。<br>通过上面的步骤，做题的过程比较的顺利，把难题变成了简单的的题目。<br>在第二步的时候比较烧脑，因为我的<strong>想法比较简单</strong>，就是把所有的可能全都列出来，所以<strong>要花很多的时间考虑，验证</strong>。</p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>1、考虑问题要全面，在数字前正负号时要尽量列出所有的可能。<br>2、开始做题时有一个大体的思路就行，不必考虑的很周到。<br>3、要善于<strong>猜测试点</strong>。。在考试时测试点不会告诉我们，而是需要自己取探索。</p><h4 id="坑："><a href="#坑：" class="headerlink" title="坑："></a>坑：</h4><p><strong>这个题的一个坑就是，会在有的正数前加正号，但输出的时候不用输出正号。</strong>我就一直没过这个测试点，直到搜到了测试数据。</p><hr><h5 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h5><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带有头结点 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> s;</span><br><span class="line">    Stack Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//操作</span></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">()</span></span>; <span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack p,<span class="keyword">char</span> str)</span></span>; <span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack p)</span></span>; <span class="comment">//判断是不是为空</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Pop</span><span class="params">(Stack p)</span></span>; <span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetTop</span><span class="params">(Stack p)</span></span>; <span class="comment">//得到栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">majoy</span><span class="params">(Stack p,<span class="keyword">char</span> *s)</span></span>; <span class="comment">//后缀表达式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack p = CreateStack();</span><br><span class="line">    <span class="keyword">char</span> S[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[^\n]"</span>,S);</span><br><span class="line">    majoy(p,S); <span class="comment">//得到后缀表达式</span></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后缀表达式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">majoy</span><span class="params">(Stack p,<span class="keyword">char</span> *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *ptr = S;</span><br><span class="line">    <span class="keyword">while</span>(*ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理数字</span></span><br><span class="line">        <span class="keyword">if</span>((*ptr &gt;= <span class="string">'0'</span> &amp;&amp; *ptr &lt;= <span class="string">'9'</span>) || *ptr == <span class="string">'.'</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//处理小数点</span></span><br><span class="line">            <span class="keyword">while</span>((*ptr &gt;= <span class="string">'1'</span> &amp;&amp; *ptr &lt;= <span class="string">'9'</span>) || *ptr == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c"</span>,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 可有可无，为了防止指针错误可以用这个</span></span><br><span class="line"><span class="comment">        //处理开始的-5 </span></span><br><span class="line"><span class="comment">        else if((*ptr == '-' || *ptr == '+') &amp;&amp; ptr == S)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">        ptr++;</span></span><br><span class="line"><span class="comment">        if(*(ptr-1) == '+') printf("");</span></span><br><span class="line"><span class="comment">            else printf("-");</span></span><br><span class="line"><span class="comment">            while((*ptr &gt;= '1' &amp;&amp; *ptr &lt;= '9') || *ptr == '.')&#123;</span></span><br><span class="line"><span class="comment">                printf("%c",*ptr);</span></span><br><span class="line"><span class="comment">                ptr++;</span></span><br><span class="line"><span class="comment">                flag = 1;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">        <span class="comment">//专门处理-5这种情况</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((*ptr == <span class="string">'-'</span> || *ptr == <span class="string">'+'</span>) &amp;&amp; (*(ptr<span class="number">-1</span>)&gt;<span class="string">'9'</span> || *(ptr<span class="number">-1</span>)&lt;<span class="string">'0'</span>) &amp;&amp; *(ptr<span class="number">-1</span>) != <span class="string">')'</span> &amp;&amp; (*(ptr+<span class="number">1</span>)&gt;=<span class="string">'1'</span> &amp;&amp; *(ptr+<span class="number">1</span>)&lt;=<span class="string">'9'</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ptr++;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span>(*(ptr<span class="number">-1</span>) == <span class="string">'+'</span>) <span class="built_in">printf</span>(<span class="string">""</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">            <span class="keyword">while</span>((*ptr &gt;= <span class="string">'1'</span> &amp;&amp; *ptr &lt;= <span class="string">'9'</span>) || *ptr == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c"</span>,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理左括号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*ptr == <span class="string">'('</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Push(p,*ptr);</span><br><span class="line">            ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理右括号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*ptr == <span class="string">')'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将里面的全部抛出</span></span><br><span class="line">            <span class="keyword">while</span>(GetTop(p) != <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %c"</span>,Pop(p));</span><br><span class="line">            &#125;</span><br><span class="line">            Pop(p);</span><br><span class="line">            ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理加减号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*ptr == <span class="string">'-'</span> || *ptr == <span class="string">'+'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//处理空栈，或遇到左括号</span></span><br><span class="line">            <span class="keyword">if</span>(IsEmpty(p) || GetTop(p) == <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Push(p,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//全部抛出直到空栈或左括号</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!IsEmpty(p))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(GetTop(p) == <span class="string">'('</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %c"</span>,Pop(p));</span><br><span class="line">                &#125;</span><br><span class="line">                Push(p,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理乘除号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*ptr == <span class="string">'*'</span> || *ptr == <span class="string">'/'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//处理空栈，或遇到左括号</span></span><br><span class="line">            <span class="keyword">if</span>(IsEmpty(p) || GetTop(p) == <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Push(p,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遇到加减号同上</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(GetTop(p) == <span class="string">'-'</span> || GetTop(p) == <span class="string">'+'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Push(p,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理出栈的情况</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!IsEmpty(p) &amp;&amp; (GetTop(p) == <span class="string">'*'</span> || GetTop(p) == <span class="string">'/'</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(GetTop(p) == <span class="string">'('</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %c"</span>,Pop(p));</span><br><span class="line">                &#125;</span><br><span class="line">                Push(p,*ptr);</span><br><span class="line">                ptr++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后输出剩下运算符</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %c"</span>,Pop(p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack q;</span><br><span class="line">    q = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    q-&gt;s = <span class="string">'\0'</span>;</span><br><span class="line">    q-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Stack p,<span class="keyword">char</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack ptr;</span><br><span class="line">    ptr = CreateStack();</span><br><span class="line">    ptr-&gt;s = str;</span><br><span class="line">    ptr-&gt;Next = p-&gt;Next; <span class="comment">//注意指向的位置</span></span><br><span class="line">    p-&gt;Next = ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">Pop</span><span class="params">(Stack p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack ptr;</span><br><span class="line">    <span class="keyword">char</span> str;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(p))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"栈空\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = p-&gt;Next;</span><br><span class="line">    str = ptr-&gt;s;</span><br><span class="line">    p-&gt;Next = ptr-&gt;Next;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是不是为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p-&gt;Next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">GetTop</span><span class="params">(Stack p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(p)) <span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;Next-&gt;s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文献:<a href="https://blog.csdn.net/SiKongPop/article/details/77972879#comments" target="_blank" rel="noopener">https://blog.csdn.net/SiKongPop/article/details/77972879#comments</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;历时三个半小时终于完成。&quot;&gt;&lt;a href=&quot;#历时三个半小时终于完成。&quot; class=&quot;headerlink&quot; title=&quot;历时三个半小时终于完成。&quot;&gt;&lt;/a&gt;历时三个半小时终于完成。&lt;/h3&gt;&lt;p&gt;这道题的难点主要是在处理&lt;strong&gt;数字前的正负号&lt;/strong&gt;上，同时还应该注意数字&lt;strong&gt;有小数点&lt;/strong&gt;并且&lt;strong&gt;不是一位数字&lt;/strong&gt;。&lt;br&gt;因为在做题之前同学给我说过这道题，也知道几个坑，所以做题的过程比较顺利。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;我的步骤如下：&lt;/strong&gt;&lt;br&gt;1、先完成不考虑&lt;strong&gt;数字前的正负号&lt;/strong&gt;的程序。&lt;br&gt;2、考虑&lt;strong&gt;数字前的正负号&lt;/strong&gt;，完善程序。&lt;br&gt;通过上面的步骤，做题的过程比较的顺利，把难题变成了简单的的题目。&lt;br&gt;在第二步的时候比较烧脑，因为我的&lt;strong&gt;想法比较简单&lt;/strong&gt;，就是把所有的可能全都列出来，所以&lt;strong&gt;要花很多的时间考虑，验证&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;总结：&quot;&gt;&lt;a href=&quot;#总结：&quot; class=&quot;headerlink&quot; title=&quot;总结：&quot;&gt;&lt;/a&gt;总结：&lt;/h4&gt;&lt;p&gt;1、考虑问题要全面，在数字前正负号时要尽量列出所有的可能。&lt;br&gt;2、开始做题时有一个大体的思路就行，不必考虑的很周到。&lt;br&gt;3、要善于&lt;strong&gt;猜测试点&lt;/strong&gt;。。在考试时测试点不会告诉我们，而是需要自己取探索。&lt;/p&gt;
&lt;h4 id=&quot;坑：&quot;&gt;&lt;a href=&quot;#坑：&quot; class=&quot;headerlink&quot; title=&quot;坑：&quot;&gt;&lt;/a&gt;坑：&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;这个题的一个坑就是，会在有的正数前加正号，但输出的时候不用输出正号。&lt;/strong&gt;我就一直没过这个测试点，直到搜到了测试数据。&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&quot;AC代码&quot;&gt;&lt;a href=&quot;#AC代码&quot; class=&quot;headerlink&quot; title=&quot;AC代码&quot;&gt;&lt;/a&gt;AC代码&lt;/h5&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="PTA" scheme="https://haohuaijin.github.io/tags/PTA/"/>
    
  </entry>
  
  <entry>
    <title>7-4 是否同一棵二叉搜索树(25分).md</title>
    <link href="https://haohuaijin.github.io/2019/10/06/7-4-%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-25%E5%88%86-/"/>
    <id>https://haohuaijin.github.io/2019/10/06/7-4-%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-25%E5%88%86-/</id>
    <published>2019-10-06T04:25:03.000Z</published>
    <updated>2019-10-06T14:21:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>开始是卡在怎么<strong>读数据</strong>上(果然还是读数据可怕，好几次都是卡在这里😭😭)，中间有1、2天没有再碰这道题。然后今天想着不能再拖了，就硬着头皮解出来了。</p><h6 id="想法："><a href="#想法：" class="headerlink" title="想法："></a>想法：</h6><p>一开始是想着不用构建树，用数组处理的，但是左思右想没有思路。<br>然后我就构建了<strong>树</strong>的结构，用<strong>前序遍历的方法来比较树是不是相同</strong>。<br>所以整体上来看思路比较简单。</p><a id="more"></a><h6 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这道题的主要思路是：</span></span><br><span class="line"><span class="comment"> * 就是让比结点大的数的插入顺序相同，比结点小的数的插入顺序相同。</span></span><br><span class="line"><span class="comment"> * 但是感觉上面的比较麻烦，我好像写不出来😭😭</span></span><br><span class="line"><span class="comment"> * 所以我把树建立了起来，然后用遍历的方法比较是不是相同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Leaves</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Leaves</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data;</span><br><span class="line">    Tree left,right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> **<span class="title">ReadData</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> l)</span></span>; <span class="comment">//读取数据</span></span><br><span class="line"><span class="function">Tree <span class="title">CreateNode</span><span class="params">(<span class="keyword">int</span> item)</span></span>; <span class="comment">//创造节点</span></span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree q,<span class="keyword">int</span> item)</span></span>; <span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreTraverse</span><span class="params">(Tree q)</span></span>; <span class="comment">//前序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> vec1[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> vec2[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,l;</span><br><span class="line">    <span class="keyword">int</span> **arr;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Tree front,rear; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;l);</span><br><span class="line">        <span class="comment">//读取到arr数据</span></span><br><span class="line">        arr = ReadData(n,l); </span><br><span class="line">        <span class="comment">//每一次循环将vec1，vec2化为零</span></span><br><span class="line">        <span class="built_in">memset</span>(vec1, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">100</span>); <span class="comment">//memset函数,将数组元素全化为0</span></span><br><span class="line">        <span class="built_in">memset</span>(vec2, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">100</span>); <span class="comment">//memset函数,将数组元素全化为0</span></span><br><span class="line">        <span class="comment">//初始化好第一棵树</span></span><br><span class="line">        front = CreateNode(arr[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) Insert(front,arr[<span class="number">0</span>][i]); <span class="comment">//初始化第一棵树</span></span><br><span class="line">        <span class="comment">//前序遍历第一棵树，保存在vec1中</span></span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        PreTraverse(front);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) vec1[i] = vec2[i]; <span class="comment">//将前序遍历的结果都存放在vec2中。见PreTraverse函数</span></span><br><span class="line">        <span class="comment">//遍历剩余的树并比较</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//初始化树</span></span><br><span class="line">            m = <span class="number">0</span>;flag = <span class="number">1</span>;</span><br><span class="line">            rear = CreateNode(arr[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++) Insert(rear,arr[i][j]); </span><br><span class="line">            <span class="comment">//遍历树</span></span><br><span class="line">            PreTraverse(rear);</span><br><span class="line">            <span class="comment">//比较</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;m<span class="number">-1</span>;n++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vec1[n] != vec2[n]) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放每一行的地址</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l; ++i) <span class="built_in">free</span>(*(arr + i));</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> **<span class="title">ReadData</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> **arr;</span><br><span class="line">    arr = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*(l+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=l;j++)&#123; <span class="comment">//为每一行分配地址</span></span><br><span class="line">        arr[j] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=l;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">            arr[i][j] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">CreateNode</span><span class="params">(<span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree q;</span><br><span class="line">    q = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Leaves));</span><br><span class="line">    q-&gt;Data = item;</span><br><span class="line">    q-&gt;left = q-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(Tree q,<span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!q)&#123;</span><br><span class="line">        q = CreateNode(<span class="number">0</span>);</span><br><span class="line">        q-&gt;Data = item;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(item &gt; q-&gt;Data)&#123;</span><br><span class="line">        q-&gt;right = Insert(q-&gt;right,item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(item &lt; q-&gt;Data)&#123;</span><br><span class="line">        q-&gt;left = Insert(q-&gt;left,item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreTraverse</span><span class="params">(Tree q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vec2[m++] = q-&gt;Data;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;left) PreTraverse(q-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;right) PreTraverse(q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始是卡在怎么&lt;strong&gt;读数据&lt;/strong&gt;上(果然还是读数据可怕，好几次都是卡在这里😭😭)，中间有1、2天没有再碰这道题。然后今天想着不能再拖了，就硬着头皮解出来了。&lt;/p&gt;
&lt;h6 id=&quot;想法：&quot;&gt;&lt;a href=&quot;#想法：&quot; class=&quot;headerlink&quot; title=&quot;想法：&quot;&gt;&lt;/a&gt;想法：&lt;/h6&gt;&lt;p&gt;一开始是想着不用构建树，用数组处理的，但是左思右想没有思路。&lt;br&gt;然后我就构建了&lt;strong&gt;树&lt;/strong&gt;的结构，用&lt;strong&gt;前序遍历的方法来比较树是不是相同&lt;/strong&gt;。&lt;br&gt;所以整体上来看思路比较简单。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="PTA" scheme="https://haohuaijin.github.io/tags/PTA/"/>
    
      <category term="树" scheme="https://haohuaijin.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>scanf()的用法总结</title>
    <link href="https://haohuaijin.github.io/2019/10/03/scanf-%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://haohuaijin.github.io/2019/10/03/scanf-%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2019-10-03T12:42:26.000Z</published>
    <updated>2019-10-03T12:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>最近在刷PTA数据结构时，发现自己对于scanf()的用法还不是很熟练，写下此篇做一记录。</strong></p><hr><h2 id="1、scanf-读入数字"><a href="#1、scanf-读入数字" class="headerlink" title="1、scanf() 读入数字"></a>1、scanf() 读入数字</h2><p>如果是只用<code>sacnf()</code>读入数字的话比较简单。<br>可以分为以下集中情况：</p><h6 id="1-1-在一行中，读入数字"><a href="#1-1-在一行中，读入数字" class="headerlink" title="1.1 在一行中，读入数字"></a>1.1 在一行中，读入数字</h6><p>假设读入三个：<br>用<code>scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</code>来处理就足够了。</p><h6 id="1-2-在多行中，读入数字"><a href="#1-2-在多行中，读入数字" class="headerlink" title="1.2 在多行中，读入数字"></a>1.2 在多行中，读入数字</h6><p>假设读入两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br></pre></td></tr></table></figure><p>因为读入的是数字，<code>scanf()</code>可以自动忽略空格和换行符，所以不需要特别的处理，和上面一样就行。<br><code>scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</code></p><a id="more"></a><h6 id="1-3-读入数字时，有特殊的要求"><a href="#1-3-读入数字时，有特殊的要求" class="headerlink" title="1.3 读入数字时，有特殊的要求"></a>1.3 读入数字时，有特殊的要求</h6><p>例如:<br>要读入以下的数据，得到年月日。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-10-3</span><br></pre></td></tr></table></figure><p>因为里面有<code>-</code>字符所以你<strong>没有办法直接的把数据读进来</strong>，但幸运的是<code>scanf()</code>给了我们一种简单的方法来处理这种情况。<br><code>scanf(&quot;%d-%d-%d&quot;,&amp;a,&amp;b,&amp;c);</code>，这样你就可以得到年月日，也就是a，b，c。<br>这样做的原因是，<strong>在<code>scanf()</code>里面写了什么，在输入时就要原样的输入</strong>，即在<code>scanf()</code>里面写了<code>-</code>，输入的时候也要在那个位置加上<code>-</code>。</p><hr><h2 id="2、scanf-读入字符"><a href="#2、scanf-读入字符" class="headerlink" title="2、scanf() 读入字符"></a>2、scanf() 读入字符</h2><p>相较于读入数字，读入字符就比较麻烦些。</p><h5 id="1-1-在一行中，读入字符"><a href="#1-1-在一行中，读入字符" class="headerlink" title="1.1 在一行中，读入字符"></a>1.1 在一行中，读入字符</h5><p>例如：<br>读入一下的数据，数据间用空格隔开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b c d</span><br></pre></td></tr></table></figure><p>因为现在读入的是字符，空格和换行符都属于字符，所以我们采用<br><strong>1.3</strong>的方法来读入数据<code>scanf(&quot;%c %c %c&quot;,&amp;a,&amp;b,&amp;c);</code>。<br><strong>或者</strong>用<code>scanf(&quot;%c%c%c%c%c&quot;,&amp;a,&amp;unused1,&amp;b,&amp;unused2,&amp;c);</code>来读取，中间定义了两个字符<code>unused1和unused2</code>来读取空格。</p><h5 id="1-2-在多行中，读入字符"><a href="#1-2-在多行中，读入字符" class="headerlink" title="1.2 在多行中，读入字符"></a>1.2 在多行中，读入字符</h5><p>这里和<strong>1.2在多行中，读入数字</strong>的主要的区别，就是要<strong>处理行末的换行符</strong>，下面介绍两种方法来处理这个，假设要输入以下的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a d</span><br><span class="line">c d</span><br></pre></td></tr></table></figure><p><strong>(1)</strong> 用<code>getchar()</code>来处理换行符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char a,b,c,d;</span><br><span class="line">scanf(&quot;%c %c&quot;,&amp;a,&amp;b);</span><br><span class="line">getchar();</span><br><span class="line">scanf(&quot;%c %c&quot;,&amp;c,&amp;d);</span><br><span class="line">getchar();</span><br></pre></td></tr></table></figure><p><strong>(2)</strong> 用<code>scanf()</code>自行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char a,b,c,d;</span><br><span class="line">scanf(&quot;%c %c\n&quot;,&amp;a,&amp;b);</span><br><span class="line">scanf(&quot;%c %c\n&quot;,&amp;c,&amp;d);</span><br></pre></td></tr></table></figure><p>但是第二种方法，<strong>近几天</strong>不知道为什么在我的电脑上要多输入一次数据才可以正确的运行，前几天还可以正常的读入数据，不过<strong>在PTA上提交却没有问题</strong>。</p><h2 id="3、scanf-读入字符串"><a href="#3、scanf-读入字符串" class="headerlink" title="3、scanf() 读入字符串"></a>3、scanf() 读入字符串</h2><p>读入字符串比较简单，其中要注意的是，读入的字符串中<strong>不能有空格</strong>。如果有空格，就<strong>在空格处停止</strong>。<br><strong>如果要读入空格</strong>一个可行的方法就是用<code>scanf(&quot;%[^\n]&quot;,s);</code>来处理，这个表达式的意思是<strong>遇到换行符才停止读入</strong>，其中<code>scanf()</code>中<code>[]</code>里面<code>^</code>后面就是你要<strong>停止读入的字符</strong>，如把<code>\n</code>换成<code>s</code>意思就是遇到<code>s</code>就停止读入。<br>同时在<code>^</code>的后面可以放很多的字符，例如<code>scanf(&quot;%[^sdf]&quot;,s);</code>，意思就是遇到里面的任一个字符都停止读入。</p><p><strong>初学者，如果有遗漏或错误，请见谅。同时欢迎与我沟通交流。</strong></p><p><strong>好了今天记录下这些，剩下的以后再说。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;最近在刷PTA数据结构时，发现自己对于scanf()的用法还不是很熟练，写下此篇做一记录。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1、scanf-读入数字&quot;&gt;&lt;a href=&quot;#1、scanf-读入数字&quot; class=&quot;headerlink&quot; title=&quot;1、scanf() 读入数字&quot;&gt;&lt;/a&gt;1、scanf() 读入数字&lt;/h2&gt;&lt;p&gt;如果是只用&lt;code&gt;sacnf()&lt;/code&gt;读入数字的话比较简单。&lt;br&gt;可以分为以下集中情况：&lt;/p&gt;
&lt;h6 id=&quot;1-1-在一行中，读入数字&quot;&gt;&lt;a href=&quot;#1-1-在一行中，读入数字&quot; class=&quot;headerlink&quot; title=&quot;1.1 在一行中，读入数字&quot;&gt;&lt;/a&gt;1.1 在一行中，读入数字&lt;/h6&gt;&lt;p&gt;假设读入三个：&lt;br&gt;用&lt;code&gt;scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;a,&amp;amp;b,&amp;amp;c);&lt;/code&gt;来处理就足够了。&lt;/p&gt;
&lt;h6 id=&quot;1-2-在多行中，读入数字&quot;&gt;&lt;a href=&quot;#1-2-在多行中，读入数字&quot; class=&quot;headerlink&quot; title=&quot;1.2 在多行中，读入数字&quot;&gt;&lt;/a&gt;1.2 在多行中，读入数字&lt;/h6&gt;&lt;p&gt;假设读入两行：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 2 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4 5 6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;因为读入的是数字，&lt;code&gt;scanf()&lt;/code&gt;可以自动忽略空格和换行符，所以不需要特别的处理，和上面一样就行。&lt;br&gt;&lt;code&gt;scanf(&amp;quot;%d%d%d&amp;quot;,&amp;amp;a,&amp;amp;b,&amp;amp;c);&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="经验" scheme="https://haohuaijin.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="C语言" scheme="https://haohuaijin.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>7-4 List Leaves(25分)</title>
    <link href="https://haohuaijin.github.io/2019/10/03/7-4%20List%20Leaves%20(25%20%E5%88%86)/"/>
    <id>https://haohuaijin.github.io/2019/10/03/7-4%20List%20Leaves%20(25%20%E5%88%86)/</id>
    <published>2019-10-03T08:58:56.000Z</published>
    <updated>2019-10-03T08:58:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题在逻辑上并不难，难在我们可能树不是很熟悉上。<br>我用了<strong>静态链表</strong>的方法构造树，用<strong>循环队列</strong>来用数组实现队列。</p><p><strong>思路：</strong><br>1、将数据读进来用，找到<strong>根节点</strong>。<br>2、<strong>递归</strong>找到所有的<strong>叶子节点</strong>。<br>3、用<strong>队列实现层次遍历</strong>，来找到树各层的元素。<br>4、比较<strong>叶子节点</strong>和<strong>层次遍历的结果</strong>得到最终的结果。</p><h5 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码:"></a>AC代码:</h5><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Null -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//树的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">int</span> left,right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//队列的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">Queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Data[MAX];</span><br><span class="line">    <span class="keyword">int</span> front,rear;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ReadData</span><span class="params">(Tree q)</span></span>; <span class="comment">//读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindLeaves</span><span class="params">(Tree q,<span class="keyword">int</span> root)</span></span>; <span class="comment">//找到叶子节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(Queue q,<span class="keyword">int</span> number)</span></span>; <span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteQ</span><span class="params">(Queue q)</span></span>; <span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Queue q)</span></span>; <span class="comment">//是不是为空</span></span><br><span class="line"><span class="function">Queue <span class="title">CreateQ</span><span class="params">()</span></span>; <span class="comment">//创建队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">middle</span><span class="params">(Tree q,Queue p,<span class="keyword">int</span> root)</span></span>; <span class="comment">//层次遍历</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> count_mid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    Tree T;</span><br><span class="line">    Queue q = CreateQ(); <span class="comment">//初始化队列</span></span><br><span class="line">    T = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node)*(<span class="number">100</span>)); <span class="comment">//此步不能放在函数里</span></span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">    root = ReadData(T); <span class="comment">//读入数据</span></span><br><span class="line">    FindLeaves(T,root); <span class="comment">//找到所有的叶子节点</span></span><br><span class="line">    middle(T,q,root); <span class="comment">//得到层次遍历的结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count_mid;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;count;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid[i] == num[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d"</span>,mid[i]);</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" %d"</span>,mid[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">middle</span><span class="params">(Tree q,Queue p,<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    AddQ(p,root);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(p))</span><br><span class="line">    &#123;</span><br><span class="line">        temp = DeleteQ(p);</span><br><span class="line">        mid[count_mid++] = temp;</span><br><span class="line">        <span class="keyword">if</span>(q[temp].left != Null) AddQ(p,q[temp].left);</span><br><span class="line">        <span class="keyword">if</span>(q[temp].right != Null) AddQ(p,q[temp].right);</span><br><span class="line">    &#125;</span><br><span class="line">    mid[count_mid] = <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据,找到根节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ReadData</span><span class="params">(Tree q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> lt,rt; <span class="comment">//记录左右结点</span></span><br><span class="line">    <span class="keyword">int</span> root; <span class="comment">//根节点的下标</span></span><br><span class="line">    <span class="keyword">int</span> check[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//记录结点,找到根结点</span></span><br><span class="line">    <span class="keyword">int</span> n; <span class="comment">//读入的数据</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q[i].index = i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c %c"</span>,&amp;lt,&amp;rt);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span>(lt != <span class="string">'-'</span>)&#123;</span><br><span class="line">            q[i].left = lt - <span class="string">'0'</span>;</span><br><span class="line">            check[q[i].left] = <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> q[i].left = Null;</span><br><span class="line">        <span class="keyword">if</span>(rt != <span class="string">'-'</span>)&#123;</span><br><span class="line">            q[i].right = rt - <span class="string">'0'</span>;</span><br><span class="line">            check[q[i].right] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> q[i].right = Null;</span><br><span class="line">    &#125;</span><br><span class="line">    q[n].index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(check[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            root = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到叶子节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindLeaves</span><span class="params">(Tree q,<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q[root].left == Null &amp;&amp; q[root].right == Null)&#123;</span><br><span class="line">        num[count++] = root;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q[root].left != Null)&#123;</span><br><span class="line">        FindLeaves(q,q[root].left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q[root].right != Null)&#123;</span><br><span class="line">        FindLeaves(q,q[root].right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">(Queue q,<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((q-&gt;rear+<span class="number">1</span>)%MAX == q-&gt;front)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队满\n"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    q-&gt;Data[(++q-&gt;rear)%MAX] = number;</span><br><span class="line">    q-&gt;rear = (q-&gt;rear)%MAX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteQ</span><span class="params">(Queue q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;front == q-&gt;rear)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"队空\n"</span>); <span class="keyword">return</span> Null;</span><br><span class="line">    &#125;</span><br><span class="line">    number = q-&gt;Data[(++q-&gt;front)%MAX];</span><br><span class="line">    q-&gt;front = (q-&gt;front)%MAX;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建队列</span></span><br><span class="line"><span class="function">Queue <span class="title">CreateQ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    q = (Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line">    q-&gt;front = <span class="number">0</span>;</span><br><span class="line">    q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是不是为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Queue q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (q-&gt;front == q-&gt;rear);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题在逻辑上并不难，难在我们可能树不是很熟悉上。&lt;br&gt;我用了&lt;strong&gt;静态链表&lt;/strong&gt;的方法构造树，用&lt;strong&gt;循环队列&lt;/strong&gt;来用数组实现队列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;br&gt;1、将数据读进来用，找到&lt;strong&gt;根节点&lt;/strong&gt;。&lt;br&gt;2、&lt;strong&gt;递归&lt;/strong&gt;找到所有的&lt;strong&gt;叶子节点&lt;/strong&gt;。&lt;br&gt;3、用&lt;strong&gt;队列实现层次遍历&lt;/strong&gt;，来找到树各层的元素。&lt;br&gt;4、比较&lt;strong&gt;叶子节点&lt;/strong&gt;和&lt;strong&gt;层次遍历的结果&lt;/strong&gt;得到最终的结果。&lt;/p&gt;
&lt;h5 id=&quot;AC代码&quot;&gt;&lt;a href=&quot;#AC代码&quot; class=&quot;headerlink&quot; title=&quot;AC代码:&quot;&gt;&lt;/a&gt;AC代码:&lt;/h5&gt;
    
    </summary>
    
    
    
      <category term="数据结构" scheme="https://haohuaijin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="PTA" scheme="https://haohuaijin.github.io/tags/PTA/"/>
    
  </entry>
  
</feed>
